<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<title>File API</title>
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-WD" type="text/css" />
<link rel="stylesheet" href="respec-w3c.css" type="text/css" />
<link rel="stylesheet" href="style.css" type="text/css" />
<meta name="revision" content="$Id: FileAPI.html,v 1.1 2009-08-04 21:03:10 arangana Exp $" />

</head>
<body>
 <div class="head">
		<p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" width="72" height="48" alt="W3C" /></a></p>
		<h1 class="head">File API</h1>
		<h2 id="pagesubtitle">W3C Working Draft <em>1 August 2009</em></h2>
		 <dl><dt>This version:</dt>
		 <dd><a href="http://dev.w3.org/2006/webapi/FileUpload/publish/FileAPI.html">http://dev.w3.org/2006/webapi/FileUpload/publish/FileAPI.html</a></dd>
			 <dt>Latest public version:</dt><dd><a href="http://www.w3.org/TR/file-upload/">http://www.w3.org/TR/file-upload/</a></dd>
			 <dt>Previous version:</dt><dd></dd>
			 <dt>Editor:</dt><dd><span class="person"><a href="http://arunranga.com/">Arun Ranganathan</a> (<a href="http://blog.mozilla.com/standards">Mozilla</a>) &lt;<a href="mailto:arun@mozilla~HugASpammer.com">arunATmozillaDOTcom</a>&gt;</span></dd></dl>
		<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> ©2006
        <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
        (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>,
        <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and 
        <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document  use</a> rules apply.
       </p>
 </div>
 
 <hr />

  <div class="section"><h2 id="specabstract">Abstract</h2>
    
<p>
      This specification provides an <acronym title="Application Programming Interface">API</acronym>
      for representing file objects in web applications, as well as programmatically selecting them and accessing their data.  This includes:
</p>
		<ul>
			<li>A <a href="#FileList-if" class="if-name">FileList</a> interface, which represents an array of individually selected files from the underlying system.
			The user interface for selection can be invoked via <code>&lt;input type=&quot;file&quot;&gt;</code>, i.e. when the
			<code>input</code>
			element [<a href="#HTML5">HTML5</a>] is in the <a href="#FileUpload">File Upload</a> state, or through the <a href="#FileDialog-if" class="if-name">FileDialog</a> interface.</li>
			<li>A <a href="#FileData-if" class="if-name">FileData</a> interface, which provides asynchronous data accessors for file data via callback methods.</li>
          <li>A <a href="#File-if" class="if-name">File</a> interface, which includes readonly informational attributes about a file such as its name and its mediatype.</li>
          <li>A <a href="#FileError-if" class="if-name">FileError</a> interface, which defines the error codes used by this specification.</li>
        </ul>
	<p>The section on Requirements and Use Cases [<a href="#requirements">REQ</a>] covers the motivation behind this specification.</p>
    <p>
      This API is designed to be used in conjunction with other APIs on the web platform, notably: <a href="#XHR2" class="if-name">XMLHttpRequest</a>
      (e.g.  with an overloaded <code>send()</code> method for File objects), <code>postMessage</code> and the Drag and Drop API, defined in <a href="#HTML5">HTML5</a>, and
      <a href="#WebWorkers">Web Workers</a>. Additionally, it should be possible to programmatically obtain a list of files from the
      <code>input</code> element [<a href="#HTML5">HTML5</a>] when it is
      in the <a href="#FileUpload">File Upload state</a>.
      These kinds of behaviors are defined in the appropriate affiliated specifications.
    </p>
    </div>
  
  <?revision-note?>
  
  <div class="section"><h2 id="contents">Table of Contents</h2>
    

    <ul class="toc"><li><a href="#introduction">1. Introduction</a></li>
					<li><a href="#FileList-if">2. The FileList interface</a></li>
                                        <li><a href="#FileData-if">3. The FileData interface</a></li>
					<li><a href="#File-if">4. The File interface</a></li>
                                        <li><a href="#FileErrpr-if">5. The FileError interface</a></li>
      <li><a href="FileURL-if">6. The filedata:// scheme</a></li>
                                        
			                <li><a href="#conform">7. Conformance</a></li>
					<li><a href="#requirements">8. Requirements and Use Cases</a></li>
					<li><a href="#ack">9. Acknowledgements</a></li>
			                <li><a href="#bibref">10. References</a></li>
	</ul>
	  
</div>


  <div class="section"><h2 id="sotd">Status of this Document</h2>
  <p>
    <em>This section describes the status of this document at the time of its publication.
    Other documents may supersede this document. A list of current <acronym title="World Wide Web Consortium">W3C</acronym> publications and the
    latest revision of this technical report can be found in the 
    <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym>
    technical reports index</a> at http://www.w3.org/TR/.</em>
  </p>

    
    <p>
      This document is a First Public Working Draft. It is <strong>not an official
      publication</strong> of the <acronym title="World Wide Web Consortium">W3C</acronym>. The authors of this document are
      the members of the <acronym title="World Wide Web Consortium">W3C</acronym> <a href="http://www.w3.org/2008/webapps">Web Applications</a> Working Group.
    </p>
    <p>
      This document is produced by the <a href="http://www.w3.org/2008/webapps">Web <acronym title="Application Programming Interface">Applications</acronym>
      <acronym title="Working Group">WG</acronym></a> in
      the <acronym title="World Wide Web Consortium">W3C</acronym> <a href="http://www.w3.org/Interaction/">Interaction Domain</a>.
    </p>
    <p>
      Web content and browser developers are encouraged to review this
      draft. Please send comments to <a href="mailto:public-webapps@w3.org">public-webapps@w3.org</a>,
      the <acronym title="World Wide Web Consortium">W3C</acronym>'s public email list for issues related to Web <acronym title="Application Programming Interface">API</acronym>.
      <a href="http://lists.w3.org/Archives/Public/public-webapps/">Archives</a> of the
      list are available.
    </p>
	
  
  </div>
  <div class="section"><h2 id="introduction">1. Introduction</h2>
    
    <p>
      It is desirable for web applications to have the ability to manipulate as wide
      as possible a range of user input, including files that a user may wish to upload 
      to a remote server or manipulate inside a rich web application. This specification 
     defines the basic representations for files, lists of files, errors raised by access to files, and programmatic ways to prompt for file selection.  The interfaces and API defined in this specification can be used
     with other interfaces and APIs exposed to the web platform (e.g. <a href="#XHR2" class="if-name">XMLHttpRequest</a>).
    </p>
    <p>
    This specification may refer to other specifications, including <a href="#HTML5">HTML5</a> and <a href="DOM3Core">DOM3Core</a>.  This specification uses the term &quot;caller&quot; to refer to
    the entity invoking the API.
    </p>
  </div>

  
<div class="section"><h2 id="FileList-if">2. The FileList interface</h2>
    
    <p>
      This interface exposes the list of files that has been selected.  If no file has been selected, the length attribute is zero.  When one or more files have been selected,
      an array of <a href="#File-if" class="if-name">File</a> objects is created, and the length attribute reflects the number of selected files.
    </p>

    <div class="boxed"><p><span class="idlTitle">The FileList interface</span></p>
    <pre class="schema" title="The FileList interface">
  interface <a href="#idl-if-FileList">FileList</a> {
  
   readonly attribute unsigned long <a href="#dfn-length">length</a>;
   [IndexGetter] <a href="#idl-if-File">File</a> <a href="#dfn-item">item</a>(in unsigned long index);
 
};</pre>
</div>
<div class="section" id="idl-if-FileList">
    <div class="section"><h4 class="idl-header" id="idl-attrs-FileList">Attributes</h4>
        <dl class="idl-attr"><dt id="dfn-length"><code>length</code>
        of type
         unsigned long, readonly</dt>
        <dd><p>
              The number of files in the list. 
        </p></dd>
        </dl>
    </div>
    
    <div class="section"><h4 class="idl-header" id="idl-meths-FileList">Methods</h4>
    <dl class="idl-meth">
    <dt id="dfn-item"><code>item</code></dt>
    <dd>
        <p>
            Returns the <code>index</code>th item in the collection, which is a <a href="#File-if" class="if-name">File</a> object. If 

              <code>index</code> is greater than or equal to the number of files in the
              list -- namely greater than the value of <code>length-1</code>, this returns <code>null</code>.
        </p>
        <p> Usage: <code>var file = filelist.item(0);</code></p>
        <p> Usage: <code>var file = fileList[0];</code></p>
    </dd> 
   
    </dl>
    <div class="section">
    <h4 class="idl-header">Parameters</h4>
     <dl class="idl-params"><dt><code>index</code> of type unsigned long</dt><dd> Index into the collection.  Valid values are from 0 to <code>length</code>-1.</dd></dl>
   </div>
    
    
    </div>
</div>
</div> 
<div class="section"><h2 id="FileData-if">3. The FileData interface</h2>
<p>This interface represents the raw data of a file object, and includes asynchronous data accessor methods as well as a readonly property for the data's size, in bytes.  The <a href="#File-if" class="if-name">File</a>
interface inherits from this interface. </p>
</div>
<div class="boxed"><p><span class="idlTitle">The FileData interface</span></p>
    <pre class="schema" title="The FileData interface">
interface <a href="#idl-if-FileData">FileData</a> {

 readonly attribute unsigned long long <a href="#dfn-size">size</a>;
 
 void <a href="#dfn-getAsDataURL">getAsDataURL</a>(in <a href="#dfn-FileContent">FileContent</a> callback<a href="#dfn-FileErrorCallback"></a>);
 void <a href="#dfn-getAsText">getAsText</a>(in <a href="#dfn-FileContent">FileContent</a> callback, [Optional] in DOMString <a href="#dfn-encoding">encoding</a>);
 void <a href="#dfn-getAsBinary">getAsBinary</a>(in <a href="#dfn-FileContent">FileContent</a> callback);
 void <a href="#dfn-getAsBase64">getAsBase64</a>(in <a href="#dfn-FileContent">FileContent</a> callback);
 void <a href="#dfn-getAsURL">getAsURL</a>(in <a href="#dfn-FIleContent">FileContent</a> callback);
 void <a href="#dfn-splice">splice</a>(in long long <a href="#dfn-offset">offset</a>, in long long <a href="#dfn-length">length</a>, in <a href="#dfn-FileDataContent">FileDataContent</a> callback);
 void <a href="#dfn-cancelReads">cancelReads</a>();

};




[CallBack=FunctionOnly, NoInterfaceObject] interface <a href="#dfn-FileContent">FileContent</a> {  

 void handleEvent(in DOMString fileContent, in <a href="#dfn-FileError">FileError</a> error);

};


 
[CallBack=FunctionOnly, NoInterfaceObject] interface <a href="#dfn-FileDataContent">FileDataContent</a> {

 void handleEvent(in <a href="#FileData-if">FileData</a> fileData, in <a href="#dfn-errorCode">FileError</a> error);

};

 </pre>    
</div>
<div class="section"><h4 id="idl-attribs-FileData">Attributes</h4>
<dl class="idl-attr">
<dt id="dfn-size"><code>size</code> of type <code>unsigned long long, readonly</code></dt>
  <dd><p>The size of the file in bytes.</p></dd></dl>
</div>
<div class="section"><h4 id="idl-meths-File">Methods</h4>
<dl class="idl-meth">
<dt id="dfn-getAsDataURL"><code>getAsDataURL</code></dt>
<dd>
<p>Asynchronously returns the <a href="#FileData-if" class="if-name">FileData</a> object's data as a <em>data URL</em> [<a href="#DataURL">RFC2397</a>] using the <a href="#dfn-FileContent">FileContent</a> callback method, which also handles errors.  If an error occurs, implementations MUST call the callback with <code>null</code> for the string argument and provide the appropriate <a href="#dfn-errorCode">error code</a> to the callback using the <a href="#FileError-if" class="if-name">FileError</a> argument. If the call is successful, implementations MUST call the callback function with a string argument that is a valid data URL [<a href="#DataURL">RFC2397</a>], and with a <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a> error code on the <a href="#FileError-if" class="if-name">FileError</a> object. URL length limitations in different user-agents limit the use of this call. User-agents SHOULD provide data URL representations of a <a href="#FileData-if" class="if-name">FileData</a> object's contents subject to their own URL length limitations, and provide <code>null</code> for the string argument to the callback if this is not possible, along with a <a href="#FileError-if" class="if-name">FileError</a> object with the appropriate error code (in this case, <a href="#idl-defs-FileErrorCode-ENCODING_ERR">ENCODING_ERR</a>; other error conditions exist as well).</p>
<div class="section">Usage: <div class="boxed" id="sample-getAsDataURL">
  <pre>
<code>
// Sample code in JavaScript
// Obtain fileList from &lt;input type=&quot;file&quot;&gt; using DOM
 
var file = fileList.files.item(0);
if (file)
{
  // ... Make asynchronous call
     
  file.getAsDataURL(handleURL);
 
}

// ...

function handleURL(fileAsDataURL, error)
{
  
 if(fileAsDataURL)
 {
   
   // xhr.send(fileAsDataURI);
   // Could also construct img src=fileAsDataURL
 
 }
 else
 {
   status = error.errorCode;
   if(status = error.NOT_READABLE_ERROR)
   {
    dump(&quot;File Not Readable&quot;);
    // Use another asynchronous getter
   }        
 }      
}


</code>
</pre>
</div>
</div>
</dd>
<dt id="dfn-getAsText"><code>getAsText</code></dt>
<dd>
 <p>
  Asynchronously returns the <a href="#FileData-if">FileData</a> object's data as a string using the <a href="#dfn-FileContent">FileContent</a> callback method, which also handles errors. The caller can specify an optional <code>encoding</code> argument.  If the caller does NOT provide the optional <code>encoding</code> parameter, implementations SHOULD attempt to determine the best possible encoding to use. If implementations cannot make a determination of what encoding to use, implementations MUST assume a UTF-8 encoding. For character sequences that cannot be encoded as UTF-8, implementations MUST provide the U+FFFD Replacement Character [<a href="#Unicode">Unicode</a>].  If an error occurs, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback with <code>null</code> for the string argument, and provide the appropriate <a href="#dfn-errorCode">error code</a> to the callback using the <a href="#FileError-if" class="if-name">FileError</a> object argument (e.g. <a href="#idl-defs-FileErrorCode-NOT_READABLE_ERR">NOT_READABLE_ERR</a>; implementations MAY also use <a href="#idl-defs-FileErrorCode-ENCODING_ERR">ENCODING_ERR</a>). If the call is successful, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback function with the <a href="#FileData-if" class="if-name">FileData</a> object's data as a string argument (using the appropriate encoding) and with a <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a> error code on the <a href="#FileError-if" class="if-name">FileError</a> argument. </p>
<div class="section">
Usage: <div class="boxed" id="sample-getAsText">
<pre><code>
// Sample code in JavaScript
// Obtain fileList from &lt;input type=&quot;file&quot;&gt; using DOM
 
var file = fileList.files.item(0);
if (file)
{
 // ... Make asynchronous call
     
 file.getAsText(handleText, &quot;UTF-16&quot;);
 
}

function handleText(fileDump, error)
{
 if(fileDump)
 {
  // Handle UTF-16 file dump
  if(arunlib.regexp.isChinese(fileDump))
  {
 
   //Chinese Characters + Name validation
 
  }
  else
  {
 
    // run Hiragana charset test
 
  }
 
  // xhr.send(fileDump)
 
 }
 if(error)
 {
  var code = error.code;
  
  // Handle error conditions
  if(code == error.ENCODING_ERR) msg(&quot;Pick Another Text File&quot;)
  else
  {
   // Handle read errors or security considerations
  }
 }
}
</code> 
</pre>
</div>
</div>
</dd>
<dt id="dfn-getAsBinary"><code>getAsBinary</code></dt><dd>
  <p>Asynchronously returns the <a href="#FileData-if" class="if-name">FileData</a> object's data as a binary string using the <a href="#dfn-FileContent">FileContent</a> callback method, which also handles errors. If an error occurs, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback with <code>null</code> for the string argument, and provide the appropriate <a href="#dfn-errorCode">error code</a> to the callback using the <a href="#FileError-if" class="if-name">FileError</a> object argument (e.g. <a href="#idl-defs-FileErrorCode-NOT_READABLE_ERR">NOT_READABLE_ERR</a> or <a href="#idl-defs-FileErrorCode-ENCODING_ERR">ENCODING_ERR</a>; other error conditions exist as well). If the call is successful, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback function with the <a href="#FileData-if" class="if-name">FileData</a> object's data as a string argument (using the appropriate encoding) and with a <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a> error code on the <a href="#FileError-if" class="if-name">FileError </a>argument. </p>
</dd>
<dt id="dfn-getAsBase64"><code>getAsBase64</code></dt><dd>
  <p>Asynchronously returns the <a href="#FileData-if" class="if-name">FileData</a> object's data as a Base64-encoded binary string using the <a href="#dfn-FileContent">FileContent</a> callback method, which also handles errors. If an error occurs, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback with <code>null</code> for the string argument, and provide the appropriate <a href="#dfn-errorCode">error code</a> to the callback using the <a href="#FileError-if" class="if-name">FileError</a> object argument (e.g. <a href="#idl-defs-FileErrorCode-NOT_READABLE_ERR">NOT_READABLE_ERR</a> or <a href="#idl-defs-FileErrorCode-ENCODING_ERR">ENCODING_ERR</a>; other error conditions exist as well). If the call is successful, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback function with the <a href="#FileData-if" class="if-name">FileData</a> object's data as a string argument (using the appropriate encoding) and with a <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a> error code on the <a href="#FileError-if" class="if-name">FileError</a> argument. </p>
</dd>
<dt id="dfn-getAsURL"><code>getAsURL</code></dt><dd>
  <p>Asynchronously returns the <a href="#FileData-if" class="if-name">FileData</a> object's data as a <a href="#fileurl-if" class="if-name">filedata://</a> URL using the <a href="#dfn-FileContent">FileContent</a> callback method, which also handles errors. Unlike the other methods, when this method is called, it MUST return a different <a href="#fileurl-if" class="if-name">filedata://</a> URL each time for the file resource in question by coining a new UUID at each call. If an error occurs, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback with <code>null</code> for the string argument, and provide the appropriate <a href="#dfn-errorCode">error code</a> to the callback using the <a href="#FileError-if" class="if-name">FileError</a> object argument (e.g. <a href="#idl-defs-FileErrorCode-NOT_READABLE_ERR">NOT_READABLE_ERR</a>; other error conditions exist as well, and implementations MAY choose to use <a href="#idl-defs-FileErrorCode-SECURITY_ERR">SECURITY_ERR</a> in some cases as a result of this call). If the call is successful, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback function with the <a href="#FileData-if" class="if-name">FileData</a> object's data as a string argument representing a valid <a href="#fileurl-if" class="if-name">filedata://</a> URL and with a <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a> error code on the <a href="#FileError-if" class="if-name">FileError</a> argument.</p>
<div class="section">
Usage:
<div class="boxed">
  <pre><code>
// Sample code in JavaScript
// Obtain fileList from &lt;input type=&quot;file&quot;&gt; using DOM
 
var file = fileList.files.item(0);
if (file)
{
 // ... Make asynchronous call
     
 file.getAsURL(handleURL);
}
function handleURL(url, error)
{
 if(url)
 {
   var img = new Image();
   img.src = url;
   
   // Other stuff...
   
 }
 else
 {
   // error conditions
 }
}

</code></pre>
</div>
</div>  
</dd>
<dt id="dfn-splice"><code>splice</code></dt><dd>
 <p>
 Extracts a subset of the <a href="#FileData-if" class="if-name">FileData</a> between <code>offset</code> and <code>length</code>, and asynchronously returns this byte-ranged subset of the original file as a new <a href="#FileData-if" class="if-name">FileData</a> object using the <a href="#dfn-FileDataContent">FileDataContent</a> callback, which also handles errors.  If an error occurs, implementations MUST call the <a href="#dfn-FileDataContent">FileDataContent</a> callback with <code>null</code> for the <a href="#FileData-if" class="if-name">FileData</a> argument, and provide the appropriate <a href="#dfn-errorCode">error code</a> to the callback using the <a href="#FileError-if" class="if-name">FileError</a> object argument (e.g. <a href="idl-defs-FileErrorCode-SPLICE_ERR">SPLICE_ERR</a>; other error conditions exist as well). If the call is successful, implementations MUST call the <a href="#dfn-FileContent">FileDataContent</a> callback function with the new<a href="#FileData-if" class="if-name"> FileData</a> object as an argument (using the appropriate encoding) and with a <code><a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a></code> error code on the <a href="#FileError-if" class="if-name">FileError</a> argument. </p>
 <div class="ednote">Something should be said about multiple splice calls using the same FileDataContent callback.</div>
<div class="section">
Usage:
<div class="boxed"><pre><code>
// Sample code in JavaScript
// Obtain fileList from &lt;input type=&quot;file&quot;&gt; using DOM
 
var file = fileList.files.item(0);

if(file)
{
 file.splice(0, file.size/2, handleSplices);
}
function handleSplices(fileData, error)
{
 if(fileData)
 {
   // Can call asynchronous data accessors
   
   // Can use xhr.send(fileData) (pending update to xhr2)
 }
 else
 {
  if(error.errorCode = error.SPLICE_ERR)
  {
   
   // Determine if this file can be spliced
   
  }
 }
}
</code></pre></div>
</div> 
</dd>
<dt id="dfn-cancelReads"><code>cancelReads</code></dt>
<dd>
  <p>Cancels all pending asynchronous accessor calls, perhaps because they are taking too long; this call will typically be used in conjunction with timeout calls. When this method is called, implementations MUST call 
  the appropriate callback (either <a href="#dfn-FileContent">FileContent</a>  or <a href="#dfn-FileDataContent">FileDataContent</a>, depending on the pending asynchronous accessor method) with <code>null</code> for the data argument 
  (string or <a href="#FileData-if" class="if-name">FileData</a> object, depending on the pending asynchronous accessor method) and <code><a href="#idl-defs-FileErrorCode-CANCEL_ERR">CANCEL_ERR</a></code> on the 
  <a href="#dfn-FileError" class="if-name">FileError</a> argument of the respective callback.</p>
</dd>
</dl>
<div class="section"><h4 id="idl-params-File">Parameters</h4>
<dl class="idl-params">
 <dt id="dfn-FileContent"><code>FileContent</code>, of type <code>[CallBack=FunctionOnly]</code></dt>
 <dd>
  <p>This is a callback function for asynchronous handling of strings representing a file's data.  These strings are either data URLs [<a href="#DataURL">DataURL</a>], <a href="#filedata-if" class="if-name">filedata://</a> URLs, or string encodings of a file's data.   This callback MUST be called asynchronously with <code>null</code>
  for the string argument if the asynchronous data accessors encounter a <a href="#FileError-if" class="if-name">FileError</a> while called, OR if <a href="#dfn-cancelReads"><code>cancelReads</code></a> is called before the callback is called. When called with <code>null</code> for the string argument, this callback MUST be called with a meaningful <a href="#FileError-if" class="if-name">FileError</a> error code that is NOT <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a>. If the callback is successful, it MUST be called with a valid string argument, and a <a href="#FileError-if" class="if-name">FileError</a> argument with an error code of <a href="#idl-defs-FileErrorCode-SUCCESS"><code>SUCCESS</code></a>.</p>
 </dd>
 <dt id="dfn-FileDataCallback"><code>FileDataCallback</code>, of type <code>[CallBack=FunctionOnly]</code></dt>
 <dd>
 <p>This is a callback function for asynchronous handling of <a href="#FileData-if" class="if-name">FileData</a> objects that are coined as a result of the <a href="#dfn-splice"><code>splice</code></a> call.  This callback MUST be called asynchronously with <code>null</code> for the <a href="#FileData-if" class="if-name">FileData</a> argument if the asynchronous data accessors encounter a <a href="#FileError-if" class="if-name">FileError</a> while called, OR if <a href="#dfn-cancelReads"><code>cancelReads</code></a> is called before the callback is called. When called with <code>null</code> for the <a href="#FileData-if" class="if-name">FileData</a> argument, this callback MUST be called with a meaningful <a href="#FileError-if" class="if-name">FileError</a> error code that is NOT <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a>. If the callback is successful, it MUST be called with a valid <a href="#FileData-if" class="if-name">FileData</a> object argument, and a <a href="#FileError-if" class="if-name">FileError</a> argument with an error code of <a href="#idl-defs-FileErrorCode-SUCCESS"><code>SUCCESS</code></a>.
 
 </p>
 <div class="ednote">Something should be said about multiple splice calls using the same FileDataContent callback.</div>
 </dd>
  <dt id="dfn-encoding"><code>encoding</code>, of type <code>DOMString [optional]</code></dt>
  <dd>
    <p>
      This OPTIONAL parameter is specified on the <a href="#dfn-getAsText"><code>getAsText</code></a> method.  If it is NOT used when calling <a href="#dfn-getAsText"><code>getAsText</code></a>, implementations SHOULD make a &quot;best pass&quot; at determining the encoding needed. If implementations cannot make such a determination, implementations
      MUST assume that the encoding is in UTF-8.  Bytes or sequences of bytes that are not valid UTF-8 sequences MUST be interpreted as a U+FFFD REPLACEMENT CHARACTER [<a href="#Unicode">UNICODE</a>]. If it is used by the caller, implementations
      MUST attempt to decode the file using the encoding that the caller has specified (e.g. "UTF-16" as in the sample <a href="#sample-getAsText"><code>getAsText</code> code snippet in JavaScript</a>).
      Implementations MAY use a <a href="#FileError-if" class="if-name">FileError</a> error code of <a href="#idl-defs-FileErrorCode-SUCCESS"><code>ENCODING_ERR</code></a> if charset conversations fail; the Unicode U+FFFD REPLACEMENT CHARACTER
      should be used for bytes or sequences of bytes that could not be decoded using the caller specified encoding. </p>
   </dd>
   <dt id="dfn-offset"><code>offset</code>, of type <code>long long</code></dt>
   <dd><p>A value for the start point for an asynchronous <a href="#dfn-splice"><code>splice</code></a> call.</p></dd>
   <dt id="dfn-length"><code>length</code>, of type <code>long long</code></dt>
   <dd><p>A value for the end point for an asynchronous <a href="#dfn-splice"><code>splice</code></a> call.</p></dd>
</dl>
</div>
</div>


<div class="section"><h2 id="File-if">4. The File interface</h2>
    
    <p>
      This interface describes a single file in a <a href="#FileList-if" class="if-name">FileList</a> and exposes 
      its name and mediatype.  It inherits from <a href="#FileData-if" class="if-name">FileData</a>.
    </p>
    
</div>
    <div class="boxed"><p><span class="idlTitle">The File interface</span></p>
	<pre class="schema" title="The File interface">interface <a href="#idl-if-File">File</a> : <a href="#idl-if-FileData">FileData</a> {

readonly attribute DOMString <a href="#dfn-name">name</a>;
readonly attribute DOMString <a href="#dfn-filetype">mediaType</a>;

};
</pre>
</div>
<div class="section" id="idl-if-File">
<div class="section"><h4 id="idl-attrs-File">Attributes</h4>
<dl class="idl-attr">
 <dt id="dfn-name"><code>name</code> of type <code>DOMString, readonly</code></dt>
  <dd><p>The name of the file as a UTF8-encoded string.  There are numerous file name variations on different systems; this is merely the name of the file, without path information.</p></dd>
<dt id="dfn-mediaType"><code>mediaType</code> of type <code>DOMString, readonly</code></dt>
<dd>
  <p>The ASCII-encoded string representing the media type of the file, expressed as an RFC2046 MIME type [<a href="#RFC2046">RFC2046</a>].  Implementations SHOULD return the MIME type of the file, if it is known.  If implementations cannot
determine the media type of the file, they MUST return <code>null</code>.</p>
</dd></dl>

</div>

</div>

<div class="section">
<h2 id="FileError-if">5. The FileError error</h2>
    
<p>Methods in this specification may throw an error, which is reported when asynchronous file data accessor methods invoke callbacks (<a href="#dfn-FileContent">FileContent</a> or <a href="#dfn-FileDataContent">FileDataContent</a>) with <a href="#FileError-if" class="if-name">FileError</a> objects as one of their arguments.
While this specification describes a new error interface, <code>SECURITY_ERR</code> and <code>NOT_FOUND_ERR</code> are <code>ExceptionCode</code>s that are currently defined in
<code>DOMException</code>, originally defined in DOM Core [<a href="#DOM3CORE">DOM3CORE</a>][<a href="#DOMException">DOMException</a>]. Implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback or the <a href="#dfn-FileDataContent">FileDataContent</a> callback with a <a href="#FileError-if" class="if-name">FileError</a> object with a valid <a href="#dfn-errorCode"><code>errorCode</code></a> value, which is one of the constants defined below. </p>

    <div class="boxed"><p><span class="idlTitle">The FileError error</span></p>
    <pre class="schema" title="The FileError error">interface <a href="#idl-if-FileError">FileError</a> {
  readonly attribute unsigned short errorCode;
};
// FileErrorCode
const unsigned short <a href="#idl-defs-FileErrorCode-SUCCESS">SUCCESS</a> = 0;
const unsigned short <a href="#idl-defs-FileErrorCode-NOT_FOUND_ERR">NOT_FOUND_ERR</a> = 8;
const unsigned short <a href="#idl-defs-FileErrorCode-NOT_READABLE_ERR">NOT_READABLE_ERR</a> = 24;
const unsigned short <a href="#idl-defs-FileErrorCode-SECURITY_ERR">SECURITY_ERR</a> = 18;
const unsigned short <a href="#idl-defs-FileErrorCode-CANCEL_ERR">CANCEL_ERR</a> = 25;
const unsigned short <a href="#idl-defs-FileErrorCode-ENCODING_ERR">ENCODING_ERR</a> = 26;
const unsigned short <a href="#idl-defs-FileErrorCode-SPLICE_ERR">SPLICE_ERR</a> = 27;

</pre>
</div>
    
<div class="section"><h4 class="idl-header" id="idl-defs-FileErrorCode">Definition Group <em>FileErrorCode</em></h4>
<dl class="idl-defs">
<dt id="idl-defs-FileErrorCode-SUCCESS"><code>SUCCESS</code></dt>
<dd>
<p>This error code MUST be used if the file has been successfully accessed, and is readable by the asynchronous accessor APIs on <a href="FileData-if" class="if-name">FileData</a>. </p>
</dd>
<dt id="idl-defs-FileErrorCode-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></dt>
  <dd>
 <p>
            This error code MUST be used if the file being accessed does not exist at the time the asynchronous accessor APIs on <a href="#FileData-if" class="if-name">FileData</a> are called. This may be due
            to it having been moved or deleted after a reference to it was
            acquired (e.g. concurrent modification with another application). This error code has been previously defined in <code>DOMException</code>.[<a href="#DOMException">DOMException</a>] </p>           
</dd>
<dt id="idl-defs-FileErrorCode-NOT_READABLE_ERR"><code>NOT_READABLE_ERR</code></dt>
<dd>
  <p>
            This error code MUST be used if the file cannot be read. This may be due to permission problems that occur after a reference to a file has been acquired (e.g. concurrent lock with another application).
    </p>        
</dd>
<dt id="idl-defs-FileErrorCode-SECURITY_ERR"><code>SECURITY_ERR</code></dt>
<dd>
  <p>
	       This error code has been previously defined in <code>DOMException</code> [<a href="#DOM3Core">DOM3Core</a>, <a href="#DOMException">DOMException</a>].  
	       Implementations MAYuse this error code if they determine that an application is &quot;looping&quot; on file selection (continuous prompting, till a file is chosen). Additionally, implementations MAY use this error code if they determine that certain classes of files are unsafe for access within a web application by way of an asynchronous data accessor.  This error code MAY be used if a user interaction layer soliciting
               user permission is dismissed WITHOUT granting permission. Implementations MAY use this error code if it is determined that too many asynchronous data accessor calls are being called on <a href="#FileData-if" class="if-name">FileData</a>.</p>
</dd>
<dt id="idl-defs-FileErrorCode-CANCEL_ERR"><code>CANCEL_ERR</code></dt>
<dd>
  <p>
 
 This error code MUST be used if the user cancels the file dialog without picking a file, OR if a <a href="#dfn-cancelReads"><code>cancelReads()</code></a> is called on the <a href="#FileData-if" class="if-name">FileData</a> object.  </p>
</dd>
<dt id="idl-defs-FileErrorCode-ENCODING_ERR"><code>ENCODING_ERR</code></dt>
<dd>
  <p>This error code MAY be used if implementations cannot return a <a href="#FileData-if" class="if-name">FileData</a> object's data in the requested encoding. This error code MAY be used for all the asynchronous data accessors on the <a href="#FileData-if" class="if-name">FileData</a> object.</p>
</dd>
<dt id="idl-defs-FileErrorCode-SPLICE_ERR"><code>SPLICE_ERR</code></dt>
<dd>
  <p>This error code MUST be used if implementations cannot splice the <a href="#FileData-if" class="if-name">FileData</a> object between the specified byte ranges using the <a href="#FileData-if" class="if-name">FileData</a> object's <a href="#dfn-splice"><code>splice</code></a> method. This could occur because the caller has innacurately accounted for the number of bytes that the <a href="#FileData-if" class="if-name">FileData</a> object consists of, or if implementations encounter an error in splicing the data.</p>
</dd>
</dl>
</div>
<div class="section">
  <h4 id="idl-attrs-FileError">Attributes</h4>
<dl><dt><code>errorCode</code>, of type <code>unsigned short</code>;</dt>
<dd>
  <p>The errorCode value MUST be one of the above constants. If the errorCode is <a href="#idl-defs-FileErrorCode-SUCCESS"><code>SUCCESS</code></a>, implementations MUST call the <a href="#dfn-FileContent">FileContent</a> callback with a string argument that represents the 
  <a href="#FileData-if" class="if-name">FileData</a> object's content (depending on the asynchronous accessor method, e.g. <a href="#dfn-getAsText"><code>getAsText</code></a>), and the <a href="#dfn-FileDataContent">FileDataContent</a> callback with a <a href="#FileData-if" class="if-name">FileData</a> argument (e.g. when the <a href="#dfn-splice"><code>splice</code></a> method is used). With every other errorCode but <a href="#idl-defs-FileErrorCode-SUCCESS"><code>SUCCESS</code></a> , the <a href="#dfn-FileContent">FileContent</a> callback is called with <code>null</code> for the string argument, and the <a href="#dfn-FileDataContent">FileDataContent</a> callback is called with <code>null</code> for the <a href="#FileData-if">FileData</a> argument.</p>
</dd></dl></div>
<div class="section">
<h2 id="fileurl-if">6. The filedata:// scheme</h2>
<p>This section defines a scheme for a short-lived and unique URL, generated by the <a href="#FileData-if" class="if-name">FileData</a> object's asynchronous <a href="#dfn-getAsURL"><code>getAsURL</code></a> data accessor. The URL can be used in web content, and MUST be processed by conforming implementations just as HTTP URLs are, using HTTP status codes [<a href="#HTTP">HTTP</a>].</p>
<div class="ednote">The processing model is problematic.  If we use HTTP response codes, that could be a protocol violation, since those codes shouldn't be used outside of HTTP. However, returning these status codes would allow applications to behave as they do under HTTP, particularly when resources are not found, etc.</div>
<h3 id="filedataABNF">ABNF of filedata URL Scheme</h3>
<p>This section uses the Augmented Backus-Naur Form (ABNF), defined in [<a href="#ABNF">RFC2234</a>]. All filedata:// URLs MUST follow this ABNF.</p>

<div class="section">
<pre class="schema">
filedata = scheme &quot;://&quot; UUID 

; UUID refers to a UUID in its canonical form, used without the urn: namespace, and is defined in [<a href="#UUID">RFC4122</a>]

scheme = &quot;filedata&quot;

; scheme is always "filedata"

UUID                   = time-low "-" time-mid "-"
                         time-high-and-version "-"
                         clock-seq-and-reserved
                         clock-seq-low "-" node
time-low               = 4hexOctet
time-mid               = 2hexOctet
time-high-and-version  = 2hexOctet
clock-seq-and-reserved = hexOctet
clock-seq-low          = hexOctet
node                   = 6hexOctet
hexOctet               = hexDigit hexDigit
hexDigit =
         "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" /
         "a" / "b" / "c" / "d" / "e" / "f" /
         "A" / "B" / "C" / "D" / "E" / "F"

</pre>
<p>Thus, a valid filedata:// URL would take the form:
<code>filedata://550e8400-e29b-41d4-a716-446655440000</code>
</p>
</div>
<h3 id="origin">Origin of filedata:// URLs</h3>
<div class="section">
  <p>The origin of filedata:// URLs MUST be the  origin of the script context that  invoked the <a href="#dfn-getAsURL"><code>getAsURL</code></a> method; this is defined as the &quot;first script&quot; in HTML5 [<a href="#HTML5">HTML5</a>]. filedata:// URLs MUST only be valid within this script context. Retrieving them within any other script context results in a 404 Not Found [<a href="#HTTP">HTTP</a>].</p>
  <div class="ednote">Caveats about the HTTP processing model, but I include it as a strawperson.</div>
</div>
<h3 id="lifetime">Lifetime of filedata:// URLs</h3>
<div class="section">
<p>Implementations MUST ensure that the lifetime of filedata:// URLs is the same as the lifetime of the <code>Document</code>[<a href="#HTML5">HTML5</a>] of the origin script from which <a href="#dfn-getAsURL"><code>getAsURL</code></a> was called.  When this <code>Document</code> is destroyed, implementations MUST treat requests for filedata:// URLs as 404 Not Found [<a href="#HTTP">HTTP</a>].</p>
<div class="ednote">Caveats about the HTTP processing model.</div>
<h3 id="processingModel">Processing Model for filedata:// URLs</h3>
<div class="section">
<div class="ednote">This section needs more discussion with the WG.  In particular, it seems that some status codes (200 OK, 404 Not Found, 5xx (Errors)) are going to be useful.</div>
</div>
</div>
</div>
<div class="section">
<h2 id="conform">7. Conformance</h2>
<p>    
All examples (including code snippets in JavaScript) and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>
<p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described
in RFC2119. [<a href="#RFC2119">RFC2119</a>]</p>
<p>
Requirements phrased in the imperative are to be interpreted with the
meaning of the key word ("must", "should", "may", etc) used in introducing the requirements.</p>
<p>
Some conformance requirements are phrased as requirements on attributes, methods or objects. Such requirements are to be interpreted as requirements on conforming implementations.
</p>
<p>
Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. </p>
<p>
Implementations may impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around
platform-specific limitations.
</p>
</div>
  
  <div class="section">
	<h2 id="requirements">8. Requirements and Use Cases</h2>
	<p>This section covers what the requirements are for this API, as well as illustrates some use cases.  This version of the API does not satisfy all use cases; subsequent versions may elect to address these.</p>  
	  <ul>
		  <li><p>Once a user has given permission, user agents should provide the ability to read and parse data directly from a local file programmatically.</p>
			  <ul>
				  <li> Example: A lyrics viewer. User wants to read song lyrics from songs in his plist file.  User browses for plist file.  File is opened, 
					  read, parsed, and presented to the user as a sortable, actionable list within a web application.  User can select songs to fetch lyrics.  User uses the 
					  "browse for file" dialog.</li>		
			   </ul>		  		  
		  </li>
		  <li><p>Data should be able to be stored locally so that it is available for later use, which is useful for offline data access for web applications.</p>
		    <ul><li>Example: A Calendar App.  User's company has a calendar. User wants to sync local events to company calendar, marked
  as "busy" slots (without leaking personal info).  User browses for file and selects it. The text/calendar file is parsed
  in the browser, allowing the user to merge the files to one calendar view.
  The user wants to then save the file back to his local calendar file. (using "Save As" ?).  The user can also send the integrated calendar file back to the server
			calendar store asynchronously.</li></ul>
		  
		  </li>
		  <li><p>User agents should provide the ability to save a local file programmatically given an amount of data and a file name.</p>
		  <ul>
			<li>Example: A Spreadsheet App.  User interacts with a form, and generates some input.  The form then generates a CSV (Comma Separated Variables) output
			for the user to import into a spreadsheet, and uses "Save...".  The generated output can also be directly integrated into a web-based spreadsheet, and
			uploaded asynchronously.</li>  
		  </ul>
		  </li>
		  <li><p>User agents should provide a streamlined programmatic ability to send data from a file to a remote server that works more efficiently than form-based uploads today</p>
			<ul>
				<li>Example: A Video/Photo Upload App. User is able to select large files for upload, which can then be "chunk-transfered" to the server.</li>
			</ul>  
		  </li>
		  <li><p>User agents should provide an API exposed to script that exposes the features above.  The user is notified by UI anytime interaction with the file
			  system takes place, giving the user full ability to cancel or abort the transaction.  The user is notified of any file selections, and can cancel these.
			  No invocations to these APIs occur silently without user intervention. </p></li>
		  
	  </ul>
  </div>
  <div class="section">
    <h2 id="ack">9. Acknowledgements</h2>
    
    <p>
      This specification was originally developed by the SVG Working Group. Many thanks to Mark Baker and Anne van Kesteren for their feedback.</p>
    <p>Robin Berjon, Jonas Sicking, Maciej Stachowiak, Sam Weinig, Ian Hickson</p>
  </div>

  <div class="section"><h2 id="bibref">A. References</h2>

    <dl class="bibliography">
     <dt id="RFC2119">RFC2119</dt><dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
   </dd>
    <dt id="XHR2">XMLHttpRequest</dt><dd><cite><a href="http://www.w3.org/TR/XMLHttpRequest2/">XMLHttpRequest Level 2</a></cite>
   </dd>
    <dt id="HTML5">HTML5</dt><dd><cite><a href="http://dev.w3.org/html5/spec/Overview.html">HTML 5: A vocabulary and associated APIs for HTML and XHTML</a></cite></dd>
    <dt id="DataURL">RFC2397</dt><dd><cite><a href="http://www.ietf.org/rfc/rfc2397.txt">The "data" URL Scheme</a></cite></dd>
    <dt id="FileUpload">File Upload State of the input element</dt><dd><cite><a href="http://dev.w3.org/html5/spec/Overview.html#file-upload-state">File Upload State of the HTML5 <code>input</code> Element</a></cite></dd>
    <dt id="Workers">Web Workers</dt><dd><cite><a href="http://dev.w3.org/html5/workers/">Web Workers</a></cite></dd>
    <dt id="DOM3Core">DOM 3 Core</dt><dd><cite><a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html">DOM 3 Core</a></cite></dd>
    <dt id="DOMException">DOMException Extensions Defined in HTML5</dt><dd><cite><a href="http://dev.w3.org/html5/spec/Overview.html#exceptions">DOM 3 Core DOMException Extensions Defined in HTML5</a></cite></dd>
    <dt id="Unicode">Unicode</dt><dd><cite><a href="http://www.unicode.org/versions/Unicode5.1.0/">The Unicode Standard, Version 5.1.0.</a></cite></dd>
    <dt id="UUID">RFC4122</dt><dd><cite><a href="http://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a></cite></dd>
    <dt id="HTTP">RFC2616</dt><dd><cite><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">Hypertext Transfer Protocol -- HTTP/1.1</a></cite></dd>
    <dt id="ABNF">RFC2234</dt>
    <dd><cite><a href="]http://www.ietf.org/rfc/rfc2234.txt">Augmented BNF for Syntax Specifications: ABNF</a></cite></dd>
    <dt id="RFC2046">RFC2046</dt>
    <dd><cite><a href="http://www.ietf.org/rfc/rfc2046.txt">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Extensions</a></cite></dd>
   </dl>
  </div>
  </div>
</body>
</html>
