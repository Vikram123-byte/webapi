<h2>Available test assertions</h2>

<dl>

<dt>
  shouldBe(test, expected)
</dt>
<dd>
  Evaluates the strings test and expected as expressions and tests that the results are strictly equal (===). If you want to test with normal equality instead of struct equality, then instead of shouldBe("expr1", "expr2") write shouldBeTrue("expr1 == expr2");
</dd>

<dt>
  shouldBeTrue(test)
</dt>
<dd>
  Evaluates the string test and tests that the results are strictly equal (===) to true. Same effect as shouldBe(test, "true").
</dd>

<dt>
  shouldBeFalse(test)
</dt>
<dd>
  Evaluates the string test and tests that the results are strictly equal (===) to false. Same effect as shouldBe(test, "false").
</dd>

<dt>
  shouldBeNaN(test)
</dt>
<dd>
  Evaluates the string test and tests that the results are the floating point number NaN. Testing with shouldBe won't work in this case since NaN is not equal to itself.
</dd>

<dt>
  shouldBeUndefined(test)
</dt>
<dd>
  Tests that the type of expression test is undefined. Testing with shouldBe won't work in this case since some undefined expressions throw an exception if you try to actually evaluate them.
</dd>

<dt>
  shouldThrow(test[, exception])
</dt>
<dd>
  Tests that evaluating expression test throws an exception. Optionally you can specify what exception to test for, but I don't think this usefully works right now. What you really need is a way to state test assertions about exception.
</dd>

<dt>
  shouldNotThrow(test)
</dt>
<dd>
  Tests that evaluating expression does not throw an exception.
</dd>

</dl>
