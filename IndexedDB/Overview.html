<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <meta name='revision' content='$Id: Overview.html,v 1.20 2009-12-11 01:30:18 nmehta3 Exp $'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/simple-node.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",
          
          shortName:            "WebSimpleDB",

          // publishDate:  "2009-09-29",

          previousPublishDate:  "2009-09-29",
          previousMaturity:  "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          extraCSS: [
                "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                "SimpleDB.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Oracle Corp", companyURL: "http://www.oracle.com/" },
          ],
          
          maxTocLevel: 3,
          
          wg:           "Web Applications Working Group",
          
          wgURI:        "http://www.w3.org/2008/webapps/",
          
          wgPublicList: "public-webapps",
          
          wgPatentURI:  "http://www.w3.org/Consortium/Patent-Policy-20040205/",
      };
    </script>
    <script class="remove">
      function examples() {
        var examples = document.querySelectorAll('div.example');
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        for (var i = 0; i < examples.length; i++) {
          var example = examples.item(i);
          var header = sn.element('div', {'class': 'exampleHeader'}, null, 'Example');
          example.insertBefore(header, example.firstChild);
        }
      }
      
      function codeblocks() {
        document.normalize();
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        
        var blocks = document.querySelectorAll('codeblock');
        for (var i = 0; i < blocks.length; i++) {
          var codeblock = blocks.item(i);
          var div = sn.element('div', {'class': 'block'})
          sn.element('span', {'class': 'blockTitle'}, 
            sn.element('div', {'class': 'blockTitleDiv'}, div), 'ECMAScript');
          var code = sn.element('code', {'class': 'es-code'}, 
                       sn.element('pre', {'class': 'code'}, 
                         sn.element('div', {'class': 'blockContent'}, div)));
          sn.copyChildren(codeblock, code);
          codeblock.parentNode.replaceChild(div, codeblock);
        }
      }
      function codeRefs() {
        var codes = document.querySelectorAll('a>code');
        for (var i = 0; i < codes.length; i++) {
          var code = codes.item(i);
          var a = code.parentNode;
          a.setAttribute('class', 'idltype');
          a.setAttribute('href', '#idl-def-' + code.textContent); 
        }      
      }
      window.onload = function() {
        examples();
        codeblocks();
        codeRefs();
        (new berjon.respec()).loadAndRun();
      }
    </script>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->
    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      h5 {
        display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value. 
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure. 
      </p>
    </section>

    <section id='introduction' class='section non-normative'>
      <h2>Introduction</h2>

      <p>
        User agents need to store large numbers of objects locally in
        order to satisfy off-line data requirements of Web applications.
        [[WEBSTORAGE]] is useful for
        storing pairs of keys and their corresponding values. However, it does 
        not provide in-order retrieval of keys, efficient searching over
        values, or storage of duplicate values for a key. 
      </p>
      
      <p>
        This specification provides a concrete API to perform advanced key-value data management
        that is at the heart of most sophisticated query processors. It does
        so by using transactional databases to store keys and their 
        corresponding values (one or more per key), and providing a means
        of traversing keys in a deterministic order. This is often implemented
        through the use of persistent B-tree data structures that are considered
        efficient for insertion and deletion as well as in-order traversal of
        very large numbers of data records.
      </p>
      
      <div class="example">
        <p>
          A script can efficiently find records in an object store that come 
          closest to the required value provided the value is stored in either 
          a primary or a secondary key.
          In the following example, the 'books' object store holds data about
          books which are stored by their 'isbn' attribute. Additionally, 
          an index is maintained on the 'author' attribute of the objects
          stored in the object store. This index can be used to look up books
          for a given author. If an exact match is not found, the next
          matching author is located.
        </p>
        <codeblock>
var db = <a>openDatabaseSync</a>('books', 'Book store', false);
if (db.version !== '1.0') {
  var olddb = <a>openDatabaseSync</a>('books', 'Book store');
  olddb.<a>createObjectStore</a>('books', 'isbn');
  olddb.<a>createIndex</a>('BookAuthor', 'books', 'author', false);
  olddb.<a>setVersion</a>("1.0");  
}
// db.<a>version</a> === "1.0";  
var index = db.<a>getIndex</a>('BookAuthor', true);
var author = ...
var matching = index.<a>get</a>(author);
if (matching)
  report(matching.isbn, matching.name, matching.author);
else
  report(null);</codeblock>
        <p>
        Here is an example of a script using this API. First, a function
        <code>prepareDatabase()</code> is defined. This function tries to create 
        the database if necessary, giving it one object store called "docids" with
        the primary key "id". If it is successful, or if the table
        doesn't need creating, it calls the function that does the
        actual work, in this case <code>showDocCount()</code>.
        </p>
        <codeblock>
var request = null;
function prepareDatabase(ready, error) {
  request = new <a>DatabaseRequest</a>();
  request.<a>onsuccess</a> = ready;
  request.<a>onerror</a> = error;
  var upgrade = 
    function(changes, db) {
      changes.<a>createObjectStore</a>('docids', 'id');
      // now db.<a>version</a> === '1.0'
    };
  request.<a>open</a>('documents', '1.0', 'Offline document storage', upgrade);
}

function showDocCount(db, span) {
  var storeRequest = new <a>ObjectStoreRequest</a>(db);
  storeRequest.<a>onsuccess</a> = 
    function() {
      var store = storeRequest.<a>store</a>, total = 0;
      var cursorRequest = new <a>CursorRequest</a>(store);
      cursorRequest.<a>onsuccess</a> = 
        function() {
          span.textContent = total;
        };
      cursorRequest.<a>open</a>(function(record, cursor) { 
          total += cursor.<a>count</a>; 
        }, <a>Cursor</a>.<a>NEXT_NO_DUPLICATE</a>);
    };
  storeRequest.<a>open</a>('docids', true);
};

prepareDatabase(function(evt) {
  // got database
  var span = document.getElementById('doc-count');
  showDocCount(request.<a>database</a>, span);
  }, function (evt) {
  // error getting database
  var error = request.error;
  alert(error.message);
});</codeblock>
      </div>
    </section>

    <section id='conformance' class='section'>
      <p>
        This specification defines one class of products:
      </p>
      <dl>
        <dt><dfn id='dfn-conforming-user-agent'>Conforming user agent</dfn></dt>
        <dd>
          <p>
            A user agent must behave as described in this specification
            in order to be considered conformant.
          </p>
          
          <p>
            User agents may implement algorithms given in this
            specification in any way desired, so long as the end result is
            indistinguishable from the result that would be obtained by the
            specification's algorithms.
          </p>
          
          <p>
            A conforming Indexed Database API user agent must also be a
            <em>conforming implementation</em> of the IDL fragments
            of this specification, as described in the
            “Web IDL” specification. [[!WEBIDL]]
          </p>
          
          <div class="note">
            This specification uses both the terms "conforming user agent(s)" 
            and "user agent(s)" to refer to this product class.
          </div>
        </dd>
      </dl>        
      
      <section class="section" id="dependencies">
        <h3>Dependencies</h3>
        <p>
          This specification relies on several other underlying specifications. 
        </p>
        <dl>
          <dt>HTML5</dt>
          <dd>The terms and algorithms <dfn id="document-base-url">document base URL</dfn>,
            <dfn id="event-handler-attributes">event handler attributes</dfn>, 
            <dfn id="event-handler-event-type">event handler event type</dfn>,
            <dfn title="Function"><code>Function</code></dfn>,
            <dfn>origin</dfn>, <dfn>same origin</dfn>, <dfn>structured clone</dfn>,
            <dfn>structured clone algorithm</dfn>, <dfn>task</dfn>, <dfn>task source</dfn>, 
            and <dfn title="queue-a-task">queue a task</dfn> are defined by the HTML 5 
            specification [[!HTML5]].
          </dd>
          <dt>WebWorkers</dt>
          <dd>This specification adds capabilities to WebWorkers and uses certain concepts defined in this specification [[!WEBWORKERS]].</dd>
        </dl>
      </section>
    </section>
  
    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>
      
      <section id="constructs" class="section">
      <h3>Constructs</h3>
        <p>
          An indexed database is made of records holding simple values
          and hierarchical objects. Each record consists of a key and some value. 
        </p>
        
        <section id="key-construct" class="section">
          <h5>Keys</h5>
          
          <p>
            In order to efficiently retrieve records stored in an indexed
            database, a user agent needs to organize each record by its key. 
            <a>Conforming user agents</a> MUST support the use of values
            of IDL data types <code>DOMString</code> and <code>long</code> 
            as well as the value <code>null</code> as keys.
          </p>
          
          <p>
            For purposes of comparison, a <code>DOMString</code> key is always 
            evaluated higher than any <code>long</code> key. Moreover, 
            <code>null</code> always evaluates lower than any 
            <code>DOMString</code> or <code>long</code> key.
          </p>
          <div class="note">
            Only data types with natural ordering can be used as keys. 
            The ECMAScript <code>undefined</code> cannot be used as a key.
          </div>
        </section>
        
        <section id="value-construct" class="section">
          <h5>Values</h5>
          <p>
            Values can be any data type supported by the <a>structured clone algorithm</a> 
            [[!HTML5]]. This includes simple types such as <code>DOMString</code>
            and <code>Date</code> as well as <code>Object</code> and <code>Array</code>
            instances.
          </p>
          
          <p>
            A database may choose to derive a key from the contents of
            the value being stored. In such a case, only <code>Object</code> 
            instances may be stored as values. Only the direct enumerable
            properties of a stored <code>Object</code> instance can be 
            used to derive a key value.
          </p>
        </section>
        
        <section class="section" id="object-store-concept">  
          <h4>Object Store</h4>
          <p>
            An <dfn>object store</dfn> is a persistent storage that holds 
            key-value pairs, also called <dfn title="record">records</dfn>. An 
            <a>object store</a>'s <a title="record">records</a> are sorted by
            keys so as to enable fast insertion and look up as well as ordered retrieval. 
            Every <a>object store</a> has a <dfn title="object store name">name</dfn>.
          </p>
          
          <p>
            An <a>object store</a> must have a unique <dfn>key generator</dfn>,
            if it uses keys generated from a monotonically
            increasing sequence. Alternatively, if an application provides keys,
            they can either be identified as a part of the value being stored,
            also called <dfn>in-line keys</dfn>, or be identified separately, also
            called <dfn>out-of-line keys</dfn>. No two <a title="record">records</a>
            in an <a>object store</a> may be identified by the same key. An
            <a>object store</a> must have a <dfn title="object store key path">key path</dfn> 
            if it uses <a>in-line keys</a>. The <a>key path</a> MUST be the name of
            an enumerated property of all objects being stored in that 
            <a>object store</a>.
          </p>
          
          <p>
            Concurrent access to an <a>object store</a> MAY be isolated in one of 
            three <dfn title="mode">modes</dfn>. Any number of <a title="reader">readers</a>
            may concurrently access an <a>object store</a>. A <a>writer</a> is not allowed
            if there is any <a>reader</a> concurrently accesing the <a>object store</a>,
            unless the <a>reader</a> is detached, i.e., looking at a snapshot view
            of the data that does not change once created. 
          </p>
          <div class="ednote">
            The detached reading behavior needs more explanation.
          </div>
          <p>
            The <a><code>ObjectStore</code></a> interface is used to access the metadata
            of an <a>object store</a>.
          </p>
          <dl title="interface ObjectStore" class="idl">
            <dt>const     unsigned short READ_WRITE    = 0</dt>
            <dd>Modification operations are allowed on the <a>object store</a>
            in this mode.</dd>
            <dt>const     unsigned short READ_ONLY    = 1</dt>
            <dd>Modification operations are not allowed on the <a>object store</a>
            in this mode.</dd>
            <dt>const     unsigned short SNAPSHOT_READ = 2</dt>
            <dd>This mode is used solely for reading from a snapshot of the data
            in the <a>object store</a>.</dd>

            <dt>readonly attribute unsigned short mode</dt>
            <dd>On getting, provide the <a>mode</a> for isolating access to data inside
            this <a>object store</a></dd>
            <dt>readonly attribute DOMString      name</dt>
            <dd>          
              On getting, provide the <a title="object store name">name</a> of this
              object store.        
            </dd>
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="object store key path">key path</a>
              of this <a>object store</a>. If this attribute is <code>null</code>,
              the application MUST provide a key value for each modification operation.
            </dd>
            <dt>readonly attribute DOMStringList  indexNames</dt>
            <dd>
            On getting, provide a list of the names of <a title="index">indexes</a> on 
            objects in this <a>object store</a>.
            </dd>
          </dl>
        </section> <!-- Object store -->
        
        <section id="index-concept" class="section">
          <h4>Index</h4>
          <p>
            <a title="record">Records</a> in an <a>object store</a> can be retrieved by 
            means of the <a title="record">record's</a> key. However, that may not be
            always adequate to recall <a title="record">records</a>. An <a>index</a> is
            used to lookup records in an <a>object store</a> other than through a
            <a>record</a> key.
          </p>
          <p>
            An <dfn>index</dfn> is a specialized persistent store that holds key-value 
            pairs such that each value is the key of objects in the <dfn>referenced</dfn>
            <a>object store</a>. An <a>index</a> may allow duplicate  values for a key,
            unlike an <a>object store</a>, only if its <dfn>unique</dfn> flag is not set. 
            Every <a>index</a> has a <dfn title="index name">name</dfn>.
          </p>
          <p>
            If an <a>index</a> is <dfn>auto-populated</dfn>, then the user agent populates
            records using the values stored in the <a>referenced</a> <a>object store</a>.
            An <a>auto-populated</a> <a>index</a> must have a 
            <dfn title="index key path">key path</dfn>, which MUST be the name of an
            enumerated property of all objects being stored in the <a>referenced</a> 
            <a>object store</a>. The <a>auto-populated</a> <a>index</a> record 
            corresponding to an <a>object store</a> record MUST satisfy the following 
            <dfn>index maintenance conditions</dfn>:
          </p>
          <ul>
            <li><a>index</a> record key = value of the enumerated property at the 
            <a title="index key path">key path<a> in the <a>object store</a> record value</li>
            <li><a>index</a> record value = <a>object store</a> record key</li>
          </ul>
          <p>
            The <a><code>Index</code></a> interface is used to access the metadata
            of an <a>index</a>.
          </p>
          <dl class="idl" title="interface Index">
            <dt>readonly attribute DOMString      name</dt>
            <dd>
              On getting, provide the <a title="index name">name</a> of this <a>index</a>.        
            </dd>
            <dt>readonly attribute DOMString      storeName</dt>
            <dd>
              On getting, provide the <a title="object store name">name</a> of this
              <a title="index">index's</a> <a>referenced</a> <a>object store</a>.
            </dd>
        
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="index key path">key path<a> of this
              <a>index</a>. If this attribute is <code>null</code>,
              this <a>index</a> is not <a>auto-populated</a>.
            </dd>
            
            <dt>readonly attribute boolean unique</dt>
            <dd>
              On getting, provide the <a>unique</a> flag of this <a>index</a>.
            </dd>
          </dl>  
        </section> <!-- Index -->
        
       <section id="database-concept" class="section">
          <h4>Database</h4>
          <p>
            Each <a>origin</a> has an associated set of <a title="database">databases</a>. 
            A <dfn>database</dfn> comprises:
          </p>
          <ul>
            <li>
              one or more <a title="object store">object stores</a> and
            </li>
            <li>
              any number of <a title="index">indexes</a>.
            </li>
          </ul>
          <p>
            Each <a>database</a> has a <a title="valid-name">valid</a> 
            <dfn title="database name">name</dfn> and a human readable description
            A <dfn title="valid-name">valid name</dfn> is any string including
            the empty string. Names must be compared in a case-sensitive manner.
          </p>
          
          <div class="note">
            Implementations can support this even in environments that only
            support a subset of all strings as database names by mapping
            database names (e.g. using a hashing algorithm) to the supported
            set of names.
          </div>
          <p>
          Each <a>database</a> also has a current <dfn>version</dfn>.
          </p>
          <div class="note">
            Each <a>database</a> has one version at a time; a <a>database</a> can't
            exist in multiple versions at once. 
          </div>
          <p>
            The <a>object store</a> <a title="object store name">name</a> and <a>index</a> 
            <a title="index name">name</a> MUST be <a title="valid-name">valid</a> and 
            unique within the <a>database</a>.
          </p>
          <p>
            When a <a>database</a> is opened, that creates a <dfn>connection</dfn>. There
            may be multiple <a title="connection">connections</a> to a given <a>database</a> 
            at any given time. A <a>connection</a> that is attempting to read a given piece
            of data in a <a>database</a> is called a <dfn>reader</dfn> and one that is
            attempting to write that piece of data is called a <dfn>writer</dfn>. There
            may be zero or one active <a>transaction</a> in a <a>connection</a>.
          </p>
          <p>
            A <a><code>Database</code></a> object represents a <a>connection</a> to a 
            <a>database</a>. There is no way to enumerate the 
            <a title="database">databases</a> available for an <a>origin</a> from this API. 
          </p>
          
          <dl title="interface Database" class="idl">   
            <dt>readonly attribute DOMString name</dt>
            <dd>
              On getting, this attribute must return the <a title="database name">name</a>
              of the <a title="connection">connected</a> <a>database</a>.
            </dd>
            <dt>readonly attribute DOMString description</dt>  
            <dd>
              On getting, this attribute must return the description of the
              <a title="connection">connected</a> <a>database</a>.
            </dd>
            <dt>readonly attribute DOMString version</dt>
            <dd>
              On getting, this attribute must return the <a>version</a> of this
              <a>database</a>. This attribute has the <a>null</a> value when the
              <a title="connection">connected</a> <a>database</a> is first created.
            </dd>
            <dt>readonly attribute DOMStringList objectStores</dt>
            <dd>
              On getting, this attribute must return a list of names of the 
              <a title="object store">object stores</a> currently in the 
              <a title="connection">connected</a> <a>database</a>.
            </dd>
            <dt>readonly attribute DOMStringList indexes</dt>
            <dd>
              On getting, this attribute must return a list of names of the 
              <a title="index">indexes</a> currently in the 
              <a title="connection">connected</a> <a>database</a>.
            </dd>
            <dt>readonly attribute Transaction currentTransaction</dt>
            <dd>
              On getting, this attribute must return a <a><code>Transaction</code></a> object
              corresponding to the <a>transaction</a> that is currently active in this
              <a>database</a> <a>connection</a>.
            </dd>
          </dl>
        </section>  <!-- Database -->
        
        <section class="section" id="range-concept">
          <h4>Key Range</h4>
          <p>
            An individual record can be retrieved from an <a>object store</a> using 
            either the record's key or the key applicable for some <a>index</a> that
            <a title="referenced">references</a> that <a>object store</a>. Multiple
            records can be fetched using a <a>key range</a>. A <dfn>key range</dfn> 
            is a continuous interval over some data type used for keys.
          </p>
          <p>
            A <a>key range</a> may be left-bounded or right-bounded if there is a value
            that is, respectively, smaller than or larger than all its elements. A
            <a>key range</a> is said to be bounded if it is both left- and right-bounded
            and unbounded otherwise. A <dfn title="valid key range">valid</dfn>
            <a>key range</a> must be either half-bounded or bounded. A <a>key range</a>
            may be open, i.e., not including its endpoints or closed, i.e., including
            its endpoints. A <a>key range</a> may be degenerate if it consists of a 
            single value.
          </p>
          <p>
            The <a><code>KeyRange</code></a> interface is used to define a <a>key range</a>.
          </p>
          <dl class="idl" title="interface KeyRange"> 
            <dt>const     unsigned short DEGENERATE = 0</dt>
            <dd>This flag indicates a degenerate <a>key range</a>.</dd>
            <dt>const     unsigned short LEFT_OPEN = 1</dt>
            <dd>This flag indicates a left-open <a>key range</a>.</dd>
            <dt>const     unsigned short RIGHT_OPEN = 2</dt>
            <dd>This flag indicates a right-open <a>key range</a>.</dd>
            <dt>const     unsigned short LEFT_BOUND = 4</dt>
            <dd>This flag indicates a left-bound <a>key range</a>.</dd>
            <dt>const     unsigned short RIGHT_BOUND = 8</dt>
            <dd>This flag indicates a right-bound <a>key range</a>.</dd>
            <dt>readonly attribute any left</dt>
            <dd>This value is the left-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute any right</dt>
            <dd>This value is the right-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute unsigned short flags</dt>
            <dd>Flags for bounding values</dd>
            <dt>KeyRange degenerate()</dt>
            <dd>
              Create a new degenerate <a>key range</a>.
              <dl class="parameters">
                <dt>any bound</dt>
                <dd>The only value</dd>
              </dl>
            </dd>
            <dt>KeyRange leftBound()</dt>
            <dd>
              Create a new left-bound <a>key range</a>.
              <dl class="parameters">
                <dt>any bound</dt>
                <dd>The left bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Is the left-bound value included in the <a>key range</a>.</dd>
              </dl>
            </dd>
            <dt>KeyRange rightBound()</dt>
            <dd>
              Create a new right-bound <a>key range</a>.
              <dl class="parameters">
                <dt>any bound</dt>
                <dd>The right bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Is the right-bound value included in the <a>key range</a>.</dd>
              </dl>
            </dd>
            <dt>KeyRange bound()</dt>
            <dd>
              Create a new right-bound <a>key range</a>.
              <dl class="parameters">
                <dt>any left</dt>
                <dd>The left-bound value</dd>
                <dt>any right</dt>
                <dd>The right-bound value</dd>
                <dt>optional boolean openLeft</dt>
                <dd>Is the left-bound value included in the <a>key range</a>.</dd>
                <dt>optional boolean openRight</dt>
                <dd>Is the right-bound value included in the <a>key range</a>.</dd>
              </dl>
            </dd>
          </dl>
        </section> <!-- Key Range -->
        
        <section id="cursor-concept" class="section">
          <h4>Cursor</h4>
          <p>
            <a title="cursor">Cursors</a> are a transient mechanism used to 
            iterate over multiple records in a database. The storage operations
            are performed on the underlying <a>index</a> or an <a>object store</a>.
          </p>
          
          <p>
            A <dfn>cursor</dfn> comprises a series of records in either an
            <a>index</a> or an <a>object store</a>. A <a title="cursor">cursor</a>
            maintains a <dfn>position</dfn> over this series, which moves in a
            <dfn>direction</dfn> that is either monotonically increasing or 
            decreasing order of the record keys. 
          </p>
          
          <dl title="interface Cursor" class="idl">
            <dt>const     unsigned short     NEXT = 0</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     NEXT_NO_DUPLICATE = 1</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>
            <dt>const     unsigned short     PREV = 2</dt>
            <dd>
              indicates that <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     PREV_NO_DUPLICATE = 3</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>

            <dt>readonly attribute unsigned short     direction</dt>
            <dd>            
            On getting, provide the traversal <a>direction</a> of the <a>cursor</a>.
            </dd>
          </dl>          
        </section> <!-- Cursor -->
        
        <section id="transaction-concept" class="section">
          <h4>Transaction</h4>
          <p>
            A <dfn>transaction</dfn> has a <dfn>scope</dfn> and a <a>database</a>.
            A <a title="transaction">transaction's</a> <a>scope</a> is either static
            or dynamic. If the scope is static, it can cover either all the
            <a title="object store">object stores</a> and <a title="index">indexes</a>
            in a <a>database</a> or it may include a subset of them.
          </p>
          <p>
            A <a>connection</a> may have at most one <a>transaction</a> at any
            given time. Moreover, there may not be any overlap among the
            <a title="scope">scopes</a> of all open <a title="connection">connections</a>
            to a given <a>database</a>.
          </p>
          <p>
            <a title="transaction">Transactions</a> offer some protection from 
            application and system failures. A <a>transaction</a> may be used to
            store multiple data records or to conditionally modify certain data 
            records. A <a>transaction</a> represents an atomic and durable set of 
            data access and mutation operations. 
          </p>
          
          <p>  
            <a title="transaction">Transactions</a> are expected to be short
            lived. Conforming user agents may terminate 
            <a title="transaction">transactions</a> that take too long to
            complete in order to free up storage resources that are locked by
            a long running <a>transaction</a>.
          </p>
        </section> <!-- Transaction -->
      </section>  
      
      <section class="section" id="algorithms">
        <h3>Algorithms</h3>
        <section class="section" id="opening">
          <h4>Opening the database</h4>
          <p>
            The <dfn>steps for opening a database</dfn> are as follows. These steps
            MUST be run with a database name and description. All but the first two
            and the last steps MUST be run atomically:
          </p>
          
          <ol>
            <li>Pick the appropriate steps
              <dl class="switch">
                <dt>If this method is invoked from an active document</dt>
                <dd>Let <var>origin</var> be the origin of the active document 
                from which the method was invoked.</dd>
                <dt>If this method is invoked from a worker</dt>
                <dd>Let <var>origin</var> be the origin of the scripts in the worker.</dd>
              </dl>
            </li>
            
            <li>
              If there is already a database with the given name from the origin
              <var>origin</var>, then let <var>db</var> be that database.
            </li>
            
            <li>
              If no database with the given name from the origin <var>origin</var>
              exists, then create the database <var>db</var> with the name and
              description passed to these steps.
            </li>
  
            <li>Pick the appropriate steps:
              <dl class="switch">
                <dt>If these steps are performed to synchronously open a database</dt>
                <dd>
                  Let <var>result</var> be a newly constructed 
                  <a><code>DatabaseSync</code></a> object
                  representing a <a>connection</a> 
                  to <var>db</var>.
                </dd>
                <dt>If these steps are performed to asynchronously open a database</dt>
                <dd>
                  Let <var>result</var> be a newly constructed 
                  <a><code>Database</code></a> object
                  representing a <a>connection</a> 
                  to <var>db</var>.
                </dd>
              </dl>
            </li>
  
            <li>
              Return <var>result</var>.
            </li>
          </ol>        
        </section>
        
        <section class="section" id="object store insertion">
          <h4>Object Store Storage steps</h4>
          <p>
            The <dfn>steps for storing a record into an object store</dfn> are as follows. 
            These steps MUST be run with four parameters: the <a>object store</a>,
            a value, an optional key, and an optional no-overwrite flag.
          </p>
          <ol>
            <li>
              Let <var>store</var> be the <a>object store</a>, <var>key</var> be
              the key and <var>value</var> be the value passed to these steps.
            </li>
            <li>
              If <var>store</var> uses <a>out-of-line keys</a> but no <a>key 
              generator</a>, then a key MUST be passed to these steps. If not, 
              terminate these steps and set error code <a><code>DATA_ERR</code></a>.
            </li>
            <li>
              If <var>store</var> uses <a>in-line keys</a>, then 
              let <var>key</var> be the property of <var>object</var> at  
              <var>store</var>'s <a title="object store key path">key path</a>.
            </li>
            <li>
              If <var>key</var> is defined and not null, then skip the next step.
            </li>
            <li>
              Produce a <a>structured clone</a> of <var>value</var> and call it
              <var>object</var>.
            </li>
            <li>
              Perform the following steps.              
              <ol>
                <li>
                  Using <var>store</var>'s <a>key generator</a>, produce the next
                  key and store it as <var>key</var>.
                </li>
                <li>
                  If <var>store</var> uses <a>in-line keys</a>, then store 
                  <var>key</var> as the property value for <var>object</var> at  
                  <var>store</var>'s <a title="object store key path">key path</a>.
                </li>
              </ol>
            </li>
            <li>
              If the no-overwrite flag was passed to these steps and is set, and 
              a record already exists with its key being <var>key</var>, then 
              terminate these steps and set error code <a><code>CONSTRAINT_ERR</code></a>.
            </li>
            <li>
              <p>
                Store a record in <var>store</var> containing <var>key</var> as its key  
                and <var>object</var> as its value. If any <a title="index">indexes</a>  
                are <a>auto-populated</a> for <var>store</var>, then store a record
                in that index according to <a>index maintenance conditions</a>.
              </p>
              <div class="note">
                Storing would mean inserting if no record exists for that key
                or updating an existing record, otherwise. <a title="auto-populated">
                Auto populated<a> <a>index</a> record will also be respectively
                inserted or updated depending on what storing results in.
              </div>
            </li>
            
            <li>
              Return the <var>key</var>.
            </li>
          </ol>
        </section>
        
        <section id="index insertion" class="section">
          <h4>Index Storage steps</h4>
          <p>
            The <dfn>steps for storing a record into an index</dfn> are as follows. 
            These steps MUST be run with four parameters: the <a>index</a>,
            a key, a value, and a no-overwrite flag.
          </p>
          <ol>
            <li>
              Let <var>index</var> be the <a>index</a>, <var>key</var> be
              the key and <var>value</var> be the value passed to these steps.
            </li>
            <li>
              If <var>index</var> has a <a title="index key path">key path</a>,
              then terminate these steps and set error code <a><code>CONSTRAINT_ERR</code></a>.
            </li>
            <li>
              If the no-overwrite flag was passed to these steps and is set, and 
              a record already exists in <var>index</var> with its key being 
              <var>key</var>, then terminate these steps and set error code 
              <a><code>CONSTRAINT_ERR</code></a>.
            </li>
            <li>
              If no record exists in <var>index</var>'s <a>referenced</a>
              <a>object store</a> whose key is <var>value</var>, then terminate
              these steps and set error code <a><code>CONSTRAINT_ERR</code></a>.
            </li>
            <li>
              <p>
                Store a record in <var>index</var> containing <var>key</var> as its key  
                and <var>value</var> as its value. 
              </p>
              <div class="note">
                Storing would mean inserting if no record exists for that key
                or updating an existing record, otherwise. 
              </div>
            </li>
            
            <li>
              Return the <var>key</var>.
            </li>
          </ol>        
        </section>
        
        <section id="object store retrieval" class="section">
          <h4>Object Store Retrieval steps</h4>
          <p>
            The <dfn>steps for retrieving a record from an object store</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>object store</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>store</var> be the <a>object
              store</a> passed to these steps.
            </li>
            <li>
              If no record exists with key <var>key</var> in <var>store</var>,
              then terminate these steps and set error code
              <a><code>NOT_FOUND_ERR</code></a>.
            </li>
            <li>
              Return the a new <a>structured clone</a> of the value in the record with 
              key <var>key</var> in <var>store</var>.
            </li>
          </ol>
        </section>
        
        <section id="index retrieval" class="section">
          <h4>Index Referenced Value Retrieval steps</h4>
          <p>
            The <dfn>steps for retrieving a record from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If no record exists with key <var>key</var> in <var>index</var>,
              then terminate these steps and set error code
              <a><code>NOT_FOUND_ERR</code></a>.
            </li>
            <li>
              Let <var>value</var> be the value of the record with key <var>key</var>
              in <var>index</var>.
            </li>
            <li>
              Return the value for the record with key <var>value</var> in 
              <var>index</var>'s <a>referenced</a> <a>object store</a>.
            </li>
          </ol>
        </section>
        
        <section id="index retrieval" class="section">
          <h4>Index Value Retrieval steps</h4>
          <p>
            The <dfn>steps for retrieving a value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If no record exists with key <var>key</var> in <var>index</var>,
              then terminate these steps and set error code
              <a><code>NOT_FOUND_ERR</code></a>.
            </li>
            <li>
              Return the value of the record with key <var>key</var>
              in <var>index</var>.
            </li>
          </ol>
        </section>
        
        <section id="object store deletion" class="section">
          <h4>Obejct Store Deletion steps</h4>
          <p>
            The <dfn>steps for deleting a record from an object store</dfn> 
            are as follows. These steps MUST be run with two parameters: the key
            of the record to be deleted and the <a>object store</a>.
          </p>
          <ol>
            <li>
              Let <var>key</var> be the key and <var>store</var> be the <a>object
              store</a> passed to these steps.
            </li>
            <li>
              If no record exists with key <var>key</var> in <var>store</var>,
              then terminate these steps and set error code
              <a><code>NOT_FOUND_ERR</code></a>.
            </li>            
            <li>
               If any <a title="index">indexes</a> are <a>auto-populated</a> for
               <var>store</var>, then remove the record in that index according to
               <a>index maintenance conditions</a>.
            </li>
            
            <li>
              Remove the record from <var>store</var> with key <var>key</var>. 
            </li>
          </ol>
        </section>
        <section id="index deletion" class="section">
          <h4>Index Deletion steps</h4>
          <p>
            The <dfn>steps for deleting a record from an index</dfn> 
            are as follows. These steps MUST be run with two parameters: the key
            of the record to be deleted and the <a>index</a>.
          </p>
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If no record exists with key <var>key</var> in <var>index</var>,
              then terminate these steps and set error code
              <a><code>NOT_FOUND_ERR</code></a>.
            </li>            
            <li>
              Remove the records from <var>index</var> with key <var>key</var>. 
            </li>
          </ol>
        </section>
        <section class="section" id="transaction creation">
          <h4>Transaction Creation steps</h4>
          <p>
            When the user agent is to <dfn>create a <a>transaction</a></dfn>
            it must run the following steps. These steps MUST be run with 
            two parameters - <a>database</a> and an optional list of names of 
            <a title="index">indexes</a> and <a title="object store">object stores</a>
            in the database to be locked.
          </p>
          
          <ol>
            <li>
              Pick the appropriate steps:
              <dl class="switch">
                <dt>If these steps are not called with a list of database objects</dt>
                <dd>Acquire a lock on the entire database.</dd>
                <dt>If these steps are called with a non-empty list of database objects</dt>
                <dd><ol>
                  <li>
                    If any of the objects in this array is not a database object,
                    then set <var>code</var> to <a><code>NON_TRANSIENT_ERR</code></a>
                    and jump to the last step.
                  </li>
                  <li>
                    Acquire appropriate locks on each of the database objects and
                    the objects they depend on in an ordered sequence. 
                    <div class="note">
                      If the database does not allow fine grained locking,
                      then a user agent may obtain a shared or exclusive lock on the database.
                    </div>
                  </li>
                </ol></dd>
                <dt>If these steps are called with an empty array of database objects</dt>
                <dd>
                    Do not acquire locks on any database objects now. Locks are obtained as
                    the application attempts to access those objects.
                    <div class="note">
                      Using the database in this style may lead to deadlocks. Programmers
                      must use caution to acquire and release database objects in the same
                      global order to avoid deadlocks.
                    </div>
                </dd>
              </dl>
            </li>

            <li>
              If a timeout duration is passed to these steps and is exceeded when 
              acquiring locks, then set <var>code</var> to 
              <a><code>TIMEOUT_ERR</code></a> and jump to the last step.
            </li>

            <li>
              Open a new transaction to the database, and create a
              <code><a>Transaction</a></code> object
              that represents that transaction. Let <var>transaction</var> be this object.
            </li>
            
            <li>
              Set the current transaction of this <a><code>Database</code></a> object
              to <var>transaction</var>.
            </li>
            <li>
              Return <var>transaction</var>. End these steps.
            </li>
            <li>
              This step is only performed in case of error. If this step is performed
              asynchronously, then run the 
              <a class="dfnref" href="#database-failure-steps">database failure steps</a>
              with the code <var>code</var>. Otherwise, raise a newly constructed 
              <a><code>DatabaseException</code></a> 
              exception exception with the code <var>code</var>.
            </li>
          </ol>        
        </section>
      </section>
      
      <section id="sync-database" class="section">
        <h3>Synchronous APIs</h3>
        <p>
          This API can only be used in a Worker [[!WEBWORKERS]].
        </p>
        <section id="opening-sync" class="section">
          <h4>Opening a database connection</h4>
          <p class="idl" title="WorkerUtils implements EnvironmentSync">
            Worker objects MUST implement the interface to synchronously open
            database connections.
          </p>
          
          <dl class="idl" title="[Supplemental, NoInterfaceObject] interface EnvironmentSync">
            <dt>DatabaseSync openDatabaseSync()</dt>
            <dd>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd> </dd>
                <dt>DOMString description</dt>
                <dd> </dd>
                <dt>optional boolean modifyDatabase</dt>
                <dd>This defaults to true</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>UNKNOWN_ERR</dt>
                <dd>if an error occurs while the <a>database</a> <a>connection</a> 
                is being opened.</dd>
              </dl>
              <p>
                The synchronous API for databases blocks the calling thread until a
                <a><code>DatabaseSync</code></a> object is ready to return.
                When this method is invoked, the user agent must run the
                following steps:
              </p>
    
              <ol>
                <li>
                  Perform the <a class="dfnref" href="#database-open-steps">database opening steps</a>,
                  and call its result as <var>result</var>.
                </li>
                <li>
                  If the steps were aborted due to an error, then throw a newly constructed
                  <a><code>DatabaseException</code></a> 
                  exception with the code of that error and abort these steps.
                </li>
                <li>
                  Return <var>result</var>.
                </li>
              </ol>              
            </dd>
          </dl>
        </section>
        
        <section id="database-interface" class="section">
          <h4>Database connection</h4>
          <dl class="idl" title="interface DatabaseSync : Database">
            <dt>ObjectStoreSync createObjectStore()</dt>
            <dd>
              <p>
                This method creates a and returns a new <a>object store</a> with the
                given name in the <a title="connection">connected</a> <a>database</a>.
              </p>
              <dl class="parameters">
                <dt>[Null=Empty] DOMString name</dt>
                <dd>The <a title="object store name">name</a> of a new <a>object store</a></dd>
                <dt>[Null=Null] DOMString keyPath</dt>
                <dd>The <a title="object store key path">key path</a> of a new 
                <a>object store</a>. If <a>null</a> path is specified, then the 
                <a>object store</a> created will not have a <a>key path</a> and will
                use <a>out-of-line keys</a>.</dd>
                <dt>optional boolean autoIncrement</dt>
                <dd>Whether the <a>object store</a> created should have a 
                <a>key generator</a>.</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt><a><code>CONSTRAINT_ERR</code></a></dt>
                <dd>
                If an <a>object store</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
              </dl>
            </dd>
            <dt>ObjectStoreSync getObjectStore()</dt>
            <dd>
              <p>
                This method opens the <a>object store</a> with the given name
                in the <a title="connection">connected</a> <a>database</a> for the
                <a>mode</a> specified.
              </p>              
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of an existing 
                <a>object store</a></dd>
                <dt>optional unsigned short mode</dt>
                <dd>The <a>mode</a> used to access the <a>object store</a></dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt><a><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If an <a>object store</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
              </dl>
            </dd>
            <dt>IndexSync createIndex()</dt>
            <dd>
              <p>
                This method creates a and returns a new <a>index</a> with the
                given name in the <a title="connection">connected</a> <a>database</a>.
              </p>
              <dl class="parameters">
                <dt>[Null=Empty] DOMString      name</dt>
                <dd>The <a title="index name">name</a> of a new <a>index</a></dd>
                <dt>[Null=Empty] DOMString      storeName</dt>
                <dd>The <a title="object store name">name</a> of an existing
                <a>object store</a> <a>referenced</a> by the new <a>index</a></dd>
                <dt>DOMString      keyPath</dt>
                <dd>The <a title="index key path">key path used by the new
                <a>index</a></dd>
                <dt>optional boolean unique</dt>
                <dd>The <a>unique</a> flag for the new <a>index</a></dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt><a><code>CONSTRAINT_ERR</code></a></dt>
                <dd>
                If an <a>index</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
                <dt><a><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>object store</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>IndexSync getIndex()</dt>
            <dd>
              <p>
                This method opens the <a>index</a> with the given name
                in the <a title="connection">connected</a> <a>database</a> for the
                <a>mode</a> specified.
              </p>              
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>      
              <dl class="exception" title="DatabaseException">
                <dt><a><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>index</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void removeObjectStore()</dt>
            <dd>
              <p>
                This method is used to destroy an <a>object store</a> with the 
                given name as well as all <a title="index">indexes</a> that are 
                <a title="referenced">referencing</a> that <a>object store</a>.
              </p>
              
              <dl class="parameters">
                <dt>DOMString storeName</dt>
                <dd>The <a title="object store name">name</a> of an existing
                <a>object store</a></dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt><a><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>object store</a> with the given name, compared in a
                case-sensitive manner, does not already exist
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void removeIndex()</dt>
            <dd>
              <p>
                This method is used to destroy an <a>index</a> with the 
                given name. 
              </p>
              <dl class="parameters">
                <dt>DOMString indexName</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt><a><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>index</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void setVersion()</dt>
            <dd>
              This method is used to set the <a>version</a> of the 
              <a title="connection">connected</a> <a>database</a>.
              <dl class="parameters">
                <dt>[Null=Null] DOMString      version</dt>
                <dd>The <a>version</a> to store in the <a>database</a></dd>
              </dl>
            </dd>
            <dt>TransactionSync transaction()</dt>
            <dd>
              Perform the <a>steps for creating a transaction</a> with the list of 
              database objects for acquiring locks 
              required in this transaction and an optional timeout duration, and return
              the resulting <a><code>TransactionSync</code></a> object.
              <dl class="parameters">
                <dt>optional DOMStringList storeNames</dt>
                <dd>The names of <a title="object store">object stores</a> and 
                <a title="index">indexes</a> in the <a>scope</a> of the new
                <a>transaction</a></dd>
                <dt>optional unsigned int timeout</dt>
                <dd>The interval which this operation is allowed to take to
                reserve all the <a>database</a> objects identified in the new
                <a title="transaction">transaction's</a> <a>scope</a>. The default
                is user agent specific</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt><a><code>TIMEOUT_ERR</code></a></dt>
                <dd>
                If reserving all the <a>database</a> objects identified in the new
                <a title="transaction">transaction's</a> <a>scope</a> takes longer 
                than the specified interval.
                </dd>
              </dl>
            </dd>
          </dl>  
        </section>
          
        <section class="section" id="object-store-sync">  
          <h4>Object Store</h4>
          <div class="example">       
            <p>
              In the following example, we set up an <a>object store</a> to use the 
              <a title="object store key path">key path</a> <em>id</em>. This
              <a>object store</a> is also designed to use a <a>key generator</a>.
            </p>
            <codeblock>var db = <a>openDatabaseSync</a>('AddressBook', 'Address Book');
if (db.version !== '1.0') {
   var olddb = <a>openDatabaseSync</a>('AddressBook', 'Address Book');
   olddb.<a>createObjectStore</a>('Contact', 'id', true);
}</codeblock>
            <p>
              Using this <a>database</a>, we can store records in the <em>Contact</em>
              <a>object store</a>. 
            </p>
            <codeblock>var store = db.<a>getObjectStore</a>('Contact');

var lincoln = {name: 'Lincoln', number: '7012'};
var contact = store.<a>put</a>(lincoln);
// contact.id === 1</codeblock>
            <p>
              A stored value can be retrieved using the same key used by the
              first put operation.
            </p>
            <codeblock>var contact = store.<>get</a>(1);
// contact.name === 'Lincoln'</codeblock>
            <p>
              A second put operation will overwrite the record stored by the first 
              put operation.
            </p>
            <codeblock>var abraham = {id: 1, name: 'Abraham', number: '2107'};
store.<a>put</a>(abraham);</codeblock>
            <p>
              Now when the object store is read with the same key, the result 
              is different compared to the object read earlier.
            </p>
            <codeblock>var contact = store.<a>get</a>(1);
// contact.id === 1 &amp;&amp; contact.name === 'Abraham';</codeblock>
            <p>
              Additionally, all the <a>records</a> of an <a>object store</a> 
              matching a certain <a>key range</a> can be retrieved in key order.
            </p>
            <codeblock>var range = new <a>KeyRange</a>.<a>bound</a>(2, 4);
var count = store.<a>forEach</a>(function(key, cursor, value) {
            // each value is a contact and each key is the id for that  
            // contact whose id is between 2 and 4, both inclusive
            }, range);</codeblock>
          </div>
          
          <dl title="interface ObjectStoreSync : ObjectStore" class="idl">
            <dt>any put()</dt>
            <dd>
              Store the given value in this <a>object store</a> by following
              the <a>steps for storing a record into an object store</a>. The
              returned object from this method is the key for the stored record.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the record</dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the record</dd>
                <dt>optional boolean noOverwrite</dt>
                <dd>Whether to overwrite an existing record with the same key</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>DATA_ERR</dt>
                <dd>This <a>object store</a> uses <a>out-of-line</a> keys and
                no <a>key generator</a> but the <var>key</var> parameter was not
                passed</dd>
                <dt>CONSTRAINT_ERR</dt>
                <dd>The <var>noOverwrite</var> parameter was true and a record
                exists in this <a>object store</a> for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>void delete()</dt>
            <dd>
              Remove the record from this <a>object store</a> by following
              the <a>steps for deleting a record from an object store</a>
              corresponding to the given key.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be removed</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>object store</a> 
                for the key <var>key</var parameter.
                </dd>
              </dl>
            </dd>
            <dt>any get()</dt>
            <dd>
              Retrieve the value from this <a>object store</a> for the record 
              corresponding to the given key by following the
              <a>steps for retrieving a record from an object store</a>. The
              value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>object store</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>unsigned long long forEach()</dt>
            <dd>
              <dl class="parameters">
                <dt>CursorCallback callback</dt>
                <dd></dd>
                <dt>optional CursorRange    range</dt>
                <dd></dd>
                <dt>optional unsigned short direction</dt>
                <dd></dd>
              </dl>
            </dd>
          </dl>                
        </section>
        <section id="index-sync" class="section">  
          <h4>Index</h4>
          
          <div class="example">
            <p>
              An object can be retrieved using <em>secondary</em> keys, provided these keys
              are defined for the object store holding such objects. If the <code>upgrade()</code>
              function above were redefined as below, an index would be maintained
              on the <em>name</em> property of objects in <em>Contact</em>.
            </p>
            <codeblock>var upgrade = function(changes, db) {
              changes.<a>createObjectStore</a>('Contact', 'id', true);
              changes.<a>createIndex</a>('ContactName', 'Contact', 'name', false);
            });</codeblock>
            <p>
              For example, the id of an object with <em>name</em> property value as
              'Lincoln' can be retrieved using this <em>ContactName</em> index.
            </p>
            <codeblock>var index = db.<a>getIndex</a>('ContactName', 'Contact');
var id = index.<a>get</a>('Lincoln');
// id === 1</codeblock>              
            <p>
              If, however, we wanted to retrieve the object with <em>name</em> property 
              value as 'Lincoln' can be retrieved using this <em>ContactName</em> index.
            </p>
            <codeblock>var index = db.<a>getIndex</a>('ContactName', 'Contact');
var contact = index.<a>getObject</a>('Lincoln');
// contact.id === 1</codeblock>              
            <p>
              Additionally, all the objects of an object store matching a certain
              range of secondary or primary keys can be retrieved in key order. 
              When objects are retrieved from the <em>Contact</em> object store, 
              they are arranged by the value of the <em>id</em> attribute. On the
              other hand, when objects are retrieved using the <em>ContactName</em>
              index, they are arranged by the value of the <em>name</em> attribute. 
            </p>
            <codeblock>var range = new <a>KeyRange</a>.<a>bound</a>('L', 'M');
var count = index.<a>forEachObject</a>(function(key, cursor, value) {
            // each value is a contact and each key is the name for that  
            // contact whose name's first letter is either L or M
            }, range);</codeblock>
            <p>
              If, on the other hand, we only want to names but not the contact
              objects for a given range, then we can use a different mechanism for that.
            </p>
            <codeblock>var range = new <a>KeyRange</a>.<a>bound</a>('L', 'M');
var count = index.<a>forEach</a>(function(key, cursor) {
            // each key is the id of a contact  
            // whose name's first letter is either L or M
            }, range);</codeblock>
          </div>
              
          <dl class="idl" title="interface IndexSync: Index">
            <dt>unsigned long long forEach()</dt>
            <dd>
              <dl class="parameters">
                <dt>CursorCallback callback</dt>
                <dd> </dd>
                <dt>optional CursorRange  range</dt>
                <dd> </dd>
                <dt>optional unsigned short direction</dt>
                <dd> </dd>
              </dl>
            </dd>
            <dt>unsigned long long forEachObject()</dt>
            <dd>
              <dl class="parameters">
                <dt>CursorCallback callback</dt>
                <dd> </dd>
                <dt>optional CursorRange  range</dt>
                <dd> </dd>
                <dt>optional unsigned short direction</dt>
                <dd> </dd>
              </dl>
            </dd>
            <dt>any put()</dt>
            <dd>
              Store the given value in this <a>index</a> by following
              the <a>steps for storing a record into an index</a>. The
              returned object from this method is the key for the stored record.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the record</dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the record</dd>
                <dt>optional boolean noOverwrite</dt>
                <dd>Whether to overwrite an existing record with the same key</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>CONSTRAINT_ERR</dt>
                <dd>The <var>noOverwrite</var> parameter was true and a record
                exists in this <a>object store</a> for the key <var>key</var> 
                parameter or this <a>index</a> is <a>auto-populated</a> or if no
                record exists with key <var>value</var> parameter in the <a>index</a>'s
                <a>referenced</a> <a>object store</a>.
                </dd>
              </dl>
            </dd>
            <dt>any getObject()</dt>
            <dd>
              Retrieve the value from this <a>index</a>'s <a>referenced</a>
              <a>object store</a> for the record corresponding to the given key
              by following the <a>steps for retrieving a record from an index</a>.
              The value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>index</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>any get()</dt>
            <dd>
              Retrieve the value from this <a>index</a> for the record 
              corresponding to the given key by following the 
              <a>steps for retrieving a value from an index</a>.
              The value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>index</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>void delete()</dt>
            <dd>
              Remove the records from this <a>index</a> by following
              the <a>steps for deleting a record from an index</a>
              corresponding to the given key.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be removed</dd>
              </dl>
              <dl class="exception" title="DatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>index</a> 
                for the key <var>key</var parameter.
                </dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section class="section" id="cursor-sync">  
          <h4>Cursor</h4>
          <p>
            Cursors are a mechanism by which applications iterate over 
            the records in a database. Cursors can be used to get, put,
            and delete database records. If a database allows duplicate 
            records, then cursors are the only mechanism by which to
            access anything other than the first duplicate for a given 
            key. Although storage operations can be performed on a 
            cursor, a cursor itself is a transient object with all the
            real storage happening in objects that yield the cursor.
          </p>
          
          <p>
            The initial position of a cursor is set by specifying the
            direction in which the cursor should iterate over matching
            records. Once the cursor is created, it yield records only in 
            that direction.
          </p>
          <div class="example">
            <p>
              By default, a cursor walks over objects starting at the
              first record and ending at the last record including
              all the duplicates encountered along the way. If the
              cursor callback returns true, then the iteration is 
              stopped.
            </p>
            <codeblock>var objects = ...
var cursor = objects.forEach(function(object) {;
// act on each object and return true to exit the cursor  
});</codeblock>
            
            <p>
              To start at the last record and end in the first record,
              the cursor should be created with the direction parameter.
            </p>
            <codeblock>var objects = ...
var count = objects.forEach(function(object) {;
// act on each object and return true to exit the cursor  
}, <a class="idltype" href="#Cursor">Cursor</a>.<a class="idlvalue" href="#PREV">PREV</a>);</codeblock>

            <p>
              To start at a certain key and end in the last record, i.e.,
              for a lower-bounded cursor, while skipping duplicates,
              the cursor should be created with both the required 
              start key and the direction parameter. 
            </p>
            
            <codeblock>var objects = ...
var range = <a class="idltype" href="#KeyRange">KeyRange</a>.leftBound(key);
objects.forEach(function(object) {
// act on each object and return true to exit the cursor  
}, range, <a class="idltype" href="#Cursor">Cursor</a>.<a class="idlvalue" href="#NEXT_NO_DUP">NEXT_NO_DUPLICATE</a>);</codeblock>
        
            <p>
              It is also possible to create a bounded cursor, i.e., with
              application-specified starting and ending points, the
              cursor should be created with both the required keys.
              If the range is inclusive of both keys, then additional
              flags are required. In the following example, all keys
              with values in the inclusive range (<code>start</code>, 
              <code>end</code>) are returned with all their duplicates,
              from the beginning of the range to its end.
            </p>
  
            <codeblock>var objects = ...
var range = <a class="idltype" href="#KeyRange">KeyRange</a>.bound(start, end);
objects.forEach(function(object) {
// act on each object and return true to exit the cursor  
}, range);</codeblock>
          </div>
          <dl title="interface Cursor" class="idl">
            <dt>const     unsigned short     NEXT = 0</dt>
            <dd>indicates
            that cursor should yield all values, including duplicates 
            starting from the beginning of the range to its end.
            </dd>
            <dt>const     unsigned short     NEXT_NO_DUPLICATE = 1</dt>
            <dd>indicates that cursor should return all values, skipping over duplicate
            objects for every key starting from the beginning of the range to 
            its end. For every key with duplicate values, only the first value
            is yielded.</dd>
            <dt>const     unsigned short     PREV = 2</dt>
            <dd>
            indicates
            that cursor should yield all values, including duplicates 
            starting from the end of the range to its beginning.
            </dd>
            <dt>const     unsigned short     PREV_NO_DUPLICATE = 3</dt>
            <dd>indicates that cursor should return all values, skipping over duplicate
            objects for every key starting from the end of the range to its
            beginning. For every key with duplicate values, only the first value
            is yielded.
            </dd>

            <dt>readonly attribute unsigned short     direction</dt>
            <dd>            
            On getting, provide the traversal direction of the cursor.
            </dd>
            <dt>readonly attribute unsigned long long count</dt>
            <dd>             
              On getting, provide the total number of objects that share the current key.
            </dd>

            <dt>void    continue()</dt>
            <dd>(in optional KeyRange skipTo);</dd>
            
            <dt>boolean update()</dt>
            <dd>
              <p>
                This method is used to 
                update the object at which the cursor is currently positioned. If 
                the object is updated, then this method returns true. The update 
                method is only allowed if the <a><code>
                Cursor</code></a> is obtained from an object store. The key of
                the <var>object</var> parameter must match the key in the current
                cursor position. Otherwise, the database will throw a newly constructed 
                <a><code>DatabaseException</code></a> 
                exception with code <a><code>DATA_ERR</code></a>.
              </p>
            (  in          any         obj);</dd>
            
            <dt>void    delete()</dt>
            <dd>          
              <p>
                This method
                is used to delete the object at which the cursor is currently
                positioned. The <a href="#cursor-delete" class="idltype"><code>delete()</code></a> 
                method will return false if this method is called more than once 
                inside a <a><code>CursorCallback</code></a>.
              </p>
            </dd>
          </dl>

          <dl class="idl" title="[FunctionOnly, NoInterfaceObject] interface CursorCallback"> 
            <dt>bool handle()</dt>
            <dd>in          any    key, 
            in          <a class="idltype" href="#Cursor">Cursor</a> cursor,
            in optional any    value);
};</dd>
          </dl>
          <p>
            The <dfn id="for-each" class="idltype"><code>forEach()</code></dfn>
            method is used to navigate records in a cursor in the direction
            identified by the <var>direction</var> parameter, which can be
            either of <a class="idlvalue" href="#NEXT"><code>NEXT</code></a>,
            <a class="idlvalue" href="#NEXT_NO_DUP"><code>NEXT_NO_DUPLICATE</code></a>,
            <a class="idlvalue" href="#PREV"><code>PREV</code></a>, or
            <a class="idlvalue" href="#PREV_NO_DUP"><code>PREV_NO_DUPLICATE</code></a>.
            If <var>direction</var> is unspecified, then the cursor uses
            the <a class="idlvalue" href="#NEXT"><code>NEXT</code></a> direction.
            The parameters <var>inclusiveFrom</var> and <var>inclusiveTo</var>
            are used to signal whether ranges are open or closed on the
            range boundaries.
          </p>
          
          <p>
            For each object that matches the cursor condition, the user agent
            calls the <a href="#CursorCallback" class="idltype"><code>
            CursorCallback</code></a>. This <var>callback</var> is passed two
            parameters - the object that matches the cursor condition, and
            a <a href="#Cursor" class="idltype"><code>Cursor</code></a> object
            to make changes to the database at the <a href="#Cursor" class="idltype"><code>
            Cursor</code></a> position. If this callback returns a <code>true</code>
            value, then the cursor traversal is exited whether or not the
            range conditions have been satisfied.
          </p>
          
        </section>
        <section id="transaction-sync" class="section">
          <h4>Transaction</h4>
          <p>
            A <dfn>transaction</dfn> represents an atomic and durable set of 
            database access and mutation operations. Transactions offer data protection
            from application or system failures. 
          </p>
          
          <p>
            A transaction may be used to store multiple data records or to conditionally 
            modify certain data records. 
          </p>
          
          <p>
            A <a><code>Database</code></a> object may
            have at most one transaction at any given time. 
          </p>
          
          <p>  
            Transactions are expected to be short lived. Conforming user agents may
            terminate transactions that take too long to complete in order to free up
            storage resources that are locked by a long running transaction.         
          </p>                    

          <dl class="idl" title="interface TransactionSync">
            <dt>void abort()</dt>
            <dd>
              This method is used to signal
              the need to cancel the effects of database operations performed in a 
              transaction. To perform this method, the database ignores all the changes
              performed in this transaction through calls to this 
              <a><code>Transaction</code></a> object.
              <div class="exception" title="DatabaseException"></div>
            </dd>
            <dt>void commit()</dt>
            <dd>
              This method is used to signal
              the normal and satisfactory completion of a transaction to the database. At
              this point, the database durably stores the result of all the operations
              performed in this transaction through calls to this 
              <a><code>Transaction</code></a> object.
              <div class="exception" title="DatabaseException"></div>
            </dd>
          </dl>
          <p>
            The API for a transaction consists of mechanisms for committing
            and rolling back the effects of database operations performed
            in that transaction. However, asynchronous databases also 
            automatically commit a transaction whenever the transaction
            callback completes. Asynchronous databases also automatically
            rollback a transaction if an error occurs inside the transaction
            callback.
          </p>
          <div class="note">
            Applications must not assume that committing the transaction
            produces an instantaneously durable result. The user agent
            may delay flushing data to durable storage until an appropriate
            time.
          </div>
          
                    
          <p>
            Once a transaction is aborted or committed, that 
            <a><code>Transaction</code></a> 
            object can no longer be used. If any calls are made on that
             object, then the database will throw a newly constructed 
            <a><code>DatabaseException</code></a> 
            exception with code <a><code>NON_TRANSIENT_ERR</code></a>. 
            To perform database operations under the control of a new transaction, 
            a fresh <a><code>Transaction</code></a>
            object is needed.
          </p>
        </section> <!-- Transaction -->
        
      </section>
      <section class="section" id="async-api"> 
        <h3>Asynchronous APIs</h3>
        <p>
          The asynchronous database API returns without blocking the calling thread.
          This API can only be used in a Window or in a Worker 
          [[!WEBWORKERS]].
        </p>
        <dl class="idl" title="[NoInterfaceObject] interface DBRequest"> 
          <dt>void abort()</dt>
          <dd> </dd>
          <dt>const     unsigned short INITIAL = 0</dt>
          <dd> </dd>
          <dt>const     unsigned short LOADING = 1</dt>
          <dd> </dd>
          <dt>const     unsigned short DONE = 2</dt>
          <dd> </dd>
          <dt>readonly attribute unsigned short readyState</dt>
          <dd> </dd>
          <dt>readonly attribute DatabaseError error</dt>
          <dd> </dd>

          <dt>attribute Function onsuccess</dt>
          <dd> </dd>
          <dt>attribute Function onerror</dt>
          <dd> </dd>
        </dl>

        <div class="idl" title="DBRequest implements EventTarget"></div>
        
        <section class="section" id="events non-normative">
          <h4>Event summary</h4>
          <p>
            Events are fired during asynchronous database access as database objects
            are created and data is consumed from these objects. As requests for
            database objects are made, the user agent loads information about them
            into memory and when the required object handle is available, it 
            alerts the application through the firing of events. The events are
            as follows:
          </p>
          <table>
            <thead><tr><th>Event name</th><th>Interface</th><th>Dispatched when...</th></tr></thead>
            <tbody>
              <tr>
                <td><dfn id="event-success"><code>success</code></dfn></td>
                <td><code>Event</code></td>
                <td>The database request has been completed and its results are 
                available.</td>
              </tr>
              <tr>
                <td><dfn id="event-error"><code>error</code></dfn></td>
                <td><a><code>DatabaseErrorEvent</code></a></td>
                <td>There was an error performing the database request.</td>
              </tr>
              <tr>
                <td><dfn id="event-commit"><code>commit</code></dfn></td>
                <td><code>Event</code></td>
                <td>The transaction commit has been completed.</td>
              </tr>
              <tr>
                <td><dfn id="event-abort"><code>abort</code></dfn></td>
                <td><code>Event</code></td>
                <td>The transaction abort has been completed.</td>
              </tr>
            </tbody>
          </table>
        </section>
        
        <section class="section" id="opening">
          <h4>The DatabaseRequest Interface</h4>
          <p>
            This interface provides methods for opening databases and accessing
            database objects using event handler attributes
            [[!DOM-LEVEL-3-EVENTS]]. 
          </p>
          <div class="example">       
            <p>
              In the following example, we open a database asynchronously. Various event
              handlers are registered for responding to various situations.
            </p>
            <codeblock>var dbReq = new <a class="idltype" href="#DatabaseRequest">DatabaseRequest</a>();
dbReq.<a class="idltype" href="#handler-request-onsuccess">onsuccess</a> = function(evt) {...};
dbReq.<a class="idltype" href="#handler-request-onerror">onerror</a> = function(evt) {...};
dbReq.<a class="idltype" href="#database-open">open</a>('AddressBook', '1', 'Address Book', function(txn, db) {...});</codeblock>
          </div>
          <p>
            This API uses an event handler mechanism to obtain database objects.
            If an error occurs while opening the database, an error handler is invoked.
            Otherwise, a success handler is invoked.
          </p>
          <dl class="idl" title="interface DatabaseRequest : DBRequest">
            <dt>readonly attribute Database database</dt>
            <dd> </dd>

            <dt>void open()</dt>
            <dd>
              <dl class="parameters">
                <dt>DOMString       name</dt>
                <dd></dd>
                <dt>DOMString       version</dt>
                <dd> </dd>
                <dt>DOMString       displayName</dt>
                <dd> </dd>
                <dt>optional UpgradeCallback upgrade</dt>
                <dd> </dd>
                <dt>unsigned short  isolation</dt>
                <dd> </dd>
              </dl>
              <p>
                This
                method takes the following arguments: a database name, a database
                version, a display name, an optional upgrade callback, and an optional 
                isolation level. When called, this method must return immediately and 
                asynchronously perform the following steps, with all but the first two
                and last steps being run atomically:
              </p>
              
              <ol>
     
                <li>
                  <span>Queue a task</span> to fire an event with the name <code>success</code>,
                  with no namespace, which does not bubble, is not cancelable, and which uses the
                  <a><code>DatabaseEvent</code></a> interface
                  and <var>result</var> at each <code>Window</code> or <code>WorkerUtils</code> object.
                </li>
              </ol>
            
              <p>
                The <dfn id="database-failure-steps">database failure steps</dfn> performed with an 
                error code are as follows:
              </p>
            
              <ol>
                <li>
                  Create a <a><code>DatabaseError</code></a> object 
                  <var>error</var> where code is the error code passed to these steps and status is 0.
                </li>
                <li>
                  <span>Queue a task</span> to fire an event with the name <code>error</code>,
                  with no namespace, which does not bubble, is not cancelable, and which uses the
                  <a><code>DatabaseErrorEvent</code></a> interface
                  and <var>error</var> at each <code>Window</code> or <code>WorkerUtils</code> object.
                </li>
              </ol>
            </dd>
          </dl>  
                          
          <p>
            The <span>task source</span> for these tasks is the 
            <dfn id="database-access-task-source">database access task source</dfn>.
          </p>    
        </section>
        
        <section class="section" id="object-store">  
          <h4>Object Store</h4>
          <div class="example">       
            <p>
              In the following example, we open the same database as in the earlier
              example using the asynchronous API. The <code>storeReq</code> is
              initialized with an <code>open()</code> call.
            </p>
            <codeblock>var store = storeReq = null;
var dbReq = new <a class="idltype" href="#DatabaseRequest">DatabaseRequest</a>();
dbReq.<a class="idltype" href="#handler-request-onsuccess">onsuccess</a> = 
  function() {
    storeReq = new <a class="idltype" href="#ObjectStoreRequest">ObjectStoreRequest</a>(dbReq.database);
    storeReq.<a class="idltype" href="#store-request-open">open</a>('Contact');
  };
var upgrade = 
  function(upgrade, db) {
    upgrade.<a class="idltype" href="#create-object-store">createObjectStore</a>('Contact', 'id');
  });
dbReq.<a class="idltype" href="#database-request-open">open</a>('AddressBook', '1', 'Address Book');</codeblock>
    
              <p>
                An asynchronous call to put an object in the object store can be performed
                once the <code>open()</code> call succeeds.
              </p>
              <codeblock>function saveContact(contact, success) {
  storeReq.<a class="idltype" href="#handler-request-onsuccess">onsuccess</a> = success;
  storeReq.<a class="idltype" href="#object-store-put">put</a>(contact);
};

var lincoln = {id: 1, name: 'Lincoln', number: '7012'};
saveContact(lincoln, function() {
  //storeReq.<a class="idltype" href="#store-request-result">result</a>.id == 1
});</codeblock>
              <p>
                Objects in the object store can be read using their key.
              </p>
              <codeblock>function loadContact(id, success) {
  storeReq.<a class="idltype" href="#handler-request-onsuccess">onsuccess</a> = success;
  storeReq.<a class="idltype" href="#store-get">get</a>(id);
};

loadContact(1, function() {
  // storeReq.<a class="idltype" href="#store-request-result">result</a>.id === 1 &amp;&amp; storeReq.result.name === 'Lincoln';
});</codeblock>
            </div>
              
            <dl class="idl" title="[Constructor(in Database db)] interface ObjectStoreRequest : DBRequest">
              <dt>readonly attribute any result</dt>
              <dd> </dd>
              <dt>void open()</dt>
              <dd>
                <dl class="parameters">
                  <dt>DOMString       name</dt>
                  <dd></dd>
                  <dt>optional unsigned short mode</dt>
                  <dd> </dd>
                </dl>
              </dd>
              <dt>any put()</dt>
              <dd>
                <p>
                  This method is used to 
                  store the given object in the object store. Insert the object by performing the 
                  <a class="dfnref" href="#insertion-steps">insertion steps</a>.
                </p>
                <dl class="parameters">
                  <dt>any obj</dt>
                  <dd></dd>
                </dl>
                <div class="exception" title="DatabaseException">
                </div>
              </dd>
              <dt>void delete()</dt>
              <dd>
                <p>
                  The <dfn id="store-request-delete"><code>delete()</code></dfn> method is used to 
                  delete the object associated with the given key in the object store. Delete the
                  object by performing the <a href="#deletion-steps">deletion steps</a>.
                </p>    
                <dl class="parameters">
                  <dt>any key</dt>
                  <dd></dd>
                </dl>
                <div class="exception" title="DatabaseException">
                </div>
              </dd>
              <dt>any get()</dt>
              <dd>
                <p>
                  The <dfn id="store-request-get"><code>get()</code></dfn> method is used to retrieve
                  the object associated with the given key in the object store. The following steps 
                  must be run for retrieving the object with the following parameters: <var>key</var>.
                </p>
                <dl class="parameters">
                  <dt>any key</dt>
                  <dd></dd>
                </dl>
                <div class="exception" title="DatabaseException">
                </div>
              </dd>
            </dl>  
          </section>
          
          <section id="index" class="section">  
            <h4>Index</h4>
            <dl class="idl" title="[Constructor(in Database db)] interface IndexRequest : DBRequest">
              <dt>readonly attribute any result</dt>
              <dd></dd>
              <dt>void open()</dt>
              <dd>(     in DOMString name,
                             in DOMString storeName,
                             in optional boolean forReadonly)</dd>
              <dt>void get()</dt>
              <dd>(      in any key);</dd>
              <dt>void getObject()</dt>
              <dd>(in any key);</dd>
              <dt>void delete()</dt>
              <dd>(   in any key);</dd>
            </dl>  
            
          </section>
          
          <section class="section" id="cursor">
            <h4>Cursor</h4>
        
            <dl class="idl" title="[Constructor(in Database db)] interface CursorRequest : DBRequest">
              <dt>readonly attribute unsigned long long count</dt>
                  <dd></dd>
              <dt>attribute CursorCallback callback</dt>
                  <dd></dd>
              <dt>void readStore()</dt>
              <dd>(      in          DOMString      storeName, 
                                 in optional <a href="#CursorRange">CursorRange</a>    range, 
                                 in optional unsigned short direction)</dd>
              <dt>void readIndex()</dt>
              <dd>(      in          DOMString      storeName, 
                                 in          DOMString      indexName,
                                 in optional <a href="#CursorRange">CursorRange</a>    range, 
                                 in optional unsigned short direction)</dd>
              <dt>void readIndexObject()</dt>
              <dd>(in          DOMString      storeName, 
                                 in          DOMString      indexName,
                                 in optional <a href="#CursorRange">CursorRange</a>    range, 
                                 in optional unsigned short direction);</dd>
          </dl>  
          </section>
          
          <section class="section" id="transaction">
            <h4>Transaction</h4>
            <dl class="idl" title="interface Transaction : TransactionSync">
              <dt>attribute Function oncommitted</dt>
              <dd></dd>
              <dt>attribute Function onaborted</dt>
              <dd></dd>
            </dl>

            <dl class="idl" title="[Constructor(in Database db)] interface TransactionRequest : DBRequest">
              <dt>readonly attribute Transaction transaction</dt>
              <dd> </dd>
              <dt>void open()</dt>
              <dd>
                <p>
                  When called, this
                  method must immediately return and then asynchronously perform the
                  <a href="#transaction-steps">transaction steps</a>.
                </p>
                <p>
                  The <dfn id="transaction-steps">transaction steps</dfn> are as follows. 
                  These steps are invoked with a
                  transaction callback, and the following optional arguments - a success
                  callback, an error callback, an array of database objects for acquiring
                  locks required in this transaction, and a timeout duration.
                </p>
                
                <ol>
                  <li>
                     Perform the <a href="#create-a-transaction-object">transaction creation steps</a> 
                     with the array of database objects and timeout duration passed to these
                     steps. Let the resulting <a><code>Transaction</code></a>
                     object be <var title="">transaction</var>.
                  </li>
                  
                  <li>
                    <span>Queue a task</span> to invoke the <em>transaction callback</em> 
                    with <var>transaction</var> as its only argument, and wait for 
                    that task to be run.
                  </li>
                  
                  <li>
                    If the callback couldn't be called (e.g. it was null), or if the
                    callback was invoked and raised an exception, jump to the last step.
                  </li>
      
                  <li>
                    <span>Queue a task</span> to invoke the <em>success callback</em>.
                  </li>
      
                  <li>
                    End these steps. 
                  </li>
                  
                  <li>This step is only used when something goes wrong.
                    <ol>
                      <li>
                        If <var>transaction</var> is still not committed or rolled back,
                        then rollback the transaction.
                      </li>
                      
                      <li>
                        If an error callback was passed to these steps, then <span>queue a task</span> 
                        to invoke the it with a newly constructed 
                        <a><code>DatabaseError</code></a>
                        with code
                        <a><code>UNKNOWN_ERR</code></a>.
                      </li>
                    </ol>
                  </li>
                </ol>
                <dl class="parameters">
                  <dt>optional DOMStringList storeNames</dt>
                  <dd> </dd>
                  <dt>optional unsigned int  timeout</dt>
                  <dd> </dd>
                </dl>
              </dd>
            </dl>  
        </section>        
        <section class="section" id="event-handler">
          <h4>Events</h4>
          <p>
            The following are the <span>event handlers</span> (and their corresponding 
            <span>event handler event types</span>) that must be supported, as IDL
            attributes, by objects implementing the various interfaces:
          </p>
          
          <table>
            <thead><tr>
              <th><span>Event handler</span> </th>
              <th>Supported by interfaces</th>
              <th><span>Event handler event type</span></th>
            </tr></thead>
            <tbody>
              <tr>
                <td><dfn id="handler-request-onsuccess"><code>onsuccess</code></dfn> </td>
                <td> <code><a class="idltype" href="#event-success">success</a></code></td>
                <td> 
                  <code><a>DatabaseRequest</a></code>
                </td>
              </tr>
              <tr>
                <td><dfn id="handler-request-onerror"><code>onerror</code></dfn> </td>
                <td> <code><a class="idltype" href="#event-error">error</a></code></td>
                <td> 
                  <code><a>DatabaseRequest</a></code>
                </td>
              </tr>
              <tr>
                <td><dfn id="handler-request-oncommitted"><code>oncommitted</code></dfn> </td>
                <td> <code><a class="idltype" href="#event-commit">commit</a></code></td>        
                <td> <code><a>TransactionRequest</a></code></td>
              </tr>
              <tr>
                <td><dfn id="handler-request-onaborted"><code>onaborted</code></dfn> </td>
                <td> <code><a class="idltype" href="#event-abort">abort</a></code></td>        
                <td> <code><a>TransactionRequest</a></code></td>
              </tr>
            </tbody>
          </table>        
        </section>
      </section>
            
      <section id="database-exception" class="section">
        <h3>Exceptions and Errors</h3>
        <p>
          Errors in the asynchronous database API are reported using 
          callbacks that have a <a><code>DatabaseError</code></a> 
          object as one of their arguments.
        </p>
        <dl class="idl" title="interface DatabaseError">
          <dt>attribute unsigned short code</dt>
          <dd>
            Return the most appropriate code.
          </dd>
          <dt>attribute int status</dt>
          <dd>
            Return the detailed error status of the database.
          </dd>
          <dt>attribute DOMString message</dt>
          <dd>
            Return an error message describing the exception raised. 
            The message should be localized to the user's language.
          </dd>
        </dl>  

        <dl class="idl" title="exception DatabaseException">
          <dt>const unsigned short UNKNOWN_ERR = 0</dt>
          <dd>The operation failed for reasons unrelated to the database
            itself and not covered by any other error code.</dd>
          <dt>const unsigned short NON_TRANSIENT_ERR = 1</dt>
          <dd>This error occurred because an operation was not allowed on 
          an object. A retry of the same operation would fail unless the
          cause of the error is corrected.</dd>
          <dt>const unsigned short VERSION_ERR = 2</dt> 
          <dd>The operation failed because the actual database version was
          not what was expected or no upgrade function was passed even though
          the requested version was not found or the upgrade function threw
          an exception.
          </dd>
          <dt>const unsigned short NOT_FOUND_ERR = 3</dt>
          <dd>The operation failed because the requested database
          object could not be found. For example, an object store
          did not exist but was being opened, or a sequence was 
          used to create an object store, but did not exist.</dd>
          <dt>const unsigned short CONSTRAINT_ERR = 4</dt>
          <dd>A mutation operation in the transaction failed due to a
          because a constraint was not satisfied. For example, an
          object such as an object store, sequence, or index already
          exists and a new one was being attempted to be created.</dd>
          <dt>const unsigned short DATA_ERR = 5</dt>
          <dd>Data provided to an operation does not meet requirements,
          e.g., if the increment value for a sequence is set to 0.</dd>
          <dt>const unsigned short FEATURE_ERR = 6</dt>
          <dd>A feature defined in this API was used but is not supported
          by the underlying implementation.</dd>
          <dt>const unsigned short SERIAL_ERR = 11</dt>
          <dd>The operation failed because of the size of the data set 
          being returned or because there was a problem in serializing or 
          deserializing the object being processed.</dd>
          <dt>const unsigned short TOO_LARGE_ERR = 12</dt>
          <dd>The operation failed because the data returned from the
          database was too large.</dd>
          <dt>const unsigned short RECOVERABLE_ERR = 21</dt>
          <dd>The operation failed because the database was prevented
          from taking an action. The operation might be able to succeed
          if the application performs some recovery steps and retries
          the entire transaction. For example, there was not enough 
          remaining storage space, or the storage quota was reached
          and the user declined to give more space to the database.</dd>
          <!--const unsigned short QUOTA_ERR = 22;
              <dd>The statement failed because there was not enough remaining
   storage space, or the storage quota was reached and the user
   declined to give more space to the database.</dd>-->
          <dt>const unsigned shrot TRANSIENT_ERR = 31</dt>
          <dd>The operation failed because of some temporary problems.
          The failed operation might be able to succeed when the
          operation is retried without any intervention by 
          application-level functionality.</dd>
          <dt>const unsigned short TIMEOUT_ERR = 32</dt>
          <dd>A lock for the transaction could not be obtained in a
          reasonable time.</dd>
          <dt>const unsigned short DEADLOCK_ERR = 33</dt>
          <dd>The current transaction was automatically rolled back
          by the database becuase of deadlock or other transaction
          serialization failures.</dd>
          <dt>attribute unsigned short code</dt>
          <dd>
            Return the most appropriate code.
          </dd>
          <dt>attribute int status</dt>
          <dd>
            Return the detailed error status of the database.
          </dd>
          <dt>attribute DOMString message</dt>
          <dd>
            Return an error message describing the exception raised. 
            The message should be localized to the user's language.
          </dd>
        </dl>  
      </section>     
    </section> <!-- API -->      
      
    <section id="privacy" class="section">
      <h2>Privacy</h2>
      
      <section id="user-tracking" class="section">
        <h3>User tracking</h3>
        
        <p>
          A third-party host (or any object capable of getting content 
          distributed to multiple sites) could use a unique identifier 
          stored in its client-side database to track a user across multiple 
          sessions, building a profile of the user's activities. In conjunction
          with a site that is aware of the user's real idobject (for 
          example an e-commerce site that requires authenticated credentials),
          this could allow oppressive groups to target individuals with
          greater accuracy than in a world with purely anonymous Web usage.
        </p>
        
        <p>
          There are a number of techniques that can be used to mitigate the
          risk of user tracking:
        </p>
        
        <dl>
          <dt>Blocking third-party storage</dt>
          <dd>
            User agents may restrict access to the database objects
            to scripts originating at the domain of the top-level document of
            the <span>browsing context</span>, for instance denying access to
            the API for pages from other domains running in <code>iframe</code>s.
          </dd>

          <dt>Expiring stored data</dt>
          <dd>
            <p>User agents may automatically delete stored data after a period
            of time.</p>

            <p>This can restrict the ability of a site to track a user, as the
            site would then only be able to track the user across multiple
            sessions when he authenticates with the site itself (e.g. by
            making a purchase or logging in to a service).</p>
        
            <p>However, this also puts the user's data at risk.</p>
          </dd>

          <dt>Treating persistent storage as cookies</dt>
          <dd>          
            <p>User agents should present the database feature
            to the user in a way that associates them strongly with HTTP
            session cookies. [[!COOKIES]]</p>
        
            <p>This might encourage users to view such storage with healthy
            suspicion.</p>
          </dd>

          <dt>Site-specific white-listing of access to databases</dt>
          <dd>
            <p>User agents may require the user to authorize access to
            databases before a site can use the feature.</p>
          </dd>
      
          <dt>Origin-tracking of stored data</dt>          
          <dd>
            <p>User agents may record the <span title="origin">origins</span>
            of sites that contained content from third-party origins that
            caused data to be stored.</p>
            
            <p>If this information is then used to present the view of data
            currently in persistent storage, it would allow the user to make
            informed decisions about which parts of the persistent storage to
            prune. Combined with a blacklist ("delete this data and prevent
            this domain from ever storing data again"), the user can restrict
            the use of persistent storage to sites that he trusts.</p>
          </dd>
      
          <dt>Shared blacklists</dt>
          <dd>          
            <p>User agents may allow users to share their persistent storage
            domain blacklists.</p>
      
            <p>This would allow communities to act together to protect their
            privacy.</p>
          </dd>
        </dl>

        <p>
          While these suggestions prevent trivial use of this API for user
          tracking, they do not block it altogether. Within a single domain, a
          site can continue to track the user during a session, and can then
          pass all this information to the third party along with any
          identifying information (names, credit card numbers, addresses)
          obtained by the site. If a third party cooperates with multiple
          sites to obtain such information, a profile can still be
          created.
        </p>
        
        <p>
          However, user tracking is to some extent possible even with no
          cooperation from the user agent whatsoever, for instance by using
          session identifiers in URLs, a technique already commonly used for
          innocuous purposes but easily repurposed for user tracking (even
          retroactively). This information can then be shared with other
          sites, using using visitors' IP addresses and other user-specific
          data (e.g. user-agent headers and configuration settings) to combine
          separate sessions into coherent user profiles.          
        </p>
      </section>

      <section id="cookie-resurrection" class="section">
        <h3>Cookie resurrection</h3>
        
        <p>
          If the user interface for persistent storage presents data in the
          persistent storage features described in this specification
          separately from data in HTTP session cookies, then users are likely
          to delete data in one and not the other. This would allow sites to
          use the two features as redundant backup for each other, defeating a
          user's attempts to protect his privacy.
        </p>
      </section>
      
      <section id="sensitivity-of-data" class="section">
        <h3>Sensitivity of data</h3>
        
        <p>
          User agents should treat persistently stored data as potentially
          sensitive; it's quite possible for e-mails, calendar appointments,
          health records, or other confidential documents to be stored in this
          mechanism.
        </p>
        
        <p>To this end, user agents should ensure that when deleting data,
          it is promptly deleted from the underlying storage.
        </p>
      </section>
    </section> <!-- Privacy -->

    <section id="authorization" class="section">
      <h2>Authorization</h2>
      
      <section id="dns-spoofing-attacks" class="section">
        <h3>DNS spoofing attacks</h3>
        
        <p>
          Because of the potential for DNS spoofing attacks, one cannot
          guarantee that a host claiming to be in a certain domain really is
          from that domain. To mitigate this, pages can use SSL. Pages using
          SSL can be sure that only pages using SSL that have certificates
          identifying them as being from the same domain can access their
          databases.
        </p>
      </section>
  
      <section id="cross-directory-attacks" class="section">
        <h3>Cross-directory attacks</h3>
        
        <p>
          Different authors sharing one host name, for example users
          hosting content on <code>geocities.com</code>, all share one
          set of databases.
        </p>
        
        <p>
          There is no feature to restrict the access by pathname. Authors on
          shared hosts are therefore recommended to avoid using these
          features, as it would be trivial for other authors to read the data
          and overwrite it.
        </p>
        
        <p class="note">Even if a path-restriction feature was made
          available, the usual DOM scripting security model would make it
          trivial to bypass this protection and access the data from any
          path.
        </p>
      </section>
      
      <section id="implementation-risks" class="section">
        <h3>Implementation risks</h3>
        
        <p>The two primary risks when implementing these persistent storage
        features are letting hostile sites read information from other
        domains, and letting hostile sites write information that is then
        read from other domains.</p>
        
        <p>Letting third-party sites read data that is not supposed to be
        read from their domain causes <em>information leakage</em>, For
        example, a user's shopping wishlist on one domain could be used by
        another domain for targeted advertising; or a user's
        work-in-progress confidential documents stored by a word-processing
        site could be examined by the site of a competing company.</p>
        
        <p>Letting third-party sites write data to the persistent storage of
        other domains can result in <em>information spoofing</em>, which is
        equally dangerous. For example, a hostile site could add records to a
        user's wishlist; or a hostile site could set a user's session
        identifier to a known ID that the hostile site can then use to track
        the user's actions on the victim site.</p>
        
        <p>Thus, strictly following the <span>origin</span> model described
        in this specification is important for user security.</p>
      </section>
    </section> <!-- authorization -->
    
    <section class="appendix section" id="requirements">
      <h2>Requirements</h2>
      <div class="ednote">
        Requirements will be written with an aim to verify that these were actually
        met by the API specified in this document.
      </div>
    </section>
  </body>
</html>
