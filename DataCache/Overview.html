<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Data Cache API</title>
    <meta name='revision' content='$Id: Overview.html,v 1.12 2009-12-16 23:54:21 nmehta3 Exp $'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/simple-node.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",
          
          shortName:            "DataCache",

          // publishDate:  "2009-09-29",

          previousPublishDate:  "2009-10-29",
          previousMaturity:  "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/DataCache/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          extraCSS: [
                "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                "DataCache.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Oracle Corp", companyURL: "http://www.oracle.com/" },
          ],
          
          maxTocLevel: 3,
          
          wg:           "Web Applications Working Group",
          
          wgURI:        "http://www.w3.org/2008/webapps/",
          
          wgPublicList: "public-webapps",
          
          wgPatentURI:  "http://www.w3.org/Consortium/Patent-Policy-20040205/",
      };
    </script>
    <script class="remove">
      function examples() {
        var examples = document.querySelectorAll('div.example');
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        for (var i = 0; i < examples.length; i++) {
          var example = examples.item(i);
          var header = sn.element('div', {'class': 'exampleHeader'}, null, 'Example');
          example.insertBefore(header, example.firstChild);
        }
      }
      
      function codeblocks() {
        document.normalize();
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        
        var blocks = document.querySelectorAll('codeblock');
        for (var i = 0; i < blocks.length; i++) {
          var codeblock = blocks.item(i);
          var div = sn.element('div', {'class': 'block'})
          sn.element('span', {'class': 'blockTitle'}, 
            sn.element('div', {'class': 'blockTitleDiv'}, div), 'ECMAScript');
          var code = sn.element('code', {'class': 'es-code'}, 
                       sn.element('pre', {'class': 'code'}, 
                         sn.element('div', {'class': 'blockContent'}, div)));
          sn.copyChildren(codeblock, code);
          codeblock.parentNode.replaceChild(div, codeblock);
        }
      }
      function codeRefs() {
        var codes = document.querySelectorAll('a>code');
        for (var i = 0; i < codes.length; i++) {
          var code = codes.item(i);
          var a = code.parentNode;
          a.setAttribute('class', 'idltype');
          a.setAttribute('href', '#idl-def-' + code.textContent); 
        }      
      }
      window.onload = function() {
        examples();
        codeblocks();
        codeRefs();
        (new berjon.respec()).loadAndRun();
      }
    </script>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->
    <style type="text/css">
      h5 {
        display: none
      }
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document defines APIs for off-line serving of requests to HTTP resources using
        static and dynamic responses.
      </p>
    </section>

    <section id="introduction" class="section informative">
      <h2>Introduction</h2>

      <p>
        Web applications often encounter seemingly random disconnections
        or network slowdowns, which deteriorates application responsiveness
        and availability, and, therefore, user experience. Working around
        network issues entails specially written applications, synchronization 
        programs, and data protocols for specific platforms.
      </p>
      
      <p>
        The standard HTTP caches built in to existing user agents 
        are under no obligation to locally store a cacheable resource 
        and do not provide any guarantees about off-line serving of 
        HTTP resources. An application cache [[!HTML5]]</cite>
        can hold static representations of a set of pre-defined resources
        that can be served locally. However, applications cannot
        alter this set of resources programmatically. Moreover, an
        application cache cannot satisfy requests other than 
        <code>GET</code> and <code>HEAD</code>.
      </p>
    
      <p>
        To address this limitation, this specification introduces data caches. 
        Instead of a static manifest resource listing the resources
        to be cached, a data cache can be modified programmatically.
        Web applications can add or remove resources in a data cache
        which can then be statically served by the user agent when that resource 
        is requested. This specification also provides embedded local servers
        to dynamically serve off-line representations of resources such as
        in response to unsafe HTTP methods, e.g., <code>POST</code>. 
      </p>
      
      <p>
        Using data caches and embedded local servers, applications can obtain 
        locally cached or served data and complete requests to  
        resources whether or not the requests can be serviced immediately 
        by a remote server. Applications can replay locally satisfied requests
        to the server thus enabling responsive and robust Web 
        applications in the presence of low connectivity conditions.
      </p>
      
      <p>
        This specification does not introduce a new programming model
        for Web applications as data caches and embedded local servers are
        transparently pressed into action by the user agent, depending
        on system conditions. This means that existing applications
        can be used unchanged in environments that are not affected
        by network unreliability. Applications can be altered to use APIs
        specified in this document, only if they require improved
        responsiveness. Such applications can seamlessly switch
        between on-line and off-line operation without needing explicit
        user action.
      </p>
    </section>

    <section id="conformance" class="section">
      <p>
        This specification defines one class of products:
      </p>
      <dl>
        <dt><dfn id="dfn-conforming-user-agent">Conforming user agent</dfn></dt>
        <dd>
          <p>
            A user agent must behave as described in this specification
            in order to be considered conformant.
          </p>
          
          <p>
            User agents may implement algorithms given in this
            specification in any way desired, so long as the end result is
            indistinguishable from the result that would be obtained by the
            specification's algorithms.
          </p>
          
          <p>
            A conforming DataCache user agent must also be a
            <em>conforming implementation</em> of the IDL fragments
            of this specification, as described in the
            âWeb IDLâ specification. [[!WEBIDL]]
          </p>
          
          <p class="note">
            This specification uses both the terms "conforming user agent(s)" 
            and "user agent(s)" to refer to this product class.
          </p>
        </dd>
      </dl>
      
      <section id="dependencies" class="section">
        <h3>Dependencies</h3>
          
        <p>This specification relies on several underlying specifications.</p>
        <dl>
          <dt>HTML5</dt>
          <dd>The terms and algorithms 
            <dfn id="event-handler-attributes">event handler attributes</dfn>, 
            <dfn id="event-handler-event-type">event handler event type</dfn>,
            <dfn>browsing context</dfn>, <dfn>current browsing context</dfn>,
            <dfn>child browsing contexts</dfn>, <dfn title="fetch">fetching resources</dfn>,
            <dfn title="Function"><code>Function</code></dfn>, <dfn>origin</dfn>, 
            <dfn>same origin</dfn>, <dfn>task</dfn>, <dfn>task source</dfn>, 
            and <dfn>queue a task</dfn>, <dfn>storage mutex</dfn> are referenced
            in this specification and defined by the HTML 5 specification [[!HTML5]].
          </dd>
          <dt>HTTP</dt>
          <dd>
            <p>
              A <a> conforming user agent</a> must support some version of the
              HTTP protocol [[!HTTP11]].
            </p>
          
            <p>
              In order to protect against attacks, the use of the following
              headers is prohibited using interfaces defined in this specification.
            </p>
          
            <ul>
             <li><code>Accept</code></li>
        
             <li><code>Accept-Charset</code></li>
        
             <li><code>Accept-Encoding</code></li>
        
             <li><code>Accept-Language</code></li>
        
             <li><code>Authorization</code></li>
        
             <li><code>Cache-Control</code></li>
        
             <li><code>Connection</code></li>
        
             <li><code>Content-Transfer-Encoding</code></li>
        
             <li><code>Cookie</code></li>
        
             <li><code>Date</code></li>
        
             <li><code>Expect</code></li>
        
             <li><code>Host</code></li>
        
             <li><code>Keep-Alive</code></li>
        
             <li><code>Origin</code></li>
        
             <li><code>Range</code></li>
        
             <li><code>Referer</code></li>
        
             <li><code>Set-Cookie</code></li>
        
             <li><code>TE</code></li>
        
             <li><code>Trailer</code></li>
        
             <li><code>Transfer-Encoding</code></li>
        
             <li><code>Upgrade</code></li>
        
             <li><code>User-Agent</code></li>
        
             <li><code>Via</code></li>
            </ul>
          </dd>
          <dt>HTTP State Management</dt>
          <dd>
            <p>
              A <a>conforming user agent</a> must support storage and
              exchange of cookies as specified by HTTP State Management 
              [[!COOKIES]].
            </p>
          </dd>
          <dt>File API</dt>
          <dd>The term  
            <dfn title="Blob"><code>Blob</code></dfn> is referenced by this
            specification and defined by the File API specification [[!FILE-API]].
          <dt>DOM</dt>
          <dd>
            <p>
              A <a>conforming user agent</a> must define the exception  
              codes defined in [[!DOM-LEVEL-3-CORE]] and referenced in 
              this specification.
            </p>
          </dd>
        </dl>
      </section>
    </section>
    
    <section id="terminology" class="section">
      <h2>Terminology</h2>

      <p>
        A resource is <dfn>captured</dfn> when it is added
        to a data cache.
      </p>
      
      <p>
        A resource is <dfn>released</dfn> when it is removed
        from a data cache.
      </p>
      
      <p>
        A <dfn>managed</dfn> resource is one whose URI is captured.
      </p>
      
      <p>
        A <dfn>static</dfn> representation is one that 
        is generated directly by the user agent from its internal storage.
      </p>
      
      <p>
        A <dfn>dynamic</dfn> representation is one that  
        is generated  programmatically by using application-supplied logic.
      </p>
      
      <p>
        <dfn title="off-line">Transparent off-line data access and manipulation</dfn>  
        means to locally generate a <a>static</a> or a <a>dynamic</a> 
        response for HTTP requests to <a>captured</a> resources.
      </p>
      <p>
        A <dfn>private</dfn> resource is one that requires explicit authorization.
      </p>
    </section>
            
    <section id="cache" class="section">
      <h2>Programmable HTTP Processing</h2>

      <p>
        Programmable HTTP processing enables applications to identify
        <a>managed</a> resources to a user agent and to produce <a>static</a> 
        and <a>dynamic</a> representations for responding to requests on
        these resources. 
      </p>
        
      <section id="datacache-intro" class="section informative">
        <h3>Introduction</h3>     

        <p>  
          A user agent processes network requests to <a>managed resources</a>
          in one of three ways: 
        </p>
        <ol>
          <li>
            <dfn>serve policy</dfn> - respond with the <a>static</a> representation  
            of the requested resource (for any safe HTTP methods) from a
            <a>data cache</a>. 
          </li>
          <li>
            <dfn>intercept policy</dfn> - 
            immediately invoke an <a>embedded local server</a> to obtain a 
            <a>dynamic</a> representation (for any HTTP methods). 
          </li>
          <li>
            <dfn>review policy</dfn> - 
            relay the request to the server to obtain a <a>dynamic</a>
            representation and notify an <a>embedded local server</a> 
            when that representation is available (only for unsafe HTTP methods). 
          </li>
        </ol>
        
        <p>
          The <a>serve policy</a> applies only to resources that do not
          require interception, whereas the <a>intercept policy</a> can only 
          be used for resources that require interception. Both policies
          improve availability and responsiveness. However, both may affect
          data freshness. The <a>review policy</a>
          can only be used when the user agent is able to communicate with
          the server. This policy improves data freshness at the cost of 
          reduced responsiveness. User agents may choose freely from among
          these options, e.g., using information about the system condition, 
          network state or battery power level, or a user preference.
        </p>
          
        <section class="section" id="examples">
          <h4>Examples</h4>

          <p>
            An application can use a <a>data cache</a> to 
            <a title="captured">capture</a> the representation of a resource, 
            i.e., cache an <a>off-line</a> representation in the <a>data cache</a>.  
          </p>
          
          <div class="example">    
            <p>
              Using a <a>data cache</a>, an application <a>captures</a> a resource
              as part of an atomic <a>cache transaction</a>. Once the resource is 
              <a>captured</a> successfully, the application places the <a>captured</a> 
              representation in to service.
            </p>
            <codeblock>var uri = ...
var cache = window.openDataCache();
// cache and immediately take advantage of the new stuff in the cache
cache.immediate(uri);</codeblock>
            <p>
              The user agent is able to then serve this <a>static</a> representation
              when an application issues a <code>GET</code> request for
              that resource either through page navigation or an XMLHttpRequest 
              [[XMLHTTPREQUEST]]. 
            </p>
            <codeblock>var req = new XMLHttpRequest();
req.open('GET', uri);
...
req.send();</codeblock>
          </div>              
          
          <p>
            A <a>dynamic</a> representation is produced by using an
            <a>embedded local server</a> in conjunction with the 
            <a>data cache</a>. An <a>interceptor</a> processes an HTTP
            request locally in an <a>embedded local server</a>
            without changing the network APIs used by applications. Thus 
            even if a host is unreachable, applications can successfully
            make HTTP requests to a <a>managed</a> resource.
          </p>

          <div class="example">      
            <p>
              In this example, a local requst handler can produce a <a>dynamic</a> 
              response  to an application request when the network is not accessible. 
              The response can be prepared using the <a>data cache</a>, for 
              example. The benefit of this technique is that applications don't need to 
              alter their applications to accommodate <a>off-line</a> use cases. 
              Instead, user agents can transparently introduce an application-specific 
              <a>off-line</a> handler to deal with situations when the network is not 
              available.  
            </p>
            <codeblock>var uri = ...
var cache = window.openDataCache();
var local = function(request, response) {
  response.statusCode = 200;
  response.statusLine = 'HTTP/1.1 OK';
  response.bodyText = ...
  response.send();
};

window.navigator.registerOfflineHandler(uri, local);

var txn = cache.offlineTransaction(function(txn) {
  txn.capture(uri, '', null, ['GET']);
  txn.commit();
});</codeblock>
            <p>
              Later when that application issues a <code>GET</code> request for
              the <a>managed</a> resource either through page navigation or an XMLHttpRequest 
              [[XMLHTTPREQUEST]], and the user agent is <a>off-line</a>, it invokes the
              <code>local</code> <a>off-line</a> handler which produces a <a>dynamic</a> 
              response. 
            </p>
            <codeblock>var req = new XMLHttpRequest();
req.open('GET', uri);
...
req.send();</codeblock>
          </div>              
         
          <p>
            Applications can also locally intercept requests that modify data, 
            e.g., unsafe HTTP requests such as <code>PUT</code> in an <a>off-line</a>
            handler. Requests to resources that are <a>managed</a> in a 
            <a>data cache</a> can be either:
          </p>
          <ul>
            <li>intercepted and served by an <a>interceptor</a>, when the
            user agent is <a>off-line</a> or</li>
            <li>the server, when the user agent is online with a <a>reviewer</a>  
          analyzing the result of the online request.</li>
          </ul>
          <p>
             A user agent can switch 
            between these two behaviors automatically based on system conditions.
          </p>
         
          <div class="example">
            <p>
              For example, an application worker script that wishes to allow <a>off-line</a>
              updates to <var>uri</var> <a title="captured">captures</a> that resource 
              in a <a>data cache</a>.
            </p>
            
            <codeblock>var uri = ...
var cache = self.openDataCacheSync();
var txn = cache.transactionSync();
txn.capture(uri, ['PUT']);
txn.commit();</codeblock>

            <p>
              Another application in the same origin could then register an <a>off-line</a>
              handler for the same <var>uri</var> to serve <a>off-line</a> requests to 
              that resource. 
            </p>
            
            <codeblock>cache = window.openDataCache();
var intercept = function(request, response) {
  if (...) {
    // validation fails
    response.setStatus(400, 'HTTP/1.1 Bad Request');
    response.send();
    return;
  } 
  cache.offlineTransaction(function(txn) {
    txn.oncommitted = function() {
      response.bodyText = request.bodyText;
      response.headers['Content-Type'] = type;
      response.statusCode = 200;
      response.statusLine = 'HTTP/1.1 OK';
      response.send();
    });
    txn.capture(request.targetURL, request.bodyText, request.headers['Content-Type']);
    txn.commit();    
  });
};

var review = function(request, response) {
  cache.offlineTransaction(function(txn) {
    txn.capture(request.targetURL, response.bodyText, response.headers['Content-Type']); 
    txn.commit();
  });
};

window.navigator.registerOfflineHandler(uri, intercept, review);</codeblock>

            <p>
              When the application makes a <code>PUT</code> request to 
              <var>uri</var> and the user agent is <a>off-line</a>,
              the user agent asks the <var>intercept</var> function to
              process the request and respond to it. If the user agent is online
              when the request arrives, then it sends the request to
              a host and asks the <var>review</var> function to process the
              response received from it.              
            </p>
            
            <codeblock>var req = new XMLHttpRequest();
req.open('PUT', uri);
...
req.send(...);</codeblock>

            <p>
              If this application makes a <code>GET</code> request to 
              <var>uri</var>, then its cached <a>static</a> representation is 
              returned as the response regardless of whether the user agent is off-line.
            </p>
            
            <codeblock>var req = new XMLHttpRequest();
req.open('GET', uri);
...
req.send();</codeblock>
          </div>
        </section>
          
        <section id="cache-events" class="section informative">
          <h4>Event summary</h4>
          
          <p>
            Application scripts may modify a <a>managed resource</a> of a 
            <a>data cache</a>. The user agent will fetch the representations
            of newly added and modified <a>managed</a> resources and add 
            the representations to the <a>data cache</a>.
          </p>
          
          <p>
            A number of events are fired to keep the application
            updated as to the state of the cache, so that the
            user can be notified appropriately. The events are as follows:
          </p>
          
          <table>
            <thead><tr><th>Event name</th><th>Occasion</th><th>Next events</th></tr></thead>
            <tbody>
              <tr>
                <td><dfn id="event-off-line-updating"><code>off-line-updating</code></dfn></td>
                <td>A script has started an <a>off-line transaction</a> to modify the <a>data cache</a>.</td>
                <td>
                  <a href="#event-captured" class="dfnref"><code>captured</code></a>, 
                  <a href="#event-released" class="dfnref"><code>released</code></a>, 
                  <a href="#event-ready" class="dfnref"><code>ready</code></a>
                </td>
              </tr>

              <tr>
                <td><dfn id="event-updating"><code>updating</code></dfn></td>
                <td>A script has started an <a>online transaction</a> to modify the <a>data cache</a>.</td>
                <td>
                  <a href="#event-fetching" class="dfnref"><code>fetching</code></a>, 
                  <a href="#event-released" class="dfnref"><code>released</code></a>, 
                  <a href="#event-ready" class="dfnref"><code>ready</code></a>
                </td>
              </tr>

              <tr>
                <td><dfn id="event-fetching"><code>fetching</code></dfn></td>
                <td>The user agent has started fetching the representation of
                a <a>managed</a> resource.</td>
                <td>
                  <a href="#event-captured" class="dfnref"><code>captured</code></a>, 
                  <a href="#event-obsolete" class="dfnref"><code>obsolete</code></a>, 
                  <a href="#event-error" class="dfnref"><code>error</code></a>
                </td>
              </tr>

              <tr>
                <td><dfn id="event-captured"><code>captured</code></dfn></td>
                <td>The user agent has finished fetching the representation of
                a <a>managed</a> resource and stored it.</td>
                <td>
                  <a href="#event-captured" class="dfnref"><code>captured</code></a>, 
                  <a href="#event-fetching" class="dfnref"><code>fetching</code></a>, 
                  <a href="#event-ready" class="dfnref"><code>ready</code></a>, 
                </td>
              </tr>

              <tr>
                <td><dfn id="event-released"><code>released</code></dfn></td>
                <td>The user agent has released a <a>managed</a> resource 
                and can no longer serve <a>off-line</a> requests to it.</td>
                <td>
                  <a href="#event-captured" class="dfnref"><code>captured</code></a>, 
                  <a href="#event-fetching" class="dfnref"><code>fetching</code></a>, 
                  <a href="#event-ready" class="dfnref"><code>ready</code></a>, 
                </td>
              </tr>

              <tr>
                <td><dfn id="event-ready"><code>ready</code></dfn></td>
                <td>All the <a>managed</a> resources have been cached for serving 
                <a>off-line</a> requests to them, and the script can use 
                <a title="widl-DataCache-swapCache"><code>swapCache()</code></a> to switch
                to the new cache.</td>
                <td>(Last event in sequence.)</td>
              </tr>

              <tr>
                <td><dfn id="event-obsolete"><code>obsolete</code></dfn></td>
                <td>The server returned a 401 error in response to a 
                request for fetching a <a>managed</a> resource's representation.</td>
                <td>(Last event in sequence.)</td>
              </tr>

              <tr>
                <td><dfn id="event-error"><code>error</code></dfn></td>
                <td>A fatal error occurred while fetching a <a>managed</a> resource's 
                representation.</td>
                <td>(Last event in sequence.)</td>
              </tr>

            </tbody>
          </table>            
        </section>
      </section>
        
        <section id="http-cache" class="section">
          <h3>Data Caches</h3>

          <p>
            A <a>data cache</a> is a programmable HTTP cache that can be 
            manipulated by a Web application to serve <a>off-line</a>
            representations of resources. <!--These representations can be either
            static, i.e., generated from a store, or dynamic, i.e., generated
            programmatically.-->
          </p>
          
          <p>
            A <dfn>data cache</dfn> is a set of <a>managed</a> resources
            consisting of the entity (i.e., headers and body) for each
            such resource that falls into one of the following categories:
          </p>

          <dl>          
            <dt><dfn>static entry</dfn></dt>
            <dd>
              A resource whose representation is cached for <a>off-line</a> serving.
              A request to a <a>static entry</a>
              can only be used with the <a>serve policy</a>.
            </dd>
            <dt><dfn>dynamic entry</dfn></dt>
            <dd>
              A resource whose representation is produced locally 
              by an application upon request. Each <a>dynamic entry</a> 
              identifies one or more <dfn>dynamic methods</dfn>
              for which a response can be obtained locally using an 
              <a>interceptor</a>.
            </dd>
          </dl>
          
          <p>
            Each <a>data cache</a> has a <dfn>completeness flag</dfn>, 
            which is either <var>incomplete</var> or <var>complete</var>.
          </p>
      
          <p>
            A <a>data cache</a> may have zero or one required 
            <dfn>authorization cookie</dfn>.
          </p>          
          
          <p>
            A <dfn>data cache group</dfn> is a group
            of <a>data cache</a>s identified by the <a>origin</a> in which it is created 
            and its <a>authorization cookie</a> [[!COOKIES]].
          </p>
          
          <p>
            Each <a>data cache</a> whose <a>completeness flag</a> 
            is <var>complete</var> has a <dfn>version</dfn>.
            No two <a>data cache</a>s in a <a>data cache group</a> 
            may have the same <a>version</a>. A <a>data cache</a>
            is <dfn>newer</dfn> than another if it's <a>version</a>
            is bigger than the other (in other words <a>data cache</a>s in a
            <a>data cache group</a> have a chronological order).
          </p>
          
          <!--p>
            Only the newest <a class="dfnref" href="#data-cache">data cache</a>
            in a <a href="#data-cache-group" class="dfnref">data cache group</a>
            can have its <a href="#data-cache-complete">completeness flag</a>
            set to <var>incomplete</var>, all the others are 
            always <var>complete</var>.
          </p-->
          
          <p>
            Each <a>data cache group</a> has an <dfn>update status</dfn>, which
            is one of the following: <var>idle</var> or <var>updating</var>.
          </p>
          
          <p>
            A <dfn>relevant data cache</dfn> is a <a>data cache</a> that is 
            the <a title="newer">newest</a> in its 
            <a title="data cache group">group</a> to be <var>complete</var>.
          </p>
          
          <p>
            An <dfn >unsecure <a>data cache group</a></dfn> is not secured with an 
            <a>authorization cookie</a> and cannot serve <a>private</a> resources.
            A <dfn>secure <a>data cache group</a></dfn> controls access to 
            <a>private</a> resources using an <a>authorization cookie</a>. 
          </p>
          
          <p>
            A <dfn>cache host</dfn> is a <code>Document</code>
            or a <code>SharedWorkerGlobalScope</code> object [[!WEBWORKERS]]. 
          </p>
          
          <p>
            If a <a>data cache group</a> is <dfn>available</dfn> to a 
            <a>cache host</a>, then it can be associated with the <a>cache host</a>.
            A <a>secure data cache group</a> is <a>available</a> to a 
            <a>cache host</a> if its <a>authorization cookie</a> 
            will be sent to an origin server for fetching that 
            <a>cache host</a> [[!COOKIES]]. An <a>unsecure data cache group</a>
            is <a>available</a> to a <a>cache host</a> if its <a>origin</a> is
            the same as its <a>cache host</a>'s.
          </p>
          
          <p>
            A <a>data cache group</a> can be marked as <dfn>obsolete</dfn>, 
            meaning that it cannot be made <a>available</a> to a 
            <a>cache host</a>.
          </p>
          
          <p>
            When a <code>SharedWorkerGlobalScope</code> is created or when a 
            <code>Document</code> is loaded, the <a>relevant data cache</a> of 
            every <a>available</a> <a>data cache group</a> is associated with it as 
            the <dfn>effective data cache</dfn> in that <a>data cache group</a>.
          </p>
                  
          <p>
            Multiple <a>effective data cache</a>s may contain the representation
            of a given resource. If the user agent is to <dfn>select a data cache</dfn>
            from a list of <a>relevant data cache</a>s that contain the representation
            of a required resource, then the user agent must use the 
            <a>data cache</a> that the user most likely wants
            to see the representation from, taking into account the following:
          </p>
          
          <ul>
            <li>which <a>data cache</a> belongs to a <a>secure data cache group</a></li>
            <li>which <a>data cache</a> contains the latest representation of the 
            required resource</li>
            <li>what <a>data cache</a> the user prefers</li>
          </ul>
            <p>
              Application scripts identify the resources managed by a
              <a>data cache</a> during a <dfn>cache transaction</dfn>, 
              when applications may either <a title="captured">capture</a> or 
              <a title="released">release</a> its resources. 
            </p>

            <p>
              Each <a>cache transaction</a> has a <a>data cache group</a>
              and a <a>data cache</a>.
            </p>
            
            <p>
              A <a>cache transaction</a>  can be marked as 
              <dfn>off-line transaction</dfn>.
            </p>
            
            <p>
              Each <a>cache transaction</a> has a <dfn>commit status</dfn>, 
              which can be either of <var>pending</var>, <var>committed</var>, or
              <var>aborted</var>.
            </p>
            
            <p>
              When a <a>cache transaction</a> is started, the user agent must run the 
              steps to <a>create a cache transaction</a>. When a resource is added to 
              a transaction's list of <a>captured</a> resources, the user agent must run  
              the steps to <a>add a resource to be captured</a>. When a resource is added to 
              a transaction's list of released resources, the user agent must run the 
              steps to <a>add a resource to be released</a>. When the transaction is finished, 
              the user agent must run either the steps to <a>commit a cache transaction</a>
              or the steps to <a>abort a cache transaction</a>.
            </p>

          <section class="section" id="opening-cache">
            <h4>Opening a cache</h4>
            
            <p>
              When the user agent is required to <dfn>open a data cache</dfn>, 
              given a <a>cache host</a>, and optionally the name of an
              <a>authorization cookie</a>, the user agent must perform the 
              following steps:
            </p>
            
            <ol>
              <li>
                Let <var>cookie name</var> be the name of an
                <a>authorization cookie</a> passed to these steps.
              </li>
            
              <li>
                Pick the appropriate sub-steps:
                <dl class="switch">
                  <dt>If the <a>cache host</a> passed to these steps is a
                  <code>Window</code> object</dt> 
                  <dd>
                    Let <var>origin</var> be the <a>origin</a> of the
                    <a>active document</a> of the <a>browsing context</a>
                    of that <code>Window</code> object.
                  </dd>
                  
                  <dt>If the <a>cache host</a>
                  passed to these steps is a <code>WorkerUtils</code> object</dt>
                  <dd>  
                    Let <var>origin</var> be the <a>origin</a> of the scripts in the worker.
                  </dd>
                </dl>
              </li>
              
              <li>
                Atomically, so as to avoid race conditions, perform the following sub-steps:
                <dl class="switch">
                  <dt>If <var>cookie name</var> is empty, then perform the following steps:</dt>
                  <dd>
                    <ol>
                      <li>
                        If there is an <a>unsecure data cache group</a> for
                        <a>origin</a> <var>origin</var>, then perform the 
                        following sub-steps:
                        <ol>
                          <li>
                            Let <var>data cache group</var> be that existing 
                            <a>data cache group</a>.
                          </li>
                          <li>
                            Let <var>data cache</var> be the the <a>relevant data cache</a>
                            in <var>data cache group</var>.
                          </li>
                        </ol>
                      </li>
                      <li>
                        If <var>data cache group</var> does not exist, then perform the 
                        following sub-steps:
                        <ol>
                          <li>Create a new <a>data cache</a>, called
                            <var>data cache</var>, in a new
                            <a>unsecure data cache group</a> for <a>origin</a> <var>origin</var> 
                            called <var>data cache group</var>.
                          </li>
                          <li>
                            Set the <a>completeness flag</a> of <var>data cache</var> to 
                            <var>incomplete</var>.
                          </li>
                          
                          <li>
                            Set the <a>update status</a> of <var>data cache group</var>
                            to <var>idle</var>.
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </dd>
                  <dt>If <var>cookie name</var> is not empty, then perform the following steps:</dt>
                  <dd>
                    <ol>
                      <li>
                        Let <var>data cache group</var> be an existing 
                        <a>secure data cache group</a> for <a>origin</a> <var>origin</var>, the
                        name of whose <a>authorization cookie</a> case-insensitively matches
                        <var>cookie name</var>.
                      </li>
    
                      <li>Obtain the <a>storage mutex</a>.</li>
    
                      <li>
                        Let <var>cookie</var> be the cookie in the 
                        <a>current browsing context</a>, whose name case-insensitively
                        matches <var>cookie name</var>. 
                      </li>
                      
                      <li>
                        If <var>data cache group</var> is defined and has an 
                        <a>authorization cookie</a> whose value doesn't match 
                        <var>cookie</var>'s value, or if <var>data cache group</var>
                        is not defined, then perform the following sub-steps:
                        <ol>
                          <li>Mark <var>data cache group</var> <a>obsolete</a>.</li>
                          <li>
                            Create a new <a>data cache</a>, called <var>data cache</var>, 
                            in a new <a>secure data cache group</a> for <a>origin</a> 
                            <var>origin</var> called <var>data cache group</var> with its 
                            <a>authorization cookie</a> set to <var>cookie</var>.
                          </li>
                          <li>
                            Set the <a>completeness flag</a> of <var>data cache</var> to 
                            <var>incomplete</var>.
                          </li>
                          
                          <li>
                            Set the <a>update status</a> of <var>data cache group</var>
                            to <var>idle</var>.
                          </li>
                        </ol>
                      </li>
    
                      <li>Release the <a>storage mutex</a>.</li>
                    </ol>
                  </dd>              
                </dl>
              </li>
              <li>
                Return <var>data cache</var>.            
              </li>
            </ol>
          </section>
            
          <section class="section" id="starting-a-transaction">
            <h4>Starting a transaction</h4>
            
            <p>
              When the user agent is required to <dfn>create a cache transaction</dfn> 
              given a <a>data cache group</a> and an off-line flag, the user agent
              must run the following steps:
            </p>
            
            <ol>
              <li>
                Let <var>cache group</var> be the <a>data cache group</a> 
                passed to these steps.
              </li>
              <li>
                If <var>cache group</var> is marked <a>obsolete</a>, then 
                raise an exception and abort these steps.
              </li>
              <li>
              Pick the appropriate steps:
              <dl class="switch">
                <dt>If the off-line flag passed to these steps is set.</dt>
                <dd>
                  <ol>
                    <li>
                      Create a new <a>data cache</a>, 
                      called <var>data cache</var>, in <var>cache group</var>.
                    </li>
                    <li>
                      Set the <a>completeness flag</a> of <var>data cache</var> to 
                      <var>incomplete</var>.
                    </li>
                    <li>
                      Mark <var>transaction</var> as <a>off-line transaction</a>.
                    </li>
                    <li>
                      Create a new <a>cache transaction</a> called <var>transaction</var> and
                      set <var>data cache</var> to be its <a>data cache</a>.
                    </li>
                    <li>
                      For each <a>cache host</a> associated with a <a>data cache</a> in 
                      <var>cache group</var>, <a>queue a task</a> to fire an event at the 
                      <a>cache host</a> with the name 
                      <a href="#event-off-line-updating"><code>off-line-updating</code></a>, 
                      which does not bubble, is not cancelable, and which uses the
                      <a><code>CacheEvent</code></a> interface.
                    </li>
                    <li>
                      Return <var>transaction</var>.
                    </li>
                  </ol>
                </dd>
                
                <dt>If the off-line flag passed to these steps is not set.</dt>
                <dd>
                  <ol>
                    <li>
                      Atomically, so as to avoid race conditions, perform the following sub-steps
                      <ol>
                        <li>
                          If the <a>update status</a> of <var>cache group</var> is <var>updating</var>,
                          then raise an exception and abort
                          these steps, as a <a>cache transaction</a> is already open on this
                          <a>data cache group</a>.
                        </li>
                        <li>
                          Set the <a>update status</a> of <var>cache group</var> to <var>updating</var>.
                        </li>
                      </ol>
                    </li>
                    <li>
                      Create a new <a>data cache</a>, 
                      called <var>data cache</var>, in <var>cache group</var>
                      which holds all the same resources as the 
                      <a>relevant data cache</a> of <var>cache group</var>.
                    </li>
                    <li>
                      Set the <a>completeness flag</a> of <var>data cache</var> to 
                      <var>incomplete</var>.
                    </li>
                    <li>
                      Mark <var>transaction</var> as not <a title="off-line transaction">off-line</a>.
                    </li>
                    <li>
                      Create a new <a>cache transaction</a> called <var>transaction</var> and
                      set <var>data cache</var> to be its <a>data cache</a>.
                    </li>
                    <li>
                      For each <a>cache host</a> associated with a
                      <a>data cache</a> in <var >cache group</var>, <a>queue a task</a> 
                      to fire an event at the <a>cache host</a> with
                      the name <code><a href="#event-updating">updating</a></code>, 
                      which does not bubble, is not cancelable, and which uses the
                      <a><code>CacheEvent</code></a> 
                      interface.
                    </li>
                  </ol>
                </dd>
              </dl></li>
              <li>
                Set <var>transaction</var>'s <a>commit status</a> to
                <var>pending</var>.
              </li>
              <li>
                Return <var>transaction</var>.
              </li>
            </ol>
          </section>
          
          <section class="section" id="adding-capture-transaction">
            <h4>Capturing resources</h4>
            
            <p>
              When the user agent is required to <dfn>add a resource to be <a>captured</a></dfn>, 
              given the URI of the resource to <a title="captured">capture</a>, a <a>cache host</a>, 
              a <a>cache transaction</a>, optionally a list of <a>dynamic methods</a>, 
              optionally content to serve as the <a>static</a> representation of 
              the resource, and optionally content type for the representation, 
              the user agent must perform the following steps:
            </p>
            
            <ol>
              <li>
                Let <var>transaction</var> be the <a>cache transaction</a>
                passed to these steps.
              </li>
              
              <li>
                If <var>transaction</var>'s <a>commit status</a> is not
                <var>pending</var>, then raise an exception and abort these steps.
              </li>
              
              <li>
                Pick the appropriate sub-steps:
                <dl class="switch">
                  <dt>If the <a>cache host</a> 
                  passed to these steps is a <code>Window</code> object</dt> 
                  <dd>
                    Let <var>base URI</var> be the location 
                    of the <a>active document</a> of the <a>browsing context</a> 
                    of that <code>Window</code> object.
                  </dd>
                  
                  <dt>If the <a>cache host</a> passed to these steps is a 
                  <code>WorkerUtils</code> object</dt>
                  <dd>  
                    Let <var>base URI</var> be the location of the worker.
                  </dd>
                </dl>
              </li>
              
              <li>
                Resolve the URI passed to these steps relative to <var>base URI</var>. 
              </li>
              
              <li>
                If the resulting absolute URI has a different &lt;scheme&gt; component 
                than the base URI (compared in an ASCII case-insensitive manner), then
                throw an exception and abort these steps.
              </li>
              
              <li>
                If the resulting absolute URI does not have the same <a>origin</a>
                as <var>base URI</var>, then throw an exception and abort these steps.
              </li>
              
              <li>
                Drop the &lt;fragment&gt; component of the resulting absolute URI, if it has one.
              </li>
              
              <li>
                Let <var>cache</var> be <var>transaction</var>'s <a>data cache</a>.
              </li>
              
              <li>
                If the resulting absolute URI identifies a <a>managed</a> resource that
                is already in <var>cache</var>, then remove that <a>managed</a> 
                resource from <var>cache</var>.
              </li>
              
              <li>
                Pick the appropriate sub-steps: <dl class="switch">
                <dt>
                  If <var>transaction</var> is not marked as 
                  <a title="off-line transaction">off-line</a>
                </dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>cache group</var> be the <a>data cache group</a>
                      containing <var>cache</var>.
                    </li>
                    <li>
                      For each <a>cache host</a> associated with a
                      <a>data cache</a> in <var>cache group</var>, 
                      <a>queue a task</a> to fire an event with
                      the name <code><a href="#event-fetching">fetching</a></code>, 
                      which does not bubble, is not cancelable, and which uses the
                      <a><code>CacheEvent</code></a> interface at the <a>cache host</a>.
                    </li>
                    <li>
                      <a title="fetch">Fetch</a> the representation of the resource identified by the
                      absolute URI. Use the <var>transaction</var>'s <a>data cache</a> as an
                      HTTP cache, and honor HTTP caching semantics (such as expiration, 
                      ETags, and so forth) with respect to that cache. User agents may also
                      have other caches in place that are also honored.
                      
                      <p class="note">
                        If the resource in question is already being <a title="fetch">fetched</a>
                        for other reasons, then the existing download process can
                        sometimes be used for the purposes of this step.
                      </p>
                    </li>
                    
                    <li>
                      If the previous step fails (e.g. the server returns a 4xx
                      or 5xx response or equivalent, or there is a DNS error, or
                      the connection times out, or the user cancels the download),
                      or if the server returned a redirect, then run the
                      <a>capture failure</a> steps.
                      <p class="note">
                        Redirects are fatal because they are either indicative of
                        a network problem (e.g. a captive portal); or would allow
                        resources to be added to the cache under URIs that differ
                        from any URI that the networking model will allow access
                        to, leaving orphan entries; or would allow resources to
                        be stored under URIs different than their true URIs. All
                        of these situations are bad.
                      </p>
                    </li>
                    
                    <li>
                      Otherwise, the <a title="fetch">fetching</a> succeeded. Store in <var>cache</var> a 
                      <a>managed</a> resource comprising the resulting absolute URI,
                      its <a title="fetch">fetched</a> representation, and the list of 
                      <a>dynamic methods</a> passed to these steps. 
                    </li>
                    
                    <li>
                      For each <a>cache host</a> associated with a
                      <a>data cache</a> in <var>cache
                      group</var>, <a>queue a task</a> to fire an event
                      at the <a>cache host</a> with
                      the name <code><a href="#event-captured">captured</a></code>, 
                      which does not bubble, is not cancelable, and which uses the
                      <a><code>CacheEvent</code></a> 
                      interface.                      
                    </li>
                  </ol>
                </dd>
                <dt>
                  If <var>transaction</var> is marked as
                  <a title="transaction-off-line">off-line</a>.
                </dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>representation</var> be the content passed
                      to these steps.
                    </li>
                    <li>
                      Let <var>type</var> be the content type passed to these steps.
                    </li>
                    <li>
                      If <var>type</var> is empty or null, set it to <code>text/plain</code>.
                    </li>
                    <li>
                      Store in <var>cache</var> a <a>managed</a> resource comprising
                      the resulting absolute URI, <var>representation</var>, and the list of
                      <a>dynamic methods</a> passed to these
                      steps.                       
                    </li>
                    <li>
                      For each <a>cache host</a> associated with a <a>data cache</a>
                      in <var>cache group</var>, <a>queue a task</a> to fire an event
                      at the <a>cache host</a> with
                      the name <code><a href="#event-captured">captured</a></code>, 
                      which does not bubble, is not cancelable, and which uses the
                      <a><code>CacheEvent</code></a> 
                      interface.                      
                    </li>
                  </ol>
                </dd>
              </dl></li>            
            </ol>
            
            <p>
              The <dfn>capture failure steps</dfn> are as follows:
            </p>
            
            <ol>
              <li>Discard <var>cache</var>.</li>
              <li>
                Set <var>cache group</var>'s <a>update status</a>
                to <var>idle</var>.
              </li>
              <li>Pick the appropriate sub-steps:              
                <dl class="switch">
                  <dt>If the failure was not caused by a 401 response, then</dt>
                  <dd><ol>
                    <li>
                      For each <a>cache host</a> associated with a <a>data cache</a> 
                      in <var>cache group</var>, <a>queue a task</a> to fire an event
                      at the <a>cache host</a> with
                      the name <code><a href="#event-error">error</a></code>, 
                      which does not bubble, is not cancelable, and which uses the
                      <a><code>CacheEvent</code></a> 
                      interface.                      
                    </li>
                  </ol></dd>
                  <dt>If the failure was caused by a 401 response, then</dt>
                  <dd><ol>
                    <li>
                      Mark <var>cache group</var> as <a>obsolete</a>.
                    </li>
                    <li>
                      For each <a>cache host</a> associated with a
                      <a>data cache</a> in <var>cache
                      group</var>, <a>queue a task</a> to fire an event
                      at the <a>cache host</a> with
                      the name <code><a href="#event-obsolete">obsolete</a></code>, 
                      which does not bubble, is not cancelable, and which uses the
                      <a><code>CacheEvent</code></a> 
                      interface.
                    </li>
                  </ol></dd>
                </dl>
              </li>
              <li>
                Mark <var>transaction</var>'s <a>commit status</a>
                as <var>aborted</var>.
              </li>
            </ol>
            
            <p>
              Attempts to <a>fetch</a> resources as part of the steps to 
              <a>add a resource to be captured</a>
              may be done with cache-defeating semantics, to avoid problems with
              stale or inconsistent intermediary caches.
            </p>
          </section>
          
          <section class="section" id="release-resource">
            <h4>Releasing resources</h4>
            
            <p>
              When the user agent is required to 
              <dfn>add a resource to be <a>released</a></dfn>, given the URI of the resource to
              <a title="released">release</a>, a <a>cache host</a>, and
              a <a>cache transaction</a>, 
              the user agent must perform the following steps:
            </p>
            
            <ol>
              <li>
                Let <var>transaction</var> be the <a>cache transaction</a>
                passed to these steps.
              </li>
              
              <li>
                If <var>transaction</var>'s <a>commit status</a> is not
                <var>pending</var>, then raise an exception and abort these steps.
              </li>
              
              <li>
                Pick the appropriate sub-steps:
                <dl class="switch">
                  <dt>If the <a>cache host</a> 
                  passed to these steps is a <code>Window</code> object</dt> 
                  <dd>
                    Let <var>base URI</var> be the location 
                    of the <a>active document</a> of the <a>browsing
                    context</a> of that <code>Window</code> object.
                  </dd>
                  
                  <dt>If the <a>cache host</a>
                  passed to these steps is a <code>WorkerUtils</code> object</dt>
                  <dd>  
                    Let <va>base URI</var> be the location of the worker.
                  </dd>
                </dl>
              </li>
              
              <li>
                Resolve the URI passed to these steps relative to <var>base URI</var>. 
              </li>
              
              <li>
                If the resulting absolute URI has a different &lt;scheme&gt; component 
                than the base URI (compared in an ASCII case-insensitive manner), then
                throw an exception and abort these steps.
              </li>
              
              <li>
                If the resulting absolute URI does not have the same <a>origin</a>
                as <var>base URI</var>, then throw an exception and abort these steps.
              </li>
              
              <li>
                Drop the &lt;fragment&gt; component of the resulting absolute URI, if it has one.
              </li>
              
              <li>
                Let <var>cache</var> be <var>transaction</var>'s 
                <a>data cache</a>.
              </li>
              
              <li>
                If the resulting absolute URI does not identify a <a>managed</a> 
                resource that is already in <var>cache</var>, then raise
                an exception and abort these steps.
              </li>
              
              <li>
                Remove the <a>managed</a> 
                resource for the resulting absolute URI from <var>cache</var>.
              </li>
              
              <li>
                For each <a>cache host</a> associated with a <a>data cache</a>
                in <var>cache group</var>, <a>queue a task</a> to fire an event
                at the <a>cache host</a> with
                the name <code><a href="#event-released">released</a></code>,
                which does not bubble, is not cancelable, and which uses the
                <a><code>CacheEvent</code></a> interface.                      
              </li>
            </ol>
          </section>
          
          <section class="section" id="complete-transaction"> 
            <h4>Completing a transaction</h4>
            
            <p>
              When the user agent is required to  
              <dfn>commit a cache transaction</dfn>, 
              given a <a>cache transaction</a>, 
              and a <a>cache host</a>,
              it means that the user agent must run the following steps:
            </p>
            
            <ol>
              <li>
                Let <var>transaction</var> be the 
                <a>cache transaction</a> passed to these steps.
              </li>

              <li>
                If <var>transaction</var>'s <a>commit status</a> is not
                <var>pending</var>, then raise an exception and abort these steps.
              </li>
              
              <li>
                Let <var>cache</var> be <var>transaction</var>'s 
                <a>data cache</a>.
              </li>
              
              <li>
                Let <var>cache group</var> be the <a>data cache group</a>
                containing <var>cache</var>.
              </li>

              <li>
                Atomically, so as to avoid race conditions, perform the following
                sub-steps:
                <ol>
                  <li>
                    Let <var>cache group version</var> be the <a>version</a> of the 
                    <a>relevant data cache</a> of <var>cache group</var>.
                  </li>
                  <li>
                    Set <var>cache</var>'s <a>version</a>
                    to be higher than <var>cache group version</var>.
                  </li>
                  <li>
                    Set the <var>cache</var>'s <a>completeness flag</a> to 
                    <var>complete</var>.
                  </li>                    
                  <li>Obtain the <a>storage mutex</a></li>.
                  <li>
                    If the host sets cookies in response to such a request, 
                    the user agent should update its cookie store accordingly. 
                  </li>
                  <li>Release the <a>storage mutex</a>.</li>
                </ol>
              </li>
              <li>
                Pick the appropriate sub-steps:
                <dl class="switch">
                  <dt>
                    If <var>transaction</var> is not marked as
                    <a href="#transaction-off-line" class="dfnref">off-line</a>,
                  </dt>
                  <dd>
                    <ol>  
                      <li>
                        Set the <a>update status</a> of <var>cache group</var> 
                        to <var>idle</var>.
                      </li>
                    </ol>
                  </dd>
                  <dt>
                    If <var>transaction</var> is marked as
                    <a href="#transaction-off-line" class="dfnref">off-line</a>
                  </dt>
                  <dd>
                    <ol>  
                      <li>
                        Make <var>cache</var> the <a>effective data cache</a> for 
                        <var>cache group</var> to the <a>cache host</a>
                        passed to these steps.
                      </li>
                    </ol>
                  </dd>
                </dl>
              </li>
              <li>
                For each <a>cache host</a> associated with a
                <a>data cache</a> in <var>cache group</var>, except for the
                <a>cache host</a> passed to 
                these steps, <a>queue a task</a> to fire an event
                at the <a>cache host</a> with
                the name <code><a href="#event-ready">ready</a></code>,
                which does not bubble, is not cancelable, and which uses the
                <a><code>CacheEvent</code></a> 
                interface.                      
              </li>
            </ol>
          </section>           
          
          <section class="section" id="abort-transaction"> 
            <h4>Aborting a transaction</h4>
            
            <p>
              When the user agent is required to  
              <dfn>abort a cache transaction</dfn>, 
              given a <a>cache transaction</a>, 
              and a <a>cache host</a>,
              it means that the user agent must run the following steps:
            </p>
            
            <ol>
              <li>
                Let <var>transaction</var> be the <a>cache transaction</a>
                passed to these steps.
              </li>

              <li>
                If <var>transaction</var>'s <a>commit status</a> is not
                <var>pending</var>, then raise an exception and abort these steps.
              </li>
              
              <li>
                Discard <var>transaction</var>'s <a>data cache</a>.
              </li>
              
              <li>
                Set <var>transaction</var>'s <a>commit status</a> as 
                <var>aborted</var>.
              </li>
              <li>
                For each <a>cache host</a> associated with a <a>data cache</a>
                in <var>cache group</var>, <a>queue a task</a> to fire an event
                at the <a>cache host</a> with
                the name <code><a href="#event-error">error</a></code>,
                which does not bubble, is not cancelable, and which uses the
                <a><code>CacheEvent</code></a> 
                interface.                      
              </li>
            </ol>
          </section>
          
          <section class="section" id="activating-updates">
            <h4>Activating updates</h4>
          
            <p>
              Once a <a>cache host</a> picks an <a>effective data cache</a>
              in a <a>data cache group</a>,
              an application script can use its representations. However, once update
              transactions are completed on that <a>data cache group</a>, the
              <a>effective data cache</a> is no longer the <a>relevant data cache</a>.
            </p>
            
            <p>
              When a user agent is required to <dfn>activate updates</dfn> for a given 
              <a>data cache group</a> and a <a>cache host</a>, the user agent
              must run the steps below:
            </p>
            
            <ol>
              <li>
                Let <var>cache</var> be the <a>relevant data cache</a>
                for the <a>data cache group</a> passed to these steps.
              </li>
              
              <li>
                If <var>cache</var> is the same as the <a>effective data cache</a>
                for the <a>data cache group</a> in the <a>cache host</a> passed
                to these steps, then terminate these steps.
              </li>
              
              <li>
                Set <var>cache</var> to be the 
                <a>effective data cache</a> for the <a>data cache group</a>
                to the <a>cache host</a> passed to these steps.
              </li>
            </ol>
          </section>
        
          <section class="section" id="expiring-application-caches">
            <h4>Expiring <a>data cache</a>s</h4>
            
            <p>
              As a general rule, user agents should not expire <a>data cache</a>s, 
              except on request from the user, or after having been left
              unused for an extended period of time.
            </p>
            <p>
              Implementors are encouraged to expose <a>data cache</a>s in a
              manner related to HTTP cookies, allowing <a>data cache</a>s to be expired
              together with cookies and other origin-specific data. <a title="data caches">Data
              caches</a> and cookies have similar implications with respect to privacy
              (e.g. if the site can identify the user when providing the cache, it
              can store data in the cache that can be used for cookie
              resurrection).
            </p>
          </section>
    
          <section class="section" id="datacache-api">
            <h4>The <code>DataCache</code> Interfaces</h4>
            <div class="example">  
              <p>
                Here's how a shared worker opens an <a>unsecure data cache group</a>. 
                Representations cached in <a>unsecure data cache group</a>s are 
                available regardless of authorization.
              </p>
              <codeblock>var cache = self.openDataCacheSync();</codeblock>
              <p>
                If an application were to use a cookie named 'SSID' to secure access to
                <a>private</a> resources, then it would need to use a 
                <a>secure data cache group</a> for accessing those resources <a>off-line</a>. 
                <!--A secure cache based on the 'SSID' cookie would record 
                that cookie's value when the cache is first opened. This cookie is also
                used when capturing representations. When an application accesses representations
                from the secure cache, the current value of the 'SSID' cookie is compared
                with the one recorded in the secure cache. Only if there is a match,
                would the cached representation be served.-->
              </p>
              <codeblock>var cache = window.openDataCache('SSID');</codeblock>
            </div>
            <dl class="idl" title="[Supplemental] interface CacheUtil">
              <dt>DataCache openDataCache()</dt>
              <dd>
                (In a window) Returns a <a><code>DataCache</code></a> object 
                that represents the <a>data cache</a> obtained from the steps to 
                <a>open a data cache</a> using <code>window</code> as the 
                <a>cache host</a> and <var>cookieName</var> as the name of an
                <a>authorization cookie</a>.
                <dl class="parameters">
                  <dt>optional DOMString cookieName</dt>
                  <dd></dd>
                </dl>
              </dd>
            </dl>
  
            <p class="idl" title="Window implements CacheUtil"></p>
  
            <dl class="idl" title="[Supplemental] interface CacheUtilSync">
               <dt>DataCache openDataCacheSync()</dt>
              <dd>
                (In a shared worker) Returns a <a><code>DataCacheSync</code></a> object 
                that represents the <a>data cache</a> obtained from the steps to
                <a>open a data cache</a> using <code>worker</code> 
                as the <a>cache host</a> and <var>cookieName</var>
                as the name of an <a>authorization cookie</a>.
               <dl class="parameters">
                  <dt>optional DOMString cookieName</dt>
                  <dd></dd>
                </dl>
              </dd>
            </dl>
          </section>
        
          <section id="async-datacache-interface" class="section">
            <h4>Asynchronous Data Cache API</h4>
  
            <dl class="idl"title="interface DataCache">
              <dt>const unsigned short IDLE = 0</dt>
              <dd>
                This <a><code>DataCache</code></a> object's
                <a>cache host</a> is associated with a <a>data cache</a> whose
                <a>data cache group</a>'s <a>update status</a>
                is <var>idle</var> and that <a>data cache</a> is the 
                <a title="newer">newest</a> cache in its <a>data cache group</a>, 
                and the <a>data cache group</a> is not marked <a>obsolete</a>.
              </dd>
              <dt>const unsigned short READY = 1</dt>
              <dd>
                This <a><code>DataCache</code></a> object's
                <a>cache host</a> is associated with a <a>data cache</a> whose
                <a>data cache group</a>'s <a>update status</a> is <var>idle</var>, 
                and whose <a>data cache group</a> is not marked as
                <a>obsolete</a>, but that <a>data cache</a> is not the 
                <a title="newer">newest</a> cache in its <a>data cache group</a>.
              </dd>
              <dt>const unsigned short OBSOLETE = 2</dt>
              <dd>
                This <a><code>DataCache</code></a> object's <a>cache host</a> 
                is associated with a <a>data cache</a> whose <a>data cache group</a>
                is marked as <a>obsolete</a>.
              </dd>
              <dt>readonly attribute long version</dt>
              <dd>
                This attribute, on getting, must return the 
                <a>version</a> of the <a>data cache</a> of this
                <a><code>DataCache</code></a> object.
              </dd>
              <dt>readonly attribute DOMString requiredCookie</dt>
              <dd>
                This attribute, on getting, must return the name of the
                <a>authorization cookie</a> of the <a>data cache group</a> of this 
                <a><code>DataCache</code></a> object.
              </dd>
              <dt>readonly attribute unsigned short status</dt>
              <dd>
                This attribute, on getting, must return the current state of the 
                <a>data cache</a> of this <a><code>DataCache</code></a> object. 
              </dd>
              <dt>void immediate()</dt>
              <dd>
                When this method is called, the user agent creates a new 
                <a>cache transaction</a>, and performs the steps to 
                <a>add a resource to be captured</a> in that <a>cache transaction</a>, 
                and when the identified resource is <a title="capture">captured</a>,
                performs the steps to <a>activate updates</a> for this 
                <a>data cache group</a>.
                <dl class="parameters">
                  <dt>DOMString uri</dt>
                  <dd>identifying the resource to <a>capture</a></dd>
                  <dt>optional DOMString dynamicMethods</dt>
                  <dd>
                    The <a>dynamic methods</a> that are applicable to the identified 
                    resource. This parameter is a comma separated list of protocol 
                    methods that can be intercepted for local processing. An empty 
                    string is allowed for this parameter.
                  </dd>
                </dl>              
              </dd>
              <dt>void transaction()</dt>
              <dd>
                When called, this method must immediately return and asynchronously
                perform the following steps:
                <ol>
                  <li>
                    Execute the steps to <a class="dfnref" href="#cache-transaction-create">
                    create a cache transaction</a> with the first argument being the
                    <a>data cache group</a> of this <a><code>DataCache</code></a> 
                    object and the second argument being <code>false</code>.
                  </li>
                  <li>
                    Let <var>result</var> be a new <a><code>CacheTransaction</code></a>
                    object for the <var>transaction</var> returned from the previous step.
                  </li>
                  <li>
                    If <var>transaction callback</var> is not null, 
                    <a>queue a task</a> to invoke the <var>transaction callback</var>
                    with the aforementioned <a><code>CacheTransaction</code></a>
                    object as its only argument, and wait for that task to be run. 
                  </li>
                  <li>
                    If <var>transaction callback</var> raised an exception, jump to 
                    the last step. 
                  </li>
                  <li>
                    End these steps. The next step is only used when something goes wrong. 
                  </li>
                  <li>
                    <a>queue a task</a> to invoke the <var>error callback</var>, 
                    if it is not null. 
                  </li>
                </ol>
                <dl class="parameters">
                  <dt>TransactionCallback callback</dt>
                  <dd>The function to invoke when the <a>cache transaction</a> is
                  created</dd>
                  <dt>optional VoidCallback errorCallback</dt>
                  <dd>The function to invoke if the <a>cache transaction</a> cannot
                  be created</dd>
                </dl>
              </dd>
              <dt>void offlineTransaction()</dt>
              <dd>
                This method takes one or two arguments - a <var>transaction 
                callback</var> and optionally an <var>error callback</var>.
                When called, this method must immediately return and asynchronously
                perform the following steps:
                <ol>
                  <li>
                    Execute the steps to <a class="dfnref" href="#cache-transaction-create">
                    create a cache transaction</a> with the first argument being the
                    <a>data cache group</a> of this <a><code>DataCache</code></a> 
                    object and the second argument being <code>true</code>.
                  </li>
                  <li>
                    Let <var>result</var> be a new <a><code>CacheTransaction</code></a>
                    object for the <var>transaction</var> returned from the previous step.
                  </li>
                  <li>
                    If <var>transaction callback</var> is not null, 
                    <a>queue a task</a> to invoke the <var>transaction callback</var>
                    with the aforementioned <a><code>CacheTransaction</code></a>
                    object as its only argument, and wait for that task to be run. 
                  </li>
                  <li>
                    If <var>transaction callback</var> raised an exception, jump to 
                    the last step. 
                  </li>
                  <li>
                    End these steps. The next step is only used when something goes wrong. 
                  </li>
                  <li>
                    <a>queue a task</a> to invoke the <var>error callback</var>, 
                    if it is not null. 
                  </li>
                </ol>
                <dl class="parameters">
                  <dt>TransactionCallback callback</dt>
                  <dd></dd>
                  <dt>optional VoidCallback errorCallback</dt>
                  <dd></dd>
                </dl>
              </dd>
              <dt>void swapCache()</dt>
              <dd>
                Perform the steps to <a>activate updates</a> with the
                <a>data cache group</a> of this <a><code>DataCache</code></a> object.
              </dd>
              <dt>void eachModificationSince()</dt>
              <dd>
                 <dl class="parameters">
                  <dt>long version</dt>
                  <dd></dd>
                  <dt>ItemCallback callback</dt>
                  <dd></dd>
                  <dt>optional VoidCallback successCallback</dt>
                  <dd></dd>
                </dl>
                This method takes one to three parameters - <var>low watermark version</var> and
                <var>item callback</var>, and an optional <var> success callback</var>. When
                called, this method must immediately return and asynchronously perform the
                following steps:
                <ol>
                  <li>
                    Let <var>additions</var> be a list of entities with their URIs and 
                    let <var>removals</var> be a list of URIs.
                  </li>
                  <li>
                    Let <var>cache</var> be the <a>data cache</a> represented by this 
                    <a><code>DataCache</code></a> object.
                  </li>
                  <li>
                    For each <a>data cache</a> belonging to <var>cache</var>'s 
                    <a>data cache group</a>, starting from <var>cache</var>'s 
                    <a>version</a> down to <var>low watermark version</var>, 
                    perform the following sub-steps:
                    <ol>
                      <li>
                        Let <var>old cache</var> be the <a>data cache</a>.
                      </li>
                      <li>
                        Let <var>old version</var> be <var>old cache</var>'s <a>version</a>.
                      </li>
                      <li>
                        For the entity <var>entity</var> of each <a>managed</a> resource of 
                        <var>old cache</var> that was added in the <var>old version</var>, perform
                        the following steps:
                        <ol>
                          <li>
                            Let <var>id</var> be the URI of the <a>managed</a> resource.
                          </li>
                          <li>
                            If neither <var>additions</var> nor <var>removals</var>
                            already includes <var>id</var>, then add <var>id</var>
                            with <var>entity</var> to <var>additions</var>.
                          </li>
                        </ol>
                      </li>
                      <li>
                        For each <a>managed</a> resource of <var>old cache</var> that was
                        removed in the <var>old version</var>, perform the following steps:
                        <ol>
                          <li>
                            Let <var>id</var> be the URI of the <a>managed</a> resource.
                          </li>
                          <li>
                            If neither <var>additions</var> nor <var>removals</var>
                            already includes <var>id</var>, then add <var>id</var>
                            to <var>removals</var>.
                          </li>
                        </ol>
                      </li>   
                    </ol>
                  </li>
                  <li>
                    If <var>item callback</var> is not null, then for each item 
                    <var>item</var> in <var>additions</var>, perform the following steps:
                    <ol>
                      <li>
                        For each item <var>item</var> in <var>additions</var>,
                        <a>queue a task</a> to invoke the <var>item callback</var> 
                        with <var>item</var>.
                      </li>
                      <li>
                        For each item <var>item</var> in <var>removals</var>,
                        <a>queue a task</a> to invoke the <var>item callback</var> 
                        with <var>item</var>.
                      </li>
                    </ol>
                  </li>
                  <li>
                    If <var>success callback</var> is not null, then 
                    <a>queue a task</a> to invoke the <var>success callback</var>
                  </li>
                </ol>
              </dd>
            </dl> 

            <dl class="idl" title="[Callback=FunctionOnly, NoInterfaceObject] interface TransactionCallback">
              <dt> void callback(CacheTransaction txn)</dt>
              <dd>
              </dd>
            </dl>

            <dl class="idl" title="[Callback=FunctionOnly, NoInterfaceObject] interface VoidCallback">
              <dt> void callback()</dt>
              <dd>
              </dd>
            </dl>
          </section>
          
          <section id="sync-datacache-interface" class="section">
            <h4>Synchronous Data Cache API</h4>
  
            <dl class="idl" title="interface DataCacheSync : DataCache">
              <dt>OnlineTransaction transactionSync()</dt>
              <dd>
                <p>
                This method must perform the following steps:
              </p>
              <ol>
                <li>
                  Execute the steps to <a class="dfnref" href="#cache-transaction-create">
                  create a cache transaction</a> with the first argument being the
                  <a>data cache group</a> of this <a><code>DataCache</code></a> 
                  object and the second argument being false.
                </li>
                <li>
                  Let <var>result</var> be a new <a><code>CacheTransaction</code></a>
                  object for the <var>transaction</var> returned from the previous step.
                </li>
                <li>Return <var>result</var>.</li>
              </ol>
            </dd>
            </dl>
          </section>
          
          <section id="transaction-interface" class="section">
            <h4>Transaction API</h4>
  
            <dl class="idl" title="interface CacheTransaction">
              <dt>void getItem(in DOMString uri, ItemCallback callback)</dt>
              <dd>
                When called, this method must immediately return and
                asynchronously perform the following steps:
                <ol>
                  <li>
                    If the resource identified by <var>uri</var> does not exist in this 
                    <a><code>CacheTransaction</code></a> object's associated
                    <a>data cache</a>, then the method must raise the 
                    <code>NOT_FOUND_ERR</code> exception and terminate these steps.
                  </li>
                  <li>
                    Let <var>item</var> be the entity in this 
                    <a><code>CacheTransaction</code></a> object's associated
                    <a>data cache</a>.
                  </li>
                  <li>
                    Create <var>object</var>, a new <a><code>CacheItem</code></a> 
                    object with the associated <var>item</var>.
                  </li>
                  <li>
                    <a>queue a task</a> to invoke <var>item callback</var> with the
                    aforementioned <a><code>CacheItem</code></a> <var>object</var>
                    as its only argument.
                  </li>
                </ol>
                <dl class="parameters">
                  <dt>DOMString uri</dt>
                  <dd>identifying the resource</dd>
                  <dt>ItemCallback callback</dt>
                  <dd>Callback to invoke with the cached resource information</dd>
                </dl>
              </dd>
              <dt>void release(in DOMString uri)</dt>
              <dd>
                When called, this method must immediately return and asynchronously
                perform the steps to <a>add a resource to be released</a>
                with the first argument being <var>uri</var>, second being the current
                <code>window</code> or <code>worker</code> object,
                and the third being this <a><code>CacheTransaction</code></a> 
                object's associated <a>cache transaction</a>.
                <dl class="parameters">
                  <dt>DOMString uri</dt>
                  <dd>identifying the resource to release</dd>
                </dl>
              </dd>
              <dt>void commit()</dt>
              <dd>
                When called, this method must immediately return and asynchronously 
                perform the following steps:
                <ol>
                  <li>
                    Execute the steps to <a>commit a cache transaction</a> with the 
                    first argument being this <a><code>CacheTransaction</code></a>
                    object's associated <a>cache transaction</a>,              
                    and the second being the current <code>window</code> or 
                    <code>worker</code> object.
                  </li>
                  <li>
                    If <a href="#oncommitted" class="dfnref"><code>oncommitted</code></a>
                    attribute on this <a><code>CacheTransaction</code></a> object is not null, <a>queue a
                    task</a> to invoke the function identified by 
                    <a href="#oncommitted" class="dfnref"><code>oncommitted</code></a> .                    
                  </li>
                </ol>
              </dd>
              <dt>attribute Function oncommitted</dt>
              <dd>
                <p>
                  This attribute, on getting, must return the function to be invoked
                  when this <a><code>CacheTransaction</code></a> object has 
                  been committed.
                </p>
                <p>
                  This attribute, on setting, must store the function to be invoked
                  when this <a><code>CacheTransaction</code></a> object has
                  been committed.
                </p>
              </dd>
            </dl>
            
            <dl class="idl" title="interface OnlineTransaction : CacheTransaction">
              <dt>void capture()</dt>
              <dd>
                When called, this
                method must immediately return and asynchronously perform the steps 
                in the <a href="#cache-resource-capture" class="dfnref">resource
                capturing process</a> with the first argument being <var>uri</var>,
                second being the current <code>window</code> or <code>worker</code> object,
                the third being this <a><code>CacheTransaction</code></a> object's associated 
                <a>cache transaction</a>,
                the fourth being <var>dynamic methods</var>.
                <dl class="parameters">
                  <dt>DOMString uri</dt>
                  <dd>identifying the resource to <a>capture</a></dd>
                  <dt>optional DOMString dynamicMethods</dt>
                  <dd>
                    The <a>dynamic methods</a> that are applicable to the identified 
                    resource. This parameter is a comma separated list of protocol 
                    methods that can be intercepted for local processing. An empty 
                    string is allowed for this parameter.
                  </dd>
                </dl>
              </dd>
              <dt>void abort()</dt>
              <dd>
                When called, this method must immediately return and asynchronously 
                perform the steps to <a>abort a cache transaction</a> with the first argument 
                being this <a><code>CacheTransaction</code></a> object's associated 
                <a>cache transaction</a>, and the second being the
                <code>window</code> or <code>worker</code> object.
              </dd>
            </dl>

            <dl class="idl" title="interface OfflineTransaction : CacheTransaction">
              <dt>void capture()</dt>
              <dd> When called, this
                method must immediately return and asynchronously perform the steps 
                to <a>add a resource to be captured</a> with the first argument being <var>uri</var>,
                second being the current <code>window</code> or <code>worker</code> object,
                the third being this <a><code>CacheTransaction</code></a> object's 
                associated <a>cache transaction</a>, the fourth being 
                <var>dynamic methods</var>, the fifth being <var>entity body</var>, 
                and the sixth being <var>content type</var>.
                <dl class="parameters">
                  <dt>DOMString uri</dt>
                  <dd>identifying the resource to <a>capture</a></dd>
                  <dt>DOMString body</dt>
                  <dd>entity body for the resource</dd>
                  <dt>optional DOMString contentType</dt>
                  <dd>The MIME type of the entity body</dd>
                  <dt>optional DOMString dynamicMethods</dt>
                  <dd>
                    The <a>dynamic methods</a> that are applicable to the identified 
                    resource. This parameter is a comma separated list of protocol 
                    methods that can be intercepted for local processing. An empty 
                    string is allowed for this parameter.
                  </dd>
                </dl>
              </dd>
            </dl>

            <dl class="idl" title="[Callback=FunctionOnly, NoInterfaceObject] interface TransactionCallback">
              <dt> void callback(CacheItem item)</dt>
              <dd>
              </dd>
            </dl>

            <dl class="idl" title="interface CacheItem">
              <dt>const unsigned short UNCACHED = 0</dt>
              <dd>
                This <a><code>CacheItem</code></a> object is associated with a 
                <a>managed</a> resource
                which has been added for capturing but has not yet been cached. 
                There is no value available in <a href="#widl-CacheItem-body"><code>body</code></a>
                or <a href="#widl-CacheItem-headers"><code>headers</code></a>.
              </dd>
              <dt>const unsigned short FETCHING = 1</dt>
              <dd>
                This <a><code>CacheItem</code></a> object is associated with a 
                <a>managed</a> resource which is currently being fetched.
                There is no value available in 
                <a href="#widl-CacheItem-body"><code>body</code></a>
                or <a href="#widl-CacheItem-headers"><code>headers</code></a>.
              </dd>
              <dt>const unsigned short CACHED = 2</dt>
              <dd>
                This <a><code>CacheItem</code></a> object is associated with a 
                <a>managed</a> resource which has been cached.
              </dd>
              <dt>const unsigned short GONE = 3</dt>
              <dd>
                This <a><code>CacheItem</code></a> object is associated with a 
                <a>managed</a> resource which has been released. There is no 
                value available in 
                <a href="#widl-CacheItem-body"><code>body</code></a>, 
                <a href="#widl-CacheItem-headers"><code>headers</code></a>, or 
                <a href="#widl-CacheItem-dynamicMethods"><code>dynamicMethods</code></a>.
              </dd>
              <dt>readonly attribute unsigned short readyState</dt>
              <dd>
                This attribute, on getting, must return the current state of the 
                <a>managed</a> resource.
              </dd>
              <dt>readonly attribute <a><code>Blob</code></a> body</dt>
              <dd>
                This attribute, on getting, must return the entity body, if any, as a 
                <a title="Blob"><code>Blob</code></a> object, of the <a>managed</a> 
                resource associated with this <a><code>CacheItem</code></a> object.                 
              </dd>
              <dt>readonly attribute DOMStringList dynamicMethods</dt>
              <dd>
                This attribute, on getting, must return the list of protocol methods, 
                if any, of the <a>managed</a> resource associated with this 
                <a><code>CacheItem</code></a> object.              
              </dd>
              <dt>readonly attribute any headers</dt>
              <dd>
                This attribute, on getting, must return the headers as a native ordered
                dictionary data type from the <a>managed</a> resource associated 
                with this <a><code>CacheItem</code></a> object. In the ECMAScript 
                binding, this must be <code>Object</code>. Each header must have
                one property (or dictionary
                entry), with those properties enumerating in the order that the headers
                were recorded in the <a>managed</a> resource. Each property must
                have the name of the header and its value as recorded in the 
                <a>managed</a> resource.
              </dd>
            </dl>
          </section>          
          
          <section id="events-and-error" class="section">
            <h4>The <code>CacheEvent</code> Interface</h4>
            <p>
              The <a>task source</a> for this task is the <dfn>networking task source</dfn>.
            </p>
            
            <p>
              If the event being fired is 
              <a href="#event-fetching"><code>fetching</code></a>,
              <a href="#event-captured"><code>captured</code></a>, or
              <a href="#event-released"><code>released</code></a>, then the event must
              have its <a href="#widl-CacheEvent-uri"><code>uri</code></a> attribute set to the URI of the 
              affected <a>managed</a> resource.
            </p>
            
            <p>
              Otherwise, if the event being fired is 
              <a href="#event-off-line-updating"><code>off-line-updating</code></a>,
              <a href="#event-updating"><code>updating</code></a>, 
              <a href="#event-error"><code>error</code></a>, 
              <a href="#event-obsolete"><code>obsolete</code></a>, or
              <a href="#event-ready"><code>ready</code></a>, then the event must
              have its <a href="#widl-CacheEvent-uri"><code>uri</code></a> attribute set to null.
            </p>
            <dl class="idl" title="interface CacheEvent : Event">
              <dt>readonly attribute DataCache cache</dt>
              <dd>This attribute, on getting, must return a 
              <a><code>DataCache</code></a> object representing 
              the <a>data cache</a> on which this event
              is fired.
              </dd>
              <dt>readonly attribute DOMString uri</dt>
              <dd>This attribute, on getting, must return the URI of the 
              <a>managed resource</a> for which
              this event is fired.
              </dd>
              <dt>void initCacheEvent()</dt>
              <dd>These methods must initialize the event in a manner analogous to the
              similarly named methods in the DOM Events interfaces. 
              [[!DOM-LEVEL-3-EVENTS]]
                <dl class="parameters">
                  <dt>DataCache cache</dt>
                  <dd></dd>
                  <dt>DOMString uri</dt>
                  <dd></dd>
                </dl>
              </dd>
              <dt>void initCacheEventNS()</dt>
              <dd>These methods must initialize the event in a manner analogous to the
              similarly named methods in the DOM Events interfaces. 
              [[!DOM-LEVEL-3-EVENTS]]
                <dl class="parameters">
                  <dt>DOMString namespaceURI</dt>
                  <dd></dd>
                  <dt>DataCache cache</dt>
                  <dd></dd>
                  <dt>DOMString uri</dt>
                  <dd></dd>
                </dl>
              </dd>
            </dl>
          </section>
        </section>
  
        <section id="local-server" class="section">
          <h3>Embedded Local Server</h3>
          
          <p>
            An <a>embedded local server</a> is an application script that generates
            <a>dynamic</a> responses to resource requests without making those
            requests to the resource host.
          </p>
          
          <p>
            An <dfn>embedded local server</dfn> consists of an 
            <dfn>interceptor</dfn> function and zero or one <dfn>reviewer</dfn> function.
          </p>
          
          <p>
            An <a>embedded local server</a>
            serves requests to resources in its <dfn>interception namespace</dfn>.
          </p>
          
          <p>
            A <a>cache host</a> can be associated with
            zero or more <a>embedded local server</a>s.
          </p>
          
          <p>
            An resource request issued in a <a>cache host</a> can be an 
            <dfn>interceptible request</dfn> if the resource is in the 
            <a>interception namespace</a> of an <a>embedded local server</a>
            registered in the <a>browsing context</a> of the <a>cache host</a> 
            and the resource is a <a>dynamic entry</a> in the
            <a>effective data cache</a> of some <a>data cache group</a>
            associated with the <a>cache host</a> and the request method 
            is identified as one of the <a>dynamic entry</a>'s <a>dynamic methods</a> . 
          </p>
          
          <p>
            If an <a>embedded local server</a>
            can <a>intercept a resource request</a>, then it is called a 
            <dfn>candidate local server</dfn> for that request. 
          </p>
          
          <p>
            Multiple <a>embedded local servers</a> can be the <a>candidate local server</a>
            for a given resource request. If a user agent is to 
            <dfn>select an embedded local server</dfn> from a list of
            <a>candidate local server</a>s that can
            produce a <a>dynamic</a> representation of the requested resource, then the user agent
            must use the <a>embedded local server</a> that has the most specific 
            <a>interception namespace</a>.
          </p>
          <section id="request-interface" class="section">
            <h4>Local Server API</h4>     
          
            <dl class="idl" title="[Supplemental, NoInterfaceObject] interface NavigatorLocalServer">
              <dt>void registerOfflineHandler()</dt>
              <dd>
                <dl class="parameters">
                  <dt>DOMString namespace</dt>
                  <dd>identifying the <a>interception namespace</a> for this <a>embedded local server</a></dd>
                  <dt>InterceptHandler intercept</dt>
                  <dd>the <a>interceptor</a> function of this <a>embedded local server</a></dd>
                  <dt>ReviewHandler review</dt>
                  <dd>the <a>reviewer</a> function of this <a>embedded local server</a></dd>
                </dl>
                <p>
                  This method allows applications to register possible handlers for particular URI namespaces.
                  Upon being invoked, this method should create a new 
                  <a>embedded local server</a> called <var>server</var> with its <a>interceptor</a> 
                  function set to <var>intercept handler</var> and its 
                  <a>reviewer</a> function set to <var>review handler</var> 
                  and add <var>server</var> to the <a>cache host</a>.
                </p>                  
              </dd>
            </dl>

            <p class="idl" title="Navigator implements NavigatorLocalServer"></p>

            <dl class="idl" title="[Callback=FunctionOnly, NoInterfaceObject] interface InterceptHandler">
              <dt>void callback()</dt>
              <dd>
                <p>
                  The user agent must invoke the <a><code>InterceptHandler</code></a>,
                  with an <a><code>HttpRequest</code></a>
                  object <var>request</var> based on the application's resource request and an 
                  <a><code>MutableHttpResponse</code></a>
                  object <var>response</var>. When the <a href="#response-send">
                  <code>send()</code></a> method is invoked on <var>response</var>, the
                  user agent must respond to <var>request</var> with the headers, body, and
                  status specified in <var>response</var>.
                </p>
                <dl class="parameters">
                  <dt>HttpRequest request</dt>
                  <dd></dd>
                  <dt>MutableHttpResponse response</dt>
                  <dd></dd>
                </dl>
              </dd>
            </dl>

            <dl class="idl" title="[Callback=FunctionOnly, NoInterfaceObject] interface ReviewHandler">
              <dt>void callback()</dt>
              <dd>
                <p>
                  The user agent must invoke the <a><code>ReviewHandler</code></a>,
                  with an <a><code>HttpRequest</code></a>
                  object <var>request</var> based on the application's resource request and an 
                  <a><code>HttpResponse</code></a>
                  object <var>response</var> based on the host's response to that request. 
                </p>
                <dl class="parameters">
                  <dt>HttpRequest request</dt>
                  <dd></dd>
                  <dt>HttpResponse response</dt>
                  <dd></dd>
                </dl>
              </dd>
            </dl>

            <dl class="idl" title="interface HttpRequest">
              <dt>readonly attribute DOMString method</dt>
              <dd>
                This attribute, on getting, must return the HTTP method, 
                in upper-case characters, present on this 
                <a><code>HttpRequest</code></a> object.
              </dd>
              <dt>readonly attribute DOMString target</dt>
              <dd>
                This attribute, on getting, must return the URI of this 
                <a><code>HttpRequest</code></a> object.
              </dd>
              <dt>readonly attribute DOMString bodyText</dt>
              <dd>
                This attribute, on getting, must return the entity body of this 
                <a><code>HttpRequest</code></a>
                object, if the body has a <code>Content-Type</code> of either
                <code>text/*</code> or <code>application/xml</code>.
              </dd>
              <dt>readonly attribute any headers</dt>
              <dd>
                This attribute, on getting, must return the headers as a native ordered
                dictionary data type from this 
                <a><code>HttpRequest</code></a> object. 
                In the JavaScript binding, this must be 
                <code>Object</code>. Each header must have one property (or dictionary
                entry), with those properties enumerating in the order that the headers
                were present in the request. Each property must have the name of the
                header and its value as present in the request.
              </dd>
            </dl>

            <dl class="idl" title="interface MutableHttpResponse">
              <dt>void setStatus(in unsigned short code, in DOMString message)</dt>
              <dd>
                This method takes two arguments - <var>code</var> and <var>message</var>
                of the response status. Upon calling, this method must store the status
                with <var>code</var> and <var>message</var> in this 
                <a><code>MutableHttpResponse</code></a>
                object, replacing any previous values for both.
              </dd>
              <dt>void setResponseText(in DOMString text)</dt>
              <dd>
                This method takes a single arguments - <var>body</var> of the response entity.
                Upon calling, this method must store the entity <var>body</var> in this 
                <a><code>MutableHttpResponse</code></a>
                object, replacing any previous value.
              </dd>
              <dt>void setResponseHeader(in DOMString name, in DOMString value)</dt>
              <dd>
                This method takes two arguments - <var>name</var> and <var>value</var>  
                of a response header. Upon calling, this method must store the header
                with <var>name</var> and <var>value</var> in this 
                <a><code>MutableHttpResponse</code></a>
                object. If a value is already associated with this header, then
                this method must append <var>value</var> to it.
              </dd>
              <dt>void send()</dt>
              <dd>
                Upon calling, this method must dispatch this 
                <a><code>MutableHttpResponse</code></a>
                object. No further changes must be allowed to it. 
              </dd>
            </dl>

            <dl class="idl" title="interface HttpResponse">
              <dt>readonly attribute unsigned short statusCode</dt>
              <dd>
                This attribute, on getting, must return the status code of this 
                <a><code>HttpResponse</code></a> object.
              </dd>
              <dt>readonly attribute DOMString statusMessage</dt>
              <dd>
                This attribute, on getting, must return the status message of this 
                <a><code>HttpResponse</code></a> object.
              </dd>
              <dt>readonly attribute DOMString bodyText</dt>
              <dd>
                This attribute, on getting, must return the entity body of this 
                <a><code>HttpResponse</code></a> 
                object, if the body has a <code>Content-Type</code> of either
                <code>text/*</code> or <code>application/xml</code>.
              </dd>
              <dt>readonly attribute any headers</dt>
              <dd>
                This attribute, on getting, must return the headers as a native ordered
                dictionary data type from this 
                <a><code>HttpResponse</code></a> object. 
                In the JavaScript binding, this must be 
                <code>Object</code>. Each header must have one property (or dictionary
                entry), with those properties enumerating in the order that the headers
                were present in the response. Each property must have the name of the
                header and its value as present in the response.
              </dd>
            </dl>
          </section>
      
          <section class="section" id="networking-model-changes">
            <h4>Changes to the networking model</h4>
            
            <p>
              When a <a>cache host</a> is associated 
              with one or more <a>effective data cache</a>s, any and all loads
              for resources related to that <a>cache host</a> other than those for 
              <a>child browsing contexts</a> must go through the
              following steps instead of immediately invoking the mechanisms
              appropriate to that resource's scheme:
            </p>

            <ol>
              <li>
                Let <var>request</var> be the resource request for <a title="fetch">fetching</a> the resource.
              </li>
              <li>
                If <var>request</var> includes the HTTP header <code>X-Bypass-DataCache</code>
                and the value of that header is <code>true</code>, then <a>fetch</a> the resource
                normally, and abort these steps.
              </li>
              <li>
                Let <var>caches</var> be the set of all 
                <a>effective data cache</a>s for the <a>cache host</a>.
              </li>
              <li>
                Let <var>resource</var> be the resource to be <a title="fetch">fetched</a>.
              </li>
              <li>
                If <var>resource</var> is not <a>managed</a> in 
                <var>caches</var>, then <a>fetch</a> a representation of <var>resource</var> 
                normally and abort these steps.
              </li>
              <li>
                Perform the steps to <a>select a data cache</a> <var>cache</var> from <var>caches</var>.
              </li>
              <li>
                If <var>request</var> is using the HTTP <code>GET</code> mechanism
                and <var>resource</var> is not defined in <var>cache</var> with a 
                <a title="dynamic methods">dynamic <code>GET</code> 
                method</a>, then get the entity for <var>resource</var> from the cache
                (instead of fetching it), and abort these steps.
              </li>
              <li>
                If <var>request</var> is using the HTTP <code>HEAD</code> mechanism
                and <var>resource</var> is not defined in <var>cache</var> with a 
                <a title="dynamic methods">dynamic <code>HEAD</code> 
                method</a>, then get the entity headers for <var>resource</var> from the cache
                (instead of fetching it), and abort these steps.
              </li>
              <li>
                If <var>resource</var> is not defined in <var>cache</var> with the 
                <a title="dynamic methods">dynamic method</a> that
                <var>request</var> is using, then <a>fetch</a> a representation of 
                <var>resource</var> normally and abort these steps.
              </li>
              <li>
                Pick the appropriate steps:
                <dl class="switch">
                  <dt>If the user agent is off-line</dt>
                  <dd><ol>
                      <li>
                        Perform the steps to <a>select an embedded local server</a> 
                        <var>server</var> to produce an <a>off-line</a> response.
                      </li>
                      <li>
                        Create a new response object to hold the <a>dynamic</a> response to 
                        <var>request</var>.
                      </li>
                      <li>
                        Call the <a>interceptor</a> function of <var>server</var> passing
                        as arguments <var>request</var> and <var>response</var>.
                      </li>
                      <li>
                        Wait for the <a>interceptor</a> function to dispatch the <a>dynamic</a> response.
                      </li>
                      <li>
                        Handle <var>response</var> as the <a>dynamic</a> response, and abort
                        these steps.
                      </li>
                  </ol></dd>
                  <dt>If the user agent is online</dt>
                  <dd><ol>
                      <li>
                        Perform the steps to <a>select an embedded local server</a> 
                        <var>server</var> to review the online response.
                      </li>
                      <li>
                        <a title="fetch">Fetch</a> a representation of <var>resource</var> normally and call it
                        <var>response</var>. 
                      </li>
                      <li>
                        Call the <a>reviewer</a> function of <var>server</var> passing as
                        arguments <var>request</var> and <var>response</var>.
                      </li>
                      <li>
                        Handle <var>response</var> as the <a>dynamic</a> response, and abort
                        these steps.
                      </li>
                  </ol></dd>
                </dl>
              </li>
              <li>Fail the resource load.</li>
            </ol>
          </section>
        </section>
      </section>
      <section id="security" class="section">
        <h2>Security Considerations</h2>
        
        <p>
          Apart from requirements affecting security made throughout
          this specification implementations may, at their discretion,
          not expose certain headers, such as HttpOnly cookies. 
        </p>
  
        <p>
          Applications need to verify the identity of their users before
          allowing access to <a>private</a> resources they
          manage. Typically a host verifies the identity of its users by
          checking whether the user possesses valid credentials including a
          shared secret, e.g., a password. Applications design their own user
          interface to provide a means for users to supply their credentials
          for authentication. In Web applications, this is typically performed
          using HTML forms and it provides applications with a great deal of
          control over the authentication user interface. Also, applications
          typically do not verify the user's credentials for every request. 
          Instead, applications verify a token stored on the client as a result
          of authentication. This token is a session identifier often stored in
          an HTTP cookie [[!COOKIES]].
        </p>
        <p>
          This approach is highly scalable since just the session identifier
          and not credentials are validated for every HTTP request. Use of
          session identifiers gives the data source wide latitude over
          terminating the authorization and restricting access to certain
          scopes. It also allows users to share authorization but not their
          credentials with a variety of less-trustworthy applications.
        </p>
        
        <p>
          The token approach also enables off-line authentication without
          storing any credentials locally. The token produced by the host is
          used by user agents to authenticate requests served locally and for
          capturing resources from the host. If a <a>data cache</a> is to store
          <a>private</a> resources, it must be <a>created with a cookie name</a>. 
          Once such a <a>data cache</a> is created, the user agent must serve
          or intercept requests to its captured resources only if the cookie
          used to secure the cache is still present in the 
          <a>current browsing context</a>. 
        </p>
        <p>
          Failing this, the user agent must make the request to the host as
          would be the case if the resource were not captured locally. If the
          user agent receives an HTTP 401 status from a host while capturing a
          resource using a required cookie, then it must automatically destroy
          the <a>data cache</a> originating that capture attempt.
        </p>
      </section>
    </section>
      
    <section class="section appendix" id="acknowledgements">
      <h2>Acknowledgements</h2>
      <div>
        Thanks to Garret Swart, Colm Divilly, Ashish Motivala, Joseph Pecoraro, and Mike Wilson 
        for their useful comments that have led to improvements to this specification over time.
      </div>
    </section>
  </body>
</html>
