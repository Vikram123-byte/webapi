<?xml version='1.0'?>

<!--
  Overview.xml
  DataCache and HTTP Interceptor API

  This is written in XHTML 1.0 Strict with an inline <options> element that
  helps the WebIDL.xsl stylesheet process the document (generating a table
  of contents, section numbers, certain processing instructions).
  -->

<?xml-stylesheet href='TR.xsl' type='text/xsl'?>

<html xmlns='http://www.w3.org/1999/xhtml' xmlns:x='http://mcc.id.au/ns/local' xml:lang='en'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>DataCache and HTTP Interceptor API</title>
    <meta name='revision' content='$Id: Overview.xml,v 1.2 2009-07-15 22:33:46 nmehta3 Exp $'/>
    <link rel='stylesheet' href='DataCache.css' type='text/css'/>
    <script src='section-links.js' type='application/ecmascript'/>
    <script src='dfn.js' type='application/ecmascript'/>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->

    <options xmlns='http://mcc.id.au/ns/local'>
      <versions>
        <cvs href='http://dev.w3.org/2006/webapi/DataCache/'/>
        <this href='http://www.w3.org/TR/2009/WD-DataCache-2009XXXX/'/>
        <latest href='http://www.w3.org/TR/DataCache/'/>
        <!--previous href='http://www.w3.org/TR/2008/WD-DataCache-20081219/'/-->
      </versions>
      <editors>
        <person homepage='http://o-micron.blogspot.com/' email='nikunj.mehta@oracle.com'>
          <name>Nikunj R. Mehta</name>
          <affiliation>Oracle Corp</affiliation>
        </person>
      </editors>
      <maturity>ED</maturity>
    </options>
  </head>

  <body>
    <?top?>

    <div class='section'>
      <h2>Abstract</h2>
      <p>
        This document defines APIs for dynamically and statically serving
        off-line representations of HTTP resources.
      </p>

      <?revision-note?>
    </div>

    <div class='section'>
      <h2>Status of this Document</h2>
      <?sotd-top public-webapps@w3.org http://lists.w3.org/Archives/Public/public-webapps/ [DataCache]?>
      <p>
        This document is produced by the
        <a href='http://www.w3.org/2008/webapps/'>Web Applications Working Group</a>, part of the
        <a href='http://www.w3.org/2006/rwc/Activity'>Rich Web Clients Activity</a>
        in the W3C <a href='http://www.w3.org/Interaction/'>Interaction Domain</a>.
        Changes made to this document can be found in the
        <a href='http://dev.w3.org/cvsweb/2006/webapi/DataCache/Overview.xml'>W3C
          public CVS server</a>.
      </p>
      <?sotd-bottom http://www.w3.org/2004/01/pp-impl/42538/status?>
    </div>

    <div id='toc'>
      <h2>Table of Contents</h2>
      <?toc sections appendices?>
    </div>

    <div id='sections'>
      <div id='introduction' class='section'>
        <h2>Introduction</h2>

        <p class='norm'>This section is informative.</p>

        <p>
          Web applications often encounter seemingly random disconnections
          or network slowdowns, which deteriorates application responsiveness
          and availability, and, therefore, user experience. Special mobile 
          applications for specific mobile device platforms are developed in a 
          fat client-server architecture to work around these problems and are 
          used with special programs that synchronize data with the server.
        </p>
        <p>
          This specification provides constructs, called data caches and HTTP
          interceptors, for statically and dynamically served, off-line
          representations of resources, respectively. This specification provides
          a user agent solution to improve application availability and
          responsiveness by hoarding and subsequently supplying application data. 
        </p>
        
        <p>
          Data cache is a programmable HTTP cache that can be manipulated by
          a Web application to store and serve static off-line representations
          of resources. HTTP interceptor offers applications a way to produce
          dynamic off-line representations  of resources by intercepting HTTP
          requests, e.g., GET or PUT.
        </p>
        
        <p>
          Using these two constructs, applications can locally cache required data, 
          complete requests to HTTP resources whether or not the requests can be 
          serviced immediately by a remote server, and later replay locally 
          satisfied requests to the server. This enables responsive and robust
          Web applications in low connectivity conditions.
        </p>
        
        <p>
          As the constructs are transparently pressed into action by the user 
          agent, depending on system conditions, existing applications can be 
          used unchanged in environments that are not affected by network
          unreliability. New applications can be designed for improved
          responsiveness using constructs specified here. New applications
          seamlessly switch between on-line and off-line operation
          without needing explicit user action.
        </p>
      </div>

      <div id='conformance' class='section'>
        <h2>Conformance Requirements</h2>

        <p>
          Everything in this specification is normative except for diagrams,
          examples, notes and sections marked as being informative.
        </p>
        <p>
          The keywords “<span class='rfc2119'>MUST</span>”,
          “<span class='rfc2119'>MUST NOT</span>”,
          “<span class='rfc2119'>REQUIRED</span>”,
          “<span class='rfc2119'>SHALL</span>”,
          “<span class='rfc2119'>SHALL NOT</span>”,
          “<span class='rfc2119'>RECOMMENDED</span>”,
          “<span class='rfc2119'>MAY</span>” and
          “<span class='rfc2119'>OPTIONAL</span>” in this document are to be
          interpreted as described in
          <cite><a href='http://www.ietf.org/rfc/rfc2119'>Key words for use in RFCs to
              Indicate Requirement Levels</a></cite>
          <a href='#ref-RFC2119'>[RFC2119]</a>.
        </p>
        <p>
          This specification defines one class of products:
        </p>
        <dl>
          <dt><dfn id='dfn-conforming-user-agent'>Conforming user agent</dfn></dt>
          <dd>
            <p>
              A user agent must behave as described in this specification
              in order to be considered conformant.
            </p>
            
            <p>
              User agents may implement algorithms given in this
              specification in any way desired, so long as the end result is
              indistinguishable from the result that would be obtained by the
              specification's algorithms.
            </p>
            
            <p>
              A conforming DataCache user agent must also be a
              <em>conforming implementation</em> of the IDL fragments
              of this specification, as described in the
              “Web IDL” specification. <cite><a href='#ref-WebIDL'>[WEBIDL]</a></cite>
            </p>
            
            <div class="note">
              This specification uses both the terms "conforming user agent(s)" 
              and "user agent(s)" to refer to this product class.
            </div>
          </dd>
        </dl>
        
        <div id="dependencies" class="section">
          <h3>Dependencies</h3>
          
          <p>This specification relies on several underlying specifications.</p>
          <dl>
            <dt>HTTP</dt>
            <dd>
              <p>
                A <a href="#conforming-user-agent" title="conforming user agent">
                conforming user agent</a> must support some version of the
                HTTP protocol <cite><a href="#ref-RFC2616">[RFC2616]</a></cite>.
              </p>
            
              <p>
                In order to protect against attacks, the use of the following
                headers is prohibited using interfaces defined in this specification.
              </p>
            
              <ul>
               <li><code>Accept</code></li>
          
               <li><code>Accept-Charset</code></li>
          
               <li><code>Accept-Encoding</code></li>
          
               <li><code>Accept-Language</code></li>
          
               <li><code>Authorization</code></li>
          
               <li><code>Cache-Control</code></li>
          
               <li><code>Connection</code></li>
          
               <li><code>Content-Transfer-Encoding</code></li>
          
               <li><code>Cookie</code></li>
          
               <li><code>Date</code></li>
          
               <li><code>Expect</code></li>
          
               <li><code>Host</code></li>
          
               <li><code>Keep-Alive</code></li>
          
               <li><code>Origin</code></li>
          
               <li><code>Range</code></li>
          
               <li><code>Referer</code></li>
          
               <li><code>Set-Cookie</code></li>
          
               <li><code>TE</code></li>
          
               <li><code>Trailer</code></li>
          
               <li><code>Transfer-Encoding</code></li>
          
               <li><code>Upgrade</code></li>
          
               <li><code>User-Agent</code></li>
          
               <li><code>Via</code></li>
              </ul>
            </dd>
            <dt>HTTP State Management</dt>
            <dd>
              <p>
                A <a href="#conforming-user-agent" title="conforming user agent">
                conforming conforming user agent</a> must support storage and
                exchange of cookies as specified by HTTP State Management 
                <cite><a href="#ref-RFC2109">[RFC2109]</a></cite>.
              </p>
            </dd>
            <dt>DOM</dt>
            <dd>
              <p>
                A <a href="#conforming-user-agent" title="conforming user agent">
                conforming conforming user agent</a> must define the exception  
                codes defined in <cite><a href="#ref-DOM3Core">[DOM3Core]</a></cite> 
                and referenced in this specification.
              </p>
            </dd>
          </dl>
        </div>
	  </div>
	  
      <div id='terminology' class='section'>
        <h2>Terminology</h2>

        <p>
          A resource is <dfn id="capture">captured</dfn> when it is identified
          to a persistent data cache.
        </p>
        
        <p>
          A <dfn id="managed">managed resource</dfn> is one whose URL is captured.
        </p>
        
        <p>
          A <dfn id="static">static representation</dfn> is one that is generated 
          directly by the user agent from its internal storage.
        </p>
        
        <p>
          A <dfn id="dynamic">dynamic representation</dfn> is one that is generated 
          programmatically by using application-supplied logic.
        </p>		
        
        <p>
          <dfn id="offline">Transparent off-line data access and manipulation</dfn>  
          means to locally generate a <a class="dfnref" href="#static">static</a> 
          or a <a class="dfnref" href="#dynamic">dynamic</a> 
          response for HTTP requests to captured  resources.
        </p>
        <p>
          <dfn id="secure">Secure</dfn> resources are those that require explicit authorization.
        </p>
      </div>
            
      <div id="cache" class="section">
        <h2>DataCache and HTTP Interception</h2>
        <p>
          This specification provides APIs to applications for identifying
          <a class="dfnref" href="#capture">managed resources</a> to a user
          agent and to specify <a class="dfnref" href="#static">static</a> 
          and <a class="dfnref" href="#dynamic">dynamic</a> 
          representations for these resources. A user agent processes
          requests to <a class="dfnref" href="#capture">managed resources</a>
          in one of three ways: 
        </p>
        <ol>
          <li>
            <a class="dfnref" href="#intercept-policy">intercept</a> - 
            immediately invoke an interceptor program to obtain a 
            <a class="dfnref" href="#dynamic">dynamic representation</a>
          </li>
          <li>
            <a class="dfnref" href="#review-policy">review</a> - 
            relay the request to the server to obtain a 
            <a class="dfnref" href="#dynamic">dynamic representation</a> and 
            notify an interceptor program when that representation is available
          </li>
          <li>
            <a class="dfnref" href="#serve-policy">serve</a> - 
            respond with the <a class="dfnref" href="#static">static
            representation</a>  of the requested resource
          </li>
        </ol>
        
        <p>
          The <a class="dfnref" href="#serve-policy">serve policy</a> is only useful 
          for safe HTTP methods, i.e., <code>GET</code> and <code>HEAD</code> 
          on resources that do not require interception, whereas the 
          <a class="dfnref" href="#intercept-policy">intercept policy</a> 
          can be used for any HTTP method on resources that require interception. 
          Both policies improve availability and responsiveness. However, both 
          may affect data freshness. The 
          <a class="dfnref" href="#review-policy">review policy</a> can be used 
          for any unsafe HTTP method but can only be used when the user agent 
          is able to communicate over the network. This policy improves data freshness 
          at the cost of reduced responsiveness. User agents may choose 
          freely from among these options, e.g., using information about the system 
          condition, e.g., network state or battery power level, or a user preference.
        </p>

        <div id='http-cache' class='section'>
          <h3>Programmable HTTP Cache</h3>

		  <p>
			This specification enables a Web application to pre-fetch 
			representations of a set of programmatically determined 
			resources and later serve these representations statically in response 
			to requests to those resources. It removes the lack of 
		    predictability about the availability of cached resources.
  		  </p>

		  <div id="datacache-intro" class="section">
		    <h4>Introduction</h4>			
		    <div class="norm">This section is non-normative.</div>
				
			<p>
			  The standard HTTP caches built in to existing user agents 
			  are under no obligation to locally store a cacheable resource 
			  and do not provide any guarantees about off-line serving of 
			  HTTP resources. 
			</p>
		
			<p>
			  To address this limitation, this specification introduces 
			  the <a class="idltype" href="#DataCache"><code>DataCache</code></a> object. 
			  Web applications can <a href="#capture">capture</a> resources 
			  in to a <a class="idltype" href="#DataCache"><code>DataCache</code></a> object, 
			  which can then be served by the user agent when that resource 
			  is requested.
			</p>
		
			<div class="example">				
			  <p>
			    For example, an application can locally store a preference 
			    list fetched from its server in the following manner:
			  </p>
			  <x:codeblock language="es">var dataCache = ...
dataCache.capture('/app/layout.plist');</x:codeblock>
			  <p>
			    Later, when any page requests that preference list either 
			    through page navigation or an XMLHttpRequest 
			    <cite><a href="#ref-XMLHttpRequest">XMLHttpRequest</a></cite>, 
			    the user agent can serve it from that data cache:
			  </p>
			  <x:codeblock language="es">var req = new XMLHttpRequest;
req.open('GET', '/app/layout.plist');
req.onreadystatechange = ...
req.send();</x:codeblock>
		    </div>
			
		    <p>
		      An application can obtain a 
		      <a class="idltype" href="#DataCache"><code>DataCache</code></a> 
		      object from a <code>Window</code> or other similar object. An unsecure 
		      data cache cannot store <a class="dfnref" href="#secure">secure resources</a>.
		    </p>
		
			<div class="example">			
			  <p>
			    Here's how an application can open an unsecure data cache :
			  </p>
			  <x:codeblock language="es">var dataCache = window.openDataCache('example');</x:codeblock>
		    </div>

		    <p>
		      Applications may also use secure data caches for 
		      <a class="dfnref" href="#secure">secure resources</a>. 
		      Access is restricted by the presence of a previously identified
		      required cookie in the current browsing context. Applications
		      only identify the name of the required cookie, not its value,
		      at the time of opening the cache, whereupon the then current
		      value of the required cookie is recorded in the data cache and
		      used in all future attempts to open that data cache as well as
		      to serve requests for managed resources.
		    </p>
		
			<div class="example">
			  <p>
			    An application create a new secure data cache in the 
			    following manner:
			  </p>
			  <x:codeblock language="es">var dataCache = window.openDataCache('messages', 'SSID');</x:codeblock>
		
		    </div>
		
	      </div>
	      
	      <div id="datacache" class="section">
	      	<h4>Data caches</h4>
			<p>
			  Each data cache holds representations of a set of resources
			  identified by their URLs.
			</p>
		
			<p>
			  Each <i>origin</i> <cite><a href="#ref-HTML5">[HTML5]</a></cite> has an associated set of data caches. Each
			  data cache has a name and an optional authorization cookie used
			  to limit access to data in that cache. There is no way to
			  enumerate the data caches available for an <i>origin</i> from this
			  API or to find the cookie associated with an existing data cache.
			</p>
		
			<div>
			  <x:codeblock language="idl">[Supplemental] interface Window {
  <a href="#DataCache">DataCache</a> <a href="#openDataCache">openDataCache</a>(in DOMString name, [optional in] DOMString cookieName);
};

[Supplemental] interface WorkerUtils {
  <a href="#DataCache">DataCache</a> <a href="#openDataCache">openDataCache</a>(in DOMString name, [optional in] DOMString cookieName);
};</x:codeblock>  
            </div>
			<p>
			  The <dfn id="openDataCache"><code>openDataCache(name, cookieName)</code></dfn> 
			  method on the <code>Window</code> and <code>WorkerUtils</code> interfaces 
			  must return a new <code><a class="idltype" href="#DataCache">DataCache</a></code> object 
			  associated with either:
			</p>
		    <ul>
			  <li>
			    an existing data cache with the given <var>name</var> provided
			    that if the optional <var>cookieName</var> is specified, then
			    the cookie used in the existing data cache matches the named
			    cookie in the <i>current browsing context</i> <cite><a href="#ref-HTML5">[HTML5]</a></cite>, or
			  </li> 
			  <li>
			    a new data cache with the given <var>name</var> and if the optional
			    <var>cookieName</var> is specified, then the cookie from the 
			    <i>current browsing context</i> <cite><a href="#ref-HTML5">[HTML5]</a></cite>
			    for <var>cookieName</var>
			  </li> 
		    </ul>
		
		    <p>
		      If a new data cache is created due to a difference between the
		      required cookie of an existing data cache and the cookie present
		      in the current browsing context, then the existing data cache
		      must be destroyed automatically.
		    </p>
		
		    <p>
		      More than one data cache may <a class="dfnref" href="capture">capture</a> a resource. In 
		      such a case, the user agent must supply the most recent version
		      of that resource when responding to a request to retrieve the
		      representation of that resource.
		    </p>
		  </div>

	      <div id="datacache-interface" class="section">
	        <h4>The <a class="idltype" href="#DataCache"><code>DataCache</code></a> interface</h4>	
	        
		    <div>
			  <x:codeblock language="idl">interface <dfn id="DataCache">DataCache</dfn> { 
  // Actions
  void <a href="#datacache-capture">capture</a>(in DOMString name, [optional in] DOMString dynamicMethods, [optional in] <a href="#CaptureCallback">CaptureCallback</a> callback);
  void <a href="#datacache-captureText">captureText</a>(in DOMString name, in DOMString content, [optional in] DOMString contentType, [optional in] DOMString dynamicMethods, [optional in] <a href="#CaptureCallback">CaptureCallback</a> callback));
  void <a href="#datacache-destroy">destroy</a>();
  
  // Queries
  DOMString <a href="#datacache-getHeader">getHeader</a>(in DOMString url, in DOMString name);
  DOMString <a href="#datacache-getAllHeaders">getAllHeaders</a>(in DOMString url);
  DOMString <a href="#datacache-getText">getText</a>(in DOMString url);
  bool <a href="#datacache-isCaptured">isCaptured</a>(in DOMString relation);
  void <a href="#datacache-remove">remove</a>(in DOMString url);
};

[Callback=FunctionOnly, NoInterfaceObject]
interface <dfn id="CaptureCallback">CaptureCallback</dfn> {
  void handleEvent(in DOMString url, in bool success);
};</x:codeblock>
		    </div>

		    <p>
		      The representation of a resource identified by the <var>url</var> parameter
		      can be asynchronously <a class="dfnref" href="#capture">captured</a> in a data
		      cache in one of two ways <dfn id="datacache-capture"><code>capture(url, dynamicMethods, callback)</code></dfn>
		      and <dfn id="datacache-captureText"><code>captureText(url, body, contentType, dynamicMethods, callback)</code></dfn>.
		      In the first method the user agent asynchronously attempts to 
		      obtain the network representation of the identified resource. 
		      In the second method, the user agent asynchronously attempts to 
		      <a class="dfnref" href="#capture">capture</a> the contents of the <var>body</var>
		      parameter as the entity body of the representation. If the resource
		      exists in the data cache, then the user agent must replace the
		      previously <a class="dfnref" href="#capture">captured</a> representation only
		      if this <a class="dfnref" href="#capture">capture</a> attempt is successful.
		    </p>
		
			<p>
			  If <var>contentType</var> is specified in the 
			  <a class="idltype" href="#datacache-captureText"><code>captureText</code></a>
			  method, then the user agent must use that value for the <code>Content-Type</code>
			  header of the resource's entity. If no such parameter is present,
			  the user agent must interpret the content as <code>text/plain</code>.
			</p>
		
			<p>
			  For either <a class="idltype" href="#datacache-capture"><code>capture</code></a> or 
			  <a class="idltype" href="#datacache-captureText"><code>captureText</code></a> method, 
			  <var>dynamicMethods</var> may be optionally specified to enable 
			  programmatic interception and <a class="dfnref" href="#dynamic">dynamic representation</a>
			  generation. This parameter consists of a comma separated list of
			  HTTP methods that can be intercepted for local processing. An
			  empty string is allowed for this parameter. If the parameter uses
			  characters disallowed by the <code>Method</code> production of HTTP 
			  <cite><a href="#ref-RFC2616">[RFC2616]</a></cite>, then the method
			  must raise a <code>SYNTAX_ERR</code> exception. If the resource
			  identified by <var>url</var> exists in the data cache and  <var>dynamicMethods</var>
			  is not provided, then the user agent must retain the existing set of dynamic methods. </p>
		
			<p>
			  If a server keeps a stateful session with the client, it can track
			  the session using cookies <cite><a href="#ref-RFC2109">[RFC2109]</a></cite>. 
			  The user agent should send relevant cookies from its store to a server 
			  when <a class="dfnref" href="capture">capturing</a> a network 
			  representation of a resource. If a server sets cookies in response
			  to such a request, the user agent should update its cookie store accordingly. 
			 </p>
	
			<p>
			  When the <var>callback</var> parameter is specified, the user agent
			  must invoke it when the <a class="dfnref" href="#capture">capture</a> attempt is
			  completed, whether it is successful or if a network or storage error occurs.
			</p>
			
			<p>
			  The <dfn id="datacache-isCaptured"><code>isCaptured(url)</code></dfn> 
			  method must return true if the resource identified by the <var>url</var> 
			  has been <a class="dfnref" href="#capture">captured</a> and false otherwise.
			</p>
			
			<p>
			  The <dfn id="datacache-getHeader"><code>getHeader(url, name)</code></dfn> 
			  method must return the value of the header associated with the given 
			  <var>name</var> for the <a class="dfnref" href="#capture">captured</a> resource 
			  identified by the <var>url</var>. If the resource has not been 
			  <a class="dfnref" href="#capture">captured</a>, the method must raise 
			  the <code>INVALID_STATE_ERR</code> exception. If the resource does not
			  exist in the data cache object, then the method must raise the
			  <code>NOT_FOUND_ERR</code> exception.</p>
	
			<p>
			  The <dfn id="datacache-getAllHeaders"><code>getAllHeaders(url)</code></dfn>
			  method must return all the <a class="dfnref" href="#capture">captured</a>
			  headers for the resource identified by the <var>url</var>. Individual
			  headers must be separated in the returned string by a CRLF sequence.
			  If the resource has not been <a class="dfnref" href="#capture">captured</a>,
			  the method must raise the <code>INVALID_STATE_ERR</code> exception. If 
			  the resource does not exist in the data cache, then the method must
			  raise the <code>NOT_FOUND_ERR</code> exception.
			</p>
			
			<p>
			  The <dfn id="datacache-getText"><code>getText(url)</code></dfn> method
			  must return the entity body of the <a class="dfnref" href="#capture">captured</a>
			  representation for the resource identified by the <var>url</var>. If
			  the resource has not been <a class="dfnref" href="#capture">captured</a>, the method
			  must raise the <code>INVALID_STATE_ERR</code> exception. If the
			  resource does not exist in the data cache, then the method must raise
			  the <code>NOT_FOUND_ERR</code> exception. If the content-type of the
			  resource does not match <code>text/*</code>, <code>application/xml</code>,
			  or <code>application/*\+xml</code>
			  then the method must raise the <code>NOT_SUPPORTED_ERR</code> exception.
			</p>
			
			<p>
			  The <dfn id="datacache-remove"><code>remove(url)</code></dfn> method
			  must remove the <a class="dfnref" href="#capture">captured</a> resource identified by
			  the <var>url</var> from the data cache. If the resource does not exist
			  in the data cache, then the method must do nothing.
			</p>
			
			<p>
			  The <dfn id="datacache-destroy"><code>destroy()</code></dfn> method
			  must destroy the current data cache, cancel all its in-flight capture
			  attempts, and remove all its <a class="dfnref" href="#capture">captured</a> resources.
			  The user agent may delay the actual reclamation of storage used by
			  the data cache.
			</p>
			
			<p>
			  To invoke the <a class="idltype" href="#CaptureCallback"><code>CaptureCallback</code></a>
			  object, a user agent must provide the URL of the <a class="dfnref" href="#capture">captured</a>
			  resource as <var>url</var> and a boolean value <var>success</var>
			  indicating whether the capture attempt was successful.
			</p>

		    <div class="ednote">
		      <p>
		        It is also possible that representations of resources within 
		        a single data cache may not be consistent. For example, a 
		        captured resource may have a hyperlink to an uncaptured 
		        resource. Loss of network during periods of such inconsistency
		        would affect the availability of applications using such such
		        data even though user agents should be robust enough to survive
		        intermittent connectivity and restart capture attempts as soon as
		        connectivity is re-established.
		      </p>
		      
		      <p>
		        A versioning mechanism is required to support applications
		        with higher consistency requirements. This portion of the spec
		        is TBD.
		      </p>
		    </div>	
		  </div>

		  <div id="serving-algorithm" class="section">
		    <h4>Processing model</h4>
		  
		    <p>
		      The <dfn id="serve-policy">serve policy</dfn> steps are as follows.
		      A user agent can employ this policy only if it receives a safe HTTP
		      request, i.e., <code>GET</code> or <code>HEAD</code>, on non-interceptible
		      resources. These steps are invoked with an HTTP request called <var>request</var>.
		    </p>
		    
	        <ol>
              <li>
                Call the URL of the <var>request</var> as <var>requested resource</var>.
              </li>
              <li>
                Find the latest captured representation of the <var>required
                resource</var> and call it the <var>required representation</var>.
              </li>
              <li>
                If no <var>required representation</var> is found, then abort
                the remaining steps and continue processing the request without
                involving data caches.
              </li> 
              <li>
                Call the data cache holding the <var>required representation</var>
                as the <var>active data cache</var>.
              </li>
              <li>
                If the <var>active data cache</var> uses a required cookie and
                the current browsing context does not have that cookie, then
                abort the remaining steps and continue processing the request
                without involving data caches.
              </li>
              <li>
                Use the <var>required representation</var> including its headers
                and body to prepare a response, called <var>local response</var>.
              </li>
              <li>
                Set the <code>Content-Type</code> header in the <var>local
                response</var> using the content type of the <var>required
                representation</var>.
              </li>
              <li>Release the <var>local response</var> to the requester.</li>
	        </ol> 
	      </div>
        </div>
        
	    <div id="interceptor" class="section">
	      <h3>Intercepting HTTP Requests</h3>
	      
		  <p>
		    This specification introduces a mechanism similar to existing
		    pluggable protocol handlers, such as <cite><a href="#ref-NSURLProtocol">[NSURLProtocol]</a></cite>,
		    specifically for processing HTTP requests.
		  </p>
		
	      <div id="interception-intro" class="section">
	        <h4>Introduction</h4>			
	        
		    <div class="norm">This section is non-normative.</div>

		    <p>
		      This specification enables local processing of arbitrary HTTP
		      operations on <a class="dfnref" href="managed">managed resources</a>.
		    </p>
		
		    <p>
		      Standard user agents do not permit a locally produced
		      programmatic response to HTTP resources, which means that,
		      even if the application wishes, such requests cannot be
		      processed when the server is unreachable.
		    </p>
		
		    <p>
		      If the request to <a class="dfnref" href="#capture">capture</a>
		      a resource identifies a set of dynamic methods, then the user agent 
		      will provide a <a class="dfnref" href="#dynamic">dynamic representation</a> 
		      in response to requests with those methods for that captured resource.
		    </p>

		    <div class="example">				
			  <p>
			    For example, an application that wishes to allow local updates
			    to a locally stored preference list can do the following:
			  </p>
			  
			  <x:codeblock language="es">var dataCache = ...
dataCache.capture('/app/layout.plist', 'PUT');
window.interceptors['/app/'] = { 
  onintercept: function(interception) {
    if (...) {
      // validation fails
      interception.setStatus(400, 'HTTP/1.1 Bad Request');
      interception.send();
      return;
    } 
    var type = interception.getRequestHeader('Content-Type');
    dataCache.captureText(interception.requestURL,
      interception.requestText, type, 
      null, function(url, success) {
        if (!success)
          return; // we can't generate a dynamic response
        interception.setResponseText(interception.requestText);
        interception.setResponseHeader('Content-Type', type);
        interception.setStatus(200, 'HTTP/1.1 OK');
        interception.send();
    });
  }
};</x:codeblock>

			  <p>
			    Alternately, the interceptor can capture the body of a response
			    in some resource and redirect the intercepted request to that resource.
			  </p>
			  
			  <x:codeblock language="es">var dataCache = ...
dataCache.capture('/app/layout.plist', 'PUT');
window.interceptors['/app/'] = { 
  onintercept: function(interception) {
    if (...) {
      // validation fails
      interception.setStatus(400, 'HTTP/1.1 Bad Request');
      interception.send();
      return;
    } 
    dataCache.captureText(interception.requestURL, 
      interception.requestText, interception.getRequestHeader('Content-Type'), 
      null, function(url, success) {
        if (!success)
          return; // we can't generate a dynamic response
        interception.setResponseHeader('Location', interception.requestURL);
        interception.setStatus(303, 'HTTP/1.1 See Other');
        interception.send();
    });
  }
};</x:codeblock>

			  <p>
			    Later, when the page updates that preference with an
			    XMLHttpRequest, the user agent responds with a locally
			    produced response by asking the function identified by the
			    <var>onintercept</var> attribute to process the request.
			  </p>
		    </div>

		    <p>
		      If a user agent prefers to communicate with a server when network
		      connectivity is available, and if an interceptible request is
		      made to a <a class="dfnref" href="#managed">managed resource</a>, then the user
		      agent can send the request to the network and notify the
		      interceptor with the results of the request.
		    </p>

		    <div class="example">				
			  <p>
			    For example, a user agent that prefers updating the server and
			    then notifying the interceptor with results of server updates
			    to a locally stored preference list can do the following:
			  </p>
			  
			  <x:codeblock language="es">var dataCache = ...
dataCache.capture('/app/layout.plist', 'PUT');
window.interceptors['/app/'] = { 
  onreview: function(interaction) {
    dataCache.captureText('/app/layout.plist', 
      interaction.responseText,
      interaction.getResponseHeader('Content-Type'));
  }
};</x:codeblock>

			  <p>
			    Later, when the page updates that preference with an
			    XMLHttpRequest, the user agent obtains the server response
			    and then calls the function identified by the <var>onreview</var>
			    attribute to process the response.
			  </p>
		    </div>
	      </div>
		
		  <div id="interceptor-attribute" class="section">
		    <h4>The <code>interceptors</code> attribute</h4>
			<div>
			  <x:codeblock language="idl">[Supplemental] interface Window {
  readonly attribute sequence&lt;Interceptor> interceptors;
};

[Supplemental] interface WorkerUtils {
  readonly attribute sequence&lt;Interceptor> interceptors;
};</x:codeblock>  
            </div>
            
			<p>
			  The <dfn id="interceptors"><code>interceptors</code></dfn>
			  attribute on the <code>Window</code> and <code>WorkerUtils</code>
			  <a href="ref-WebWorkers">[Web Workers]</a> interfaces represents an associative array of 
			  <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> objects. The 
			  index of an <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> 
			  object is its namespace, which is the path prefix within the 
			  <i>origin</i> of the current browsing context that the 
			  <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> object can
			  intercept. The <dfn id="effective">effective</dfn> interceptor
			  for a given URL is the one whose namespace matches the longest
			  prefix of the given URL. There can be at most one 
			  <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> object for any
			  given namespace.
			</p>
			
			<div>
			  <x:codeblock language="idl">interface <dfn id="Interceptor">Interceptor</dfn> {
  // properties
  attribute <a href="#InterceptHandler">InterceptHandler</a> <a href="#onintercept">onintercept</a>;
  attribute <a href="#ReviewHandler">ReviewHandler</a> <a href="#onreview">onreview</a>;
};

[Callback=FunctionOnly, NoInterfaceObject]
interface <dfn id="InterceptHandler">InterceptHandler</dfn> {
  void handleEvent(in <a href="#HttpInterception">HttpInterception</a> interception);
};

[Callback=FunctionOnly, NoInterfaceObject]
interface <dfn id="ReviewHandler">ReviewHandler</dfn> {
  void handleEvent(in <a href="#HttpInteraction">HttpInteraction</a> interaction);
};</x:codeblock>
			</div>
			
			<p>
			  The <dfn id="onintercept"><code>onintercept</code></dfn> attribute 
			  must store the <a class="idltype" href="#InterceptHandler"><code>InterceptHandler</code></a>
			  that the user agent must invoke for intercepting a request to a 
			  <a class="dfnref" href="#managed">managed resource</a> in the 
			  namespace of this <code><a class="idltype" href="#Interceptor">Interceptor</a></code>.
			  The algorithm for intercepting requests is described in 
			  <a class="dfnref" href="#intercept-algorithm">Section 4.2.4.1</a>.
			</p>
			
			<p>
			  The <dfn id="onreview"><code>onreview</code></dfn> attribute must
			  store the <a class="idltype" href="#ReviewHandler"><code>ReviewHandler</code></a>
			  that the user agent must invoke for propagating response to a 
			  <a class="dfnref" href="#managed">managed resource</a> in the
			  namespace of this <code><a class="idltype" href="#Interceptor">Interceptor</a></code>.
			  The algorithm for propagating response is described in 
			  <a class="dfnref" href="#review-algorithm">Section 4.2.4.2</a>.
			</p>
			
			<p>
			  To invoke the <a class="idltype" href="#InterceptHandler"><code>InterceptHandler</code></a>
			  object, a user agent must provide an <a class="idltype" href="#HttpInterception">HttpInterception</a>
			  object to allow the application to respond to the intercepted request.
			</p>
			
			<p>
			  To invoke the <a class="idltype" href="#ReviewHandler"><code>ReviewHandler</code></a>
			  object, a user agent must provide an <a class="idltype" href="#HttpInteraction">HttpInteraction</a>
			  object to allow the application to process the network representation
			  received for the request.
			</p>
		
		  </div>

		  <div id="request-interface" class="section">
		    <h4>
		      The <a href="#HttpInterception"><code>HttpInterception</code></a>
		      and <a href="#HttpInteraction"><code>HttpInteraction</code></a> interfaces
		    </h4>			
			
			<div>
			  <x:codeblock language="idl">interface <dfn id="HttpRequest">HttpRequest</dfn> {  readonly attribute DOMString <a href="#request-method">method</a>;
  // properties
  readonly attribute DOMString <a href="#request-requestURL">requestURL</a>;
  readonly attribute DOMString <a href="#request-requestText">requestText</a>;
  readonly attribute DOMString <a href="#request-allRequestHeaders">allRequestHeaders</a>;

  DOMString <a href="#request-getRequestHeader">getRequestHeader</a>(in DOMString name);
};

interface <dfn id="HttpInterception">HttpInterception</dfn> : <a href="#HttpRequest">HttpRequest</a> {
  void <a href="#interception-setStatus">setStatus</a>(in unsigned short code, in DOMString text);
  void <a href="#interception-setResponseText">setResponseText</a>(in DOMString text);
  void <a href="#interception-setResponseHeader">setResponseHeader</a>(in DOMString name, in DOMString value);
  void <a href="#interception-send">send</a>();
};

interface <dfn id="HttpInteraction">HttpInteraction</dfn> : <a href="#HttpRequest">HttpRequest</a> {
  // properties
  readonly attribute unsigned short <a href="#interaction-statusCode">statusCode</a>;
  readonly attribute DOMString <a href="#interaction-statusLine">statusLine</a>;
  readonly attribute DOMString <a href="#interaction-responseText">responseText</a>;
  readonly attribute DOMString <a href="#interaction-allResponseHeaders">allResponseHeaders</a>;

  DOMString <a href="#interaction-getResponseHeader">getResponseHeader</a>(in DOMString name);
};</x:codeblock>
			</div>
			
			<p>
			  The <dfn id="request-method"><code>method</code></dfn> attribute
			  represents HTTP method, in upper-case characters, present on an
			  intercepted or reviewed request.
			</p>

			<p>
			  The <dfn id="request-requestURL"><code>requestURL</code></dfn> 
			  attribute represents the URL of an intercepted or reviewed HTTP request.
			</p>
			
			<p>
			  The <dfn id="request-requestText"><code>requestText</code></dfn>
			  attribute represents the entity body intercepted or reviewed request.
			</p>
			
			<p>
			  The <dfn id="request-allRequestHeaders"><code>allRequestHeaders</code></dfn>
			  attribute represents the sequence of HTTP request and entity headers, 
			  separated by a CRLF sequence, of the intercepted or reviewed request.
			</p>
			
			<p>
			  The <dfn id="request-getRequestHeader"><code>getRequestHeader(name)</code></dfn>
			  method must return the value of the header associated with the given 
			  <var>name</var> for the intercepted or reviewed request. If no such
			  header is present, this method returns the Null object.
			</p>

			<p>
			  The <dfn id="interception-setResponseHeader"><code>setResponseHeader(name, value)</code></dfn>
			  method must store the <var>value</var> for the header with the given 
			  <var>name</var> for the response of interception. If a previous value
			  is associated with this header, then this method must append the 
			  <var>value</var> to it.
			</p>

			<p>
			  The <dfn id="interception-setStatus"><code>setStatus(code, text)</code></dfn>
			  method must store the numeric status from <var>code</var> and status
			  description from <var>text</var> for the response of interception, 
			  replacing any previous values for both.
			</p>
			
			<p>
			  The <dfn id="interception-setResponseText"><code>setResponseText(text)</code></dfn>
			  method must store the entity body from <var>text</var> on the response
			  of a reviewed request, replacing any previous value.
			</p>
			
			<p>
			  The <dfn id="interception-send"><code>send()</code></dfn> method
			  must dispatch the result of interception to the requesting
			  application along with the specified status, headers, and body. No
			  further changes must be allowed to this 
			  <a class="idltype" href="HttpInterception"><code>HttpInterception</code></a> object.
			</p>
			
			<p>
			  The <dfn id="interaction-statusCode"><code>statusCode</code></dfn>
			  attribute represents numeric status code present on the response to
			  a reviewed request.
			</p>

			<p>
			  The <dfn id="interaction-statusLine"><code>statusLine</code></dfn>
			  attribute represents the status text present on the response to
			  a reviewed HTTP request.
			</p>
			
			<p>
			  The <dfn id="interaction-responseText"><code>responseText</code></dfn>
			  attribute represents the entity body present on the response of
			  a reviewed request.
			</p>
			
			<p>
			  The <dfn id="interaction-allResponseHeaders"><code>allResponseHeaders</code></dfn>
			  attribute represents the sequence of HTTP response and entity
			  headers, separated by a CRLF sequence, present on the response of
			  a reviewed request.
			</p>

			<p>
			  The <dfn id="interaction-getResponseHeader"><code>getResponseHeader(name)</code></dfn>
			  method must return the value of the header associated with the
			  given <var>name</var> from the response to a reviewed request. If
			  no such header is present, this method returns the Null object.
			</p>
			
		  </div>
		
		  <div id="interceptor-algorithm" class="section">
		    <h4>Processing model</h4>
		    
			<p>
			  User agents may employ one of two algorithms when processing
			  HTTP requests.
			</p>
				
		    <div id="intercept-algorithm" class="section">
		      <h5>For intercept policy</h5>
		      
		      <p>
		        The <dfn id="intercept-policy">intercept policy</dfn> steps
		        are as follows. These steps are invoked with an HTTP request
		        called <var>request</var>.
		      </p>
		      
		      <ol>
			    <li>
			      Call the URL of the <var>request</var> as <var>requested
			      resource</var> and the method of the <var>request</var> as
			      the <var>requested method</var>.
			    </li>
			    
                <li>
                  If the request includes the header <code>X-Bypass-DataCache</code>
                  and the value of that header is <code>true</code>, then abort
                  the remaining steps and continue processing the request without
                  involving interceptors.
                </li>
                
                <li>
                  Find the <a class="dfnref" href="#effective">effective</a>
                  <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> object for
                  the <var>requested resource</var> and call it the <var>effective
                  interceptor</var>.
                </li>
                
                <li>
                  If no <a href="#effective">effective</a>
                  <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> object is
                  found, then abort the remaining steps and continue processing
                  the request without involving interceptors.
                </li> 
                
                <li>
                  If the <var>effective interceptor</var> does not have a value
                  for its <a class="idltype" href="#onintercept"><code>onintercept</code></a>
                  attribute, then abort the remaining steps and continue
                  processing the request without involving interceptors.
                </li>
                
                <li>
                  Find the representation of the <var>requested resource</var>
                  in data caches and call it the <var>present representation</var>.
                </li>
                
                <li>
                  If no <var>present representation</var> is found, then abort
                  the remaining steps and continue processing the request
                  without involving interceptors.
                </li> 
                
                <li>
                  If the data cache holding the <var>present representation</var>
                  is secure, i.e., uses an authorization cookie and the current
                  browsing context does not have that cookie, then abort the
                  remaining steps and continue processing the request without 
                  involving interceptors.
                </li>
                
                <li>
                  If the <var>present representation</var> does not include the
                  <var>requested method</var> in its list of interceptible
                  methods, then abort the remaining steps and continue
                  processing the request without involving interceptors.
                </li>
                
                <li>
                  Call the value for the 
                  <a class="idltype" href="#onintercept"><code>onintercept</code></a> attribute
                  of the <var>effective interceptor</var> as <var>interceptor</var>.
                </li>
                
                <li>
                  Prepare an <a class="idltype" href="#HttpInterception"><code>HttpInterception</code></a>
                  object from the current request and call it <var>interception object</var>.
                </li>
                
                <li>
                  Invoke the <var>interceptor</var> with the <var>interception object</var>.
                </li>
        	  </ol> 
		    </div>
		    
		    <div id="review-algorithm" class="section">
		      <h5>For review policy</h5>
		      
		      <p>
		        The <dfn id="review-policy">review policy</dfn> steps are as
		        follows. These steps are invoked with an HTTP request called
		        <var>request</var>.
		      </p>
		      
		      <ol>
                <li>
                  Call the URL of the HTTP request as <var>requested resource</var>
                  and the method of the HTTP request as the <var>requested method</var>.
                </li>
                
                <li>Relay the request to the resource.</li>
                
                <li>
                  Wait until the response becomes available, and continue the
                  remaining steps when the response is ready.
                </li>
                <li>
                  Call the server response as <var>server response</var> and
                  the original request as <var>original request</var>.
                </li>
                <li>
                  If <var>original request</var> includes the header 
                  <code>X-Bypass-DataCache</code> and the value of that header 
                  is <code>true</code>, then abort the remaining steps.
                </li>
                
                <li>
                  Find the <a class="dfnref" href="#effective">effective</a> 
                  <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> object
                  for the <var>requested resource</var> and call it the 
                  <var>effective interceptor</var>.
                </li>
                
                <li>
                  If no <a href="#effective">effective</a> 
                  <a class="idltype" href="#Interceptor"><code>Interceptor</code></a> object
                  is found, then abort the remaining steps.
                </li> 
                
                <li>
                  If the <var>effective interceptor</var> does not have a 
                  value for its <a class="idltype" href="#onreview"><code>onreview</code></a>
                  attribute, then abort the remaining steps.
                </li>
                
                <li>
                  Find the representation of the <var>requested resource</var>
                  in data caches and call it the <var>present representation</var>.
                </li>
                
                <li>
                  If no <var>present representation</var> is found, then abort
                  the remaining steps.</li> 
                <li>
                  If the <var>present representation</var> does not include
                  the <var>requested method</var> in its list of interceptible
                  methods, then abort the remaining steps.
                </li>
                
                <li>
                  Call the value for the <a class="idltype" href="#onreview"><code>onreview</code></a>
                  attribute of the <var>effective interceptor</var> as 
                  <var>interceptor</var>.
                </li>
                
                <li>
                  Prepare an <a class="idltype" href="#HttpInteraction"><code>HttpInteraction</code></a>
                  object from the <var>original request</var> and the 
                  <var>server response</var> and call it <var>interaction object</var>.
                </li>
                
                <li>Invoke the <var>interceptor</var> with the <var>interaction object</var>.</li>
    		  </ol> 
	        </div>
          </div>
		</div>
	  </div>
	  
      <div id="security" class="section">
        <h2>Security Considerations</h2>
        
        <p>
          Apart from requirements affecting security made throughout
          this specification implementations may, at their discretion,
          not expose certain headers, such as HttpOnly cookies. 
        </p>

		<p>
		  Applications need to verify the identity of their users before
		  allowing access to <a class="dfnref" href="#secure">secure resources</a> they
		  manage. Typically a server verifies the identity of its users by
		  checking whether the user possesses valid credentials including a
		  shared secret, e.g., a password. Applications design their own user
		  interface to provide a means for users to supply their credentials
		  for authentication. In Web applications, this is typically performed
		  using HTML forms and it provides applications with a great deal of
		  control over the authentication user interface. Also, applications
		  typically do not verify the user's credentials for every request. 
		  Instead, applications verify a token stored on the client as a result
		  of authentication. This token is a session identifier often stored in
		  an HTTP cookie <cite><a href="#ref-RFC2109">[RFC2109]</a></cite>.
		  This approach is highly scalable since just the session identifier
		  and not credentials are validated for every HTTP request. Use of
		  session identifiers gives the data source wide latitude over
		  terminating the authorization and restricting access to certain
		  scopes. It also allows users to share authorization but not their
		  credentials with a variety of less-trustworthy applications.
		</p>
		
		<p>
		  The token approach also enables off-line authentication without
		  storing any credentials locally. The token produced by the server is
		  used by BITSY to authenticate requests served locally and for
		  capturing resources from the server. If a data cache is to store
		  <a class="dfnref" href="secure">secure resources</a>, it must be
		  <a href="#datacache">created with a cookie name</a>. Once such a
		  data cache is created, the user agent must serve or intercept requests
		  to its captured resources only if the cookie used to secure the cache
		  is still present in the current browsing context. 
		</p>
		<p>
		  Failing this, the user agent must make the request to the server as
		  would be the case if the resource were not captured locally. If the
		  user agent receives an HTTP 401 status from a server while capturing a
		  resource using a required cookie, then it must automatically destroy
		  the data cache originating that capture attempt.
		</p>
      </div>
    </div>

    <div id='appendices'>
      <div id='references' class='section'>
        <h2>References</h2>

        <div id='normative-references' class='section'>
          <h3>Normative references</h3>

          <dl>
		    <dt><dfn id="ref-DOM3Core">[DOM3Core]</dfn></dt>
			<dd>
			  <cite><a href="http://www.w3.org/TR/DOM-Level-3-Core">Document Object Model (DOM) Level 3 Core Specification</a></cite>, 
			  A. Le Hors (eds.), et al. W3C, April 2004.
			</dd>
		    <dt><dfn id="ref-HTML5">[HTML5]</dfn></dt>
			<dd>
			  <cite><a href="http://www.w3.org/TR/HTML5">HTML5: A vocabulary and associated APIs for HTML and XHTML</a></cite>, 
			  Ian Hickson, editor, W3C Working Draft, April 2009.
			</dd>
			<dt><dfn id="ref-RFC2109">[RFC2109]</dfn></dt>
			<dd>
			  <cite><a href="http://ietf.org/rfc/rfc2109.txt">HTTP State Management Mechanism</a></cite>,
			  D. Kristol and L. Montulli. IETF, February 1997.
			</dd>
			<dt><dfn id="ref-RFC2119">[RFC2119]</dfn></dt>
			<dd>
			  <cite><a href="http://ietf.org/rfc/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
			  S. Bradner. IETF, March 1997.
			</dd>
			<dt><dfn id="ref-RFC2616">[RFC2616]</dfn></dt>
			<dd>
			  <cite><a href="http://www.ietf.org/rfc/rfc2616.txt">Hypertext transfer protocol -- HTTP 1.1</a></cite>,
			  R. Fielding et al. IETF RFC 2616, June 1999.
			</dd>
			<dt><dfn id="ref-WebIDL">[WebIDL]</dfn></dt>
			<dd>
			  <cite><a href="http://www.w3.org/TR/WebIDL">Web IDL</a></cite>,
			  Cameron McCormack, editor. W3C Working Draft, December 2008.
			</dd>
			<dt><dfn id="ref-WebIDL">[WebWorkers]</dfn></dt>
			<dd>
			  <cite><a href="http://www.w3.org/TR/workers">Web Workers</a></cite>,
			  Ian Hickson, editor. W3C Working Draft, April 2009.
			</dd>
          </dl>
        </div>

        <div id='informative-references' class='section'>
          <h3>Informative references</h3>

          <dl>
			<dt><dfn id="ref-NSURLProtocol">[NSURLProtocol]</dfn></dt>
			<dd>
			  <cite><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSURLProtocol_Class/Reference/Reference.html">NSURLProtocol Reference</a></cite>, 
			  Apple.
			</dd>
			<dt><dfn id="ref-XMLHttpRequest">[XMLHttpRequest]</dfn></dt>
			<dd>
		  	  <cite><a href="http://www.w3.org/TR/XMLHttpRequest/">The XMLHttpRequest Object</a></cite>,
			  A. van Kesteren. W3C Working Draft, 15 April 2008.
			</dd>
          </dl>
        </div>
      </div>
    </div>
  </body>
</html>
