<?xml version='1.0'?>

<!--
  Overview.xml
  Language Bindings for DOM Specifications

  This is written in XHTML 1.1 with an inline <options> element that helps
  the Binding4DOM.xsl stylesheet process the document (generating a table
  of contents, section numbers, certain processing instructions).  The silly
  DTD subset is required so that the XPath id() function works appropriately.
  -->

<?xml-stylesheet href='Binding4DOM.xsl' type='text/xsl'?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" [
<!ELEMENT grammar ANY>
<!ATTLIST grammar id ID #IMPLIED>
]>
<html xmlns='http://www.w3.org/1999/xhtml' xmlns:x='http://mcc.id.au/ns/local' xml:lang='en'>
  <head>
    <title>Language Bindings for DOM Specifications</title>
    <meta http-equiv='Content-Type' content='application/xhtml+xml; charset=UTF-8'/>
    <meta name='revision' content='$Id: Overview.xml,v 1.32 2007-06-28 01:19:50 cmccorma Exp $'/>
    <link rel='stylesheet' href='http://www.w3.org/StyleSheets/TR/base' type='text/css'/>
    <link rel='stylesheet' href='Binding4DOM.css' type='text/css'/>

    <options xmlns='http://mcc.id.au/ns/local'>
      <versions>
        <this cvsweb='true' href='http://dev.w3.org/cvsweb/~checkout~/2006/webapi/Binding4DOM/Overview.html'/>
        <latest href=''/>
        <previous href=''/>
      </versions>
      <editors>
        <person homepage='http://mcc.id.au/' email='cam@mcc.id.au'>
          <name>Cameron McCormack</name>
          <affiliation>Invited Expert</affiliation>
        </person>
      </editors>
      <years>2007</years>
    </options>
  </head>

  <body>
    <?top?>

    <div class='section'>
      <h2>Abstract</h2>
      <p>
        This specification defines an Interface Definition Language (IDL) to be
        used by specifications that define a Document Object Model (DOM).  How
        interfaces described with this IDL correspond to constructs within an
        ECMAScript execution environment is also detailed.
      </p>

      <div class='ednote'>
        <p>
          This is revision $Id: Overview.xml,v 1.32 2007-06-28 01:19:50 cmccorma Exp $.
        </p>
      </div>
    </div>

    <div class='section'>
      <h2>Status of this Document</h2>

      <p>
        <em>
          This section describes the status of this document at the time of
          its publication.  Other documents may supersede this document. A list
          of current <acronym title="World Wide Web Consortium">W3C</acronym>
          publications and the latest revision of this technical report can be
          found in the 
          <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym>
            technical reports index</a> at http://www.w3.org/TR/.
        </em>
      </p>
      <p>
        This document is the <?date?> <b>Editor’s Draft</b> of the
        “Language Bindings for DOM Specifications” specification.  Please send
        comments to <a href='mailto:public-webapi@w3.org'>public-webapi@w3.org</a>
        (<a href='http://lists.w3.org/Archives/Public/public-webapi/'>archived</a>)
        with “<tt>[Bindings]</tt>” at the start of the subject line.
      </p>
      <p>
        This document is produced by the
        <a href='http://www.w3.org/2006/webapi/'>Web API Working Group</a>, part of the
        <a href='http://www.w3.org/2006/rwc/Activity'>Rich Web Clients Activity</a>
        in the W3C <a href='http://www.w3.org/Interaction/'>Interaction Domain</a>.
        Changes made to this document can be found in the
        <a href='http://dev.w3.org/cvsweb/2006/webapi/Binding4DOM/Overview.html'>W3C
          public CVS server</a>.
      </p>
      <p>
        Publication as a Working Draft does not imply endorsement by the
        <acronym title="World Wide Web Consortium">W3C</acronym> Membership.
        This is a draft document and may be updated, replaced or obsoleted by
        other documents at any time. It is inappropriate to cite this document
        as other than work in progress.
      </p>
      <p>
        This document was produced by a group operating under the 5 February
        2004 W3C Patent Policy. W3C maintains a public list of any patent
        disclosures made in connection with the deliverables of the group; that
        page also includes instructions for disclosing a patent. An individual
        who has actual knowledge of a patent which the individual believes
        contains Essential Claim(s) must disclose the information in accordance
        with section 6 of the W3C Patent Policy.
      </p>
    </div>

    <div class='section'>
      <h2>Table of contents</h2>
      <?toc sections appendices?>
    </div>

    <div id='sections'>
      <div id='introduction' class='section'>
        <h2>Introduction</h2>

        <p>
          Specifications published by the W3C that include Document Object Model
          (DOM) interfaces are typically described using the Object Management
          Group’s Interface Definition language (IDL)
          <a href='#ref-OMGIDL'>[OMGIDL]</a>.  The IDL provides a means to
          describe these interfaces in a language independent manner.  Usually,
          additional language binding appendices are included in such
          specifications which detail how the interfaces described with the IDL
          correspond to constructs in the given language.
        </p>
        <p>
          However, the bindings in these specifications for the language most
          commonly used on the web, ECMAScript, are consistently specified with
          low enough precision as to result in interoperability issues.  In
          addition, each specification must describe the same basic information,
          such as DOM interfaces described in IDL corresponding to properties
          on the ECMAScript global object, or the <span class='idltype'>unsigned
            long</span> IDL type mapping to the
          <span class='estype'>Number</span> type in ECMAScript.
        </p>
        <p>
          This specification defines a subset of OMG IDL version 3.0 for use
          by DOM specifications.  A number of extensions are given to the IDL
          to support common functionality that previously must have been
          written in prose.  In addition, a precise language binding for
          ECMAScript 3rd Edition is given.
        </p>
      </div>

      <div id='idl' class='section'>
        <h2>Interface definition language</h2>

        <p>
          This section describes a language with which interfaces can be defined
          in a language independent manner.  This language is based on the
          Object Management Group’s Interface Definition Language
          <a href='#ref-OMGIDL'>[OMGIDL]</a>, and is syntactically a subset thereof.
        </p>

        <p>
          An IDL fragment is a sequence of definitions that matches the
          <a class='nt' href='#prod-Definitions'>Definitions</a> non-terminal
          in the grammar.  See <a href='#idl-grammar'>Appendix <?sref idl-grammar?></a>
          for the complete grammar and an explanation of the notation used.
        </p>

        <p>…</p>
        <?productions grammar Definitions Definition?>

        <div id='idl-identifiers' class='section'>
          <h3>Identifiers</h3>

          <p>…</p>
          <?productions grammar ScopedName ScopedNameParts?>
        </div>

        <div id='idl-modules' class='section'>
          <h3>Modules</h3>

          <p>…</p>
          <?productions grammar Module?>
        </div>

        <div id='idl-interfaces' class='section'>
          <h3>Interfaces</h3>

          <p>…</p>
          <?productions grammar Interface InterfaceInheritance InterfaceBody InterfaceMembers InterfaceMember?>

          <div id='idl-constants' class='section'>
            <h4>Constants</h4>

            <p>…</p>
            <?productions grammar Const ConstExpr BooleanLiteral?>
          </div>

          <div id='idl-attributes' class='section'>
            <h4>Attributes</h4>

            <p>…</p>
            <?productions grammar Attribute ReadOnly GetRaises SetRaises ExceptionList Exceptions?>
          </div>

          <div id='idl-operations' class='section'>
            <h4>Operations</h4>

            <p>…</p>
            <?productions grammar Operation ReturnType ArgumentList Arguments Argument Raises?>
          </div>
        </div>

        <div id='idl-exceptions' class='section'>
          <h3>Exceptions</h3>

          <div class='ednote'>
            <p>
              In existing IDL, exception error codes are declared at the module scope level,
              since an exception declaration can contain only exception member variables.
              We could either extend ExceptionMembers to allow Consts (which would be
              syntactically incompatible with OMG IDL), or provide an extended attribute
              to associate the exception code constants with the particular exception.
            </p>
          </div>
          <p>…</p>
          <?productions grammar Exception ExceptionMembers ExceptionMember?>
        </div>

        <div id='idl-typedefs' class='section'>
          <h3>Typedefs</h3>

          <p>…</p>
          <?productions grammar Typedef?>
        </div>

        <div id='idl-valuetypes' class='section'>
          <h3>Valuetypes</h3>

          <p>…</p>
          <?productions grammar Valuetype?>
        </div>

        <div id='idl-types' class='section'>
          <h3>Types</h3>

          <p>…</p>
          <?productions grammar Type IntegerType OptionalLong?>
        </div>

        <div id='idl-extended-attributes' class='section'>
          <h3>Extended attributes</h3>

          <p>…</p>
          <?productions grammar ExtendedAttributeList ExtendedAttributes ExtendedAttributeAssignment ExtendedAttributeArgument?>

          <div id='Constructor' class='section'>
            <h4>[Constructor]</h4>

            <p>
              If the <a class='xattr' href='#Constructor'>[Constructor]</a>
              extended attribute appears on an interface, it indicates that
              there must be a way to construct objects that implement this interface.
              How such objects can be constructed is specific to the language binding.
            </p>
            <p>
              The <a class='xattr' href='#Constructor'>[Constructor]</a>
              extended attribute takes no argument.
            </p>
            <div class='example'>
              <p>
                The following IDL defines two interfaces.  The second has the
                <a class='xattr' href='#Constructor'>[Constructor]</a> extended
                attribute, while the first does not.
              </p>
              <x:codeblock language='idl'>interface NodeList {
  Node item(in unsigned long index);
  readonly attribute unsigned long length;
};

[Constructor]
interface Circle {
  attribute float r;
  attribute float cx;
  attribute float cy;
  readonly attribute float circumference;
};</x:codeblock>
              <p>
                An ECMAScript implementation supporting these interfaces would
                have a <span class='prop'>[[Construct]]</span> property on the
                <span class='idltype'>Circle</span> interface object which would
                return a new object that implements the interface.  The
                <span class='idltype'>NodeList</span> interface object would not
                have a <span class='prop'>[[Construct]]</span> property.
              </p>
              <x:codeblock language='es'>var x = new Circle();    // x is now a reference to a host object that implements the Circle interface.
var y = new NodeList();  // This would throw a TypeError.</x:codeblock>
            </div>
            <div class='ednote'>
              <p>
                This doesn’t allow for constructors which take arguments, and
                that’s probably something that will be wanted.  Maybe the
                extended attribute should be on operations instead, e.g.:
              </p>
              <x:codeblock language='idl'>interface Circle {
  attribute float r;
  attribute float cx;
  attribute float cy;
  readonly attribute float circumference;

  [Constructor] Circle createCircle(in float r, in float cx, in float cy);
};</x:codeblock>
              <p>
                For ES, such operations map to a [[Construct]] property
                with a function that takes the given arguments.  For other languages,
                this could perhaps map to a static method somewhere.
              </p>
            </div>
          </div>

          <div id='IndexGetter' class='section'>
            <h4>[IndexGetter]</h4>

            <p>
              If the <a class='xattr' href='#IndexGetter'>[IndexGetter]</a> extended
              attribute appears on an operation with a single <span class='idltype'>unsigned long</span>
              argument, it indicates that an object that implements the interface
              can be indexed with an <span class='idltype'>unsigned long</span>,
              resulting in the same effect as calling the operation with the given
              index (for languages that support such object indexing).
              If an object implements interfaces such that it has more than one
              operation annotated with <a class='xattr' href='#IndexGetter'>[IndexGetter]</a>,
              then which operation is invoked when an object is indexed with an
              <span class='idltype'>unsigned long</span> value is undefined.
            </p>
            <p>
              The <a class='xattr' href='#IndexGetter'>[IndexGetter]</a> extended attribute
              takes no argument.
            </p>
            <div class='example'>
              <p>
                The following IDL fragment defines an interface
                <span class='idltype'>OrderedMap</span> which allows
                retrieving and setting values by name or by index number:
              </p>
              <x:codeblock language='idl'>valuetype DOMString sequence&lt;octet>;

interface OrderedMap {
  readonly attribute unsigned long size;

  [IndexGetter] any getByIndex(in unsigned long index);
  [IndexPutter] void setByIndex(in unsigned long index, in any value);

  [NameGetter] any get(in DOMString name);
  [NamePutter] void set(in DOMString name, in any value);
};</x:codeblock>
              <p>
                An ECMAScript implementation would have an internal
                <span class='prop'>[[Get]]</span> method that allows values
                to be retrieved from the map as properties, and a corresponding
                <span class='prop'>[[Put]]</span> method for setting values
                in the map:
              </p>
              <x:codeblock language='es'>var map = getOrderedMap();  // Assume map is a host object implementing the OrderedMap interface.
var x, y;

x = map[0];                 // Same as: x = map.getByIndex(0)
map[1] = false;             // Same as: map.setByIndex(1, false)

y = map.apple;              // Same as: y = map.get('apple')
map.banana = 123;           // Same as: map.set('banana', 123)</x:codeblock>
            </div>
          </div>

          <div id='IndexSetter' class='section'>
            <h4>[IndexSetter]</h4>

            <p>
              If the <a class='xattr' href='#IndexSetter'>[IndexSetter]</a> extended
              attribute appears on an operation with a two arguments, the first of which
              is <span class='idltype'>unsigned long</span>, it indicates that an object
              that implements the interface can be indexed with an
              <span class='idltype'>unsigned long</span> for assignment,
              resulting in the same effect as calling the operation with the given
              index and value to assign (for languages that support such object indexing).
              If an object implements interfaces such that it has more than one
              operation annotated with <a class='xattr' href='#IndexSetter'>[IndexSetter]</a>,
              then which operation is invoked when an object is indexed with an
              <span class='idltype'>unsigned long</span> value for assignment is undefined.
            </p>
            <p>
              The <a class='xattr' href='#IndexSetter'>[IndexSetter]</a> extended attribute
              takes no argument.
            </p>
            <div class='example'>
              <p>
                See <a href='#IndexGetter'>section <?sref IndexGetter?></a> for an
                example of the use of <a class='xattr' href='#IndexSetter'>[IndexSetter]</a>.
              </p>
            </div>
          </div>

          <div id='NameGetter' class='section'>
            <h4>[NameGetter]</h4>

            <p>
              If the <a class='xattr' href='#NameGetter'>[NameGetter]</a> extended
              attribute appears on an operation with a single boxed
              <span class='idltype'>sequence&lt;octet></span> valuetype argument, it
              indicates that an object that implements the interface can be
              indexed with a string, resulting in the same effect as calling the
              operation with the given index name (for languages that support
              such object indexing).
              If an object has both a <a class='xattr' href='#Getter'>[NameGetter]</a>-
              and <a class='xattr' href='#IndexGetter'>[IndexGetter]</a>-annotated
              operation, then which operation is invoked when an object is indexed
              is language binding specific.
            </p>
            <p>
              The <a class='xattr' href='#NameGetter'>[NameGetter]</a> extended attribute
              takes no argument.
            </p>
            <div class='example'>
              <p>
                See <a href='#IndexGetter'>section <?sref IndexGetter?></a> for an
                example of the use of <a class='xattr' href='#NameGetter'>[NameGetter]</a>.
              </p>
            </div>
            <div class='ednote'>
              <p>
                I’m slightly uncomfortable giving sequence&lt;octet> such
                special status here.
              </p>
            </div>
          </div>

          <div id='NameSetter' class='section'>
            <h4>[NameSetter]</h4>

            <p>
              If the <a class='xattr' href='#NameSetter'>[NameSetter]</a> extended
              attribute appears on an operation with a two arguments, the first of which
              is a boxed <span class='idltype'>sequence&lt;octet></span> valuetype,
              it indicates that an object that implements the interface can be
              indexed with a string for assignment, resulting in the same effect
              as calling the operation with the given index and value to assign
              (for languages that support such object indexing).  If an object
              implements interfaces such that it has more than one
              operation annotated with <a class='xattr' href='#NameSetter'>[NameSetter]</a>,
              then which operation is invoked when an object is indexed with a
              boxed <span class='idltype'>sequence&lt;octet></span> value for
              assignment is undefined.
            </p>
            <p>
              The <a class='xattr' href='#NameSetter'>[NameSetter]</a> extended attribute
              takes no argument.
            </p>
            <div class='example'>
              <p>
                See <a href='#IndexGetter'>section <?sref IndexGetter?></a> for an
                example of the use of <a class='xattr' href='#NameSetter'>[NameSetter]</a>.
              </p>
            </div>
          </div>

          <div id='NoNull' class='section'>
            <h4>[NoNull]</h4>

            <p>
              If the <a class='xattr' href='#NoNull'>[NoNull]</a> extended
              attribute appears on an attribute, an operation or an operation
              argument, whose type is a boxed valuetype, it indicates that
              a null value is not expected and will never be returned.  How
              implementations treat the assignment of a null value to an
              attribute with the <a class='xattr' href='#NoNull'>[NoNull]</a>
              extended attribute, or passing a null value as a
              <a class='xattr' href='#NoNull'>[NoNull]</a> operation argument,
              is specific to the language binding.
            </p>
            <p>
              The <a class='xattr' href='#NoNull'>[NoNull]</a>
              extended attribute takes no argument.
            </p>
            <div class='example'>
              <p>
                The following IDL fragment defines an interface that has one
                attribute with the <a class='xattr' href='#NoNull'>[NoNull]</a>
                extended attribute, and one operation with an argument that has
                the extended attribute:
              </p>
              <x:codeblock language='idl'>valuetype DOMString sequence&lt;octet>;

interface Dog {
  [NoNull] attribute DOMString name;
  attribute DOMString shortName;

  boolean isMemberOfBreed([NoNull] in DOMString breedName);
};</x:codeblock>
              <p>
                An ECMAScript implementation implementing the <span class='idltype'>Dog</span>
                interface would not allow the <span class='esvalue'>null</span> value to
                be assigned to the <span class='prop'>name</span> property or passed as the
                argument to the <span class='prop'>isMemberOfBreed</span> function:
              </p>
              <x:codeblock language='es'>var d = getDog();         // Assume d is a host object implementing the Dog interface.

d.name = null;            // This assigns the string "null" to the .name property.
d.isMemberOfBreed(null);  // This passes the string "null" to the isMemberOfBreed function.</x:codeblock>
            </div>

            <div class='ednote'>
              <p>
                Perhaps instead of having a <span class='xattr'>[NoNull]</span> extended attribute
                on DOMString arguments/attributes, different types could be used, e.g.:
              </p>
              <x:codeblock language='idl'>typedef sequence&lt;octet> DOMString;
valuetype DOMStringOrNull DOMString;</x:codeblock>
            </div>
          </div>

          <div id='Overloads' class='section'>
            <h4>[Overloads]</h4>

            <p>
              If the <a class='xattr' href='#Overloads'>[Overloads]</a>
              extended attribute appears on an operation, it indicates that
              the operation is to be considered to overload the operation
              with the identifier given as the extended attribute argument.
              The extent to which a language supports method overloading
              determines whether an object implementing an interface with
              overloaded operations must implement the operation using the
              overloaded name or the original name, and is specific to the
              language binding.
            </p>
            <p>
              The <a class='xattr' href='#Overloads'>[Overloads]</a>
              extended attribute takes a single, required argument,
              an <a class='nt' href='#prod-Identifier'>Identifier</a>,
              which specifies the name of the operation in the interface
              this operation overloads.  The
              <a class='nt' href='#prod-Identifier'>Identifier</a> must not
              identify an operation that itself is declared with an
              <a class='xattr' href='#Overloads'>[Overloads]</a> extended
              attribute.
            </p>
            <div class='example'>
              <p>
                The following IDL fragment defines an interface with
                overloaded operations:
              </p>
              <x:codeblock language='idl'>interface Person;

interface PersonFactory {
  Person createPerson();
  [Overloads=createPerson] Person createPersonWithAge(in short age);
};</x:codeblock>
              <p>
                Since the ECMAScript binding allows overloading, a host object
                implementing the <span class='idltype'>PersonFactory</span>
                interface will have a single property <span class='prop'>createPerson</span>:
              </p>
              <x:codeblock language='es'>var f = getFactory();          // Assume f is a host object implementing the PersonFactory interface.

typeof f.createPerson;         // Evaluates to "function".
typeof f.createPersonWithAge;  // Evaluates to "undefined".

var p1 = f.createPerson();     // Corresponds to the createPerson operation.
var p2 = f.createPerson(26);   // Corresponds to the createPersonWithAge operation.</x:codeblock>
              <p>
                However, a hypothetical C language binding would not, since
                C does not support overloading.  Separate functions would likely
                be used for the two operations:
              </p>
              <x:codeblock language='c'>PersonFactory* f = getFactory();

Person* p1 = PersonFactory_createPerson(f);             // Corresponds to the createPerson operation.
Person* p2 = PersonFactory_createPersonWithAge(f, 26);  // Corresponds to the createPersonWithAge operation.</x:codeblock>
            </div>
          </div>

          <div id='PutForwards' class='section'>
            <h4>[PutForwards]</h4>

            <p>
              If the <a class='xattr' href='#PutForwards'>[PutForwards]</a> extended
              attribute appears on a readonly attribute declaration whose type is an object,
              it indicates that assigning to the attribute will have specific behavior.
              Namely, the assignment is “forwarded” to the attribute (specified by
              the extended attribute argument) on the object that is currently the value
              of the attribute being assigned to.
            </p>
            <p>
              It is binding language specific what behavior occurs when assigning
              to such an attribute when its value is null.
            </p>
            <p>
              The <a class='xattr' href='#PutForwards'>[PutForwards]</a> extended
              attribute takes a single, required argument, an
              <a class='nt' href='#prod-Identifier'>Identifier</a>, which
              specifies the name of the attribute assignments must be forwarded to.
            </p>
            <div class='example'>
              <p>
                The following IDL fragment defines interfaces for names and people.
                The <a class='xattr' href='#PutForwards'>[PutForwards]</a> extended
                attribute is used on the <span class='idlattr'>name</span> attribute
                of the <span class='idltype'>Person</span> interface to indicate
                that assignments to that attribute result in assignments to the
                <span class='idlattr'>full</span> attribute of the
                <span class='idltype'>Person</span> object:
              </p>
              <x:codeblock language='idl'>valuetype DOMString sequence&lt;octet>;

interface Name {
  attribute DOMString full;
  attribute DOMString family;
  attribute DOMString given;
};

interface Person {
  [PutForwards=full] readonly attribute Name name;
  attribute unsigned short age;
};</x:codeblock>
              <p>
                In the ECMAScript binding, this would allow assignments to the
                <span class='prop'>name</span> property:
              </p>
              <x:codeblock language='es'>var p = getPerson();           // Assume p is a host object implementing the Person interface.

p.name = 'John Citizen';       // This statement...
p.name.full = 'John Citizen';  // ...has the same behavior as this one.</x:codeblock>
            </div>
          </div>

          <div id='Variadic' class='section'>
            <h4>[Variadic]</h4>

            <p>
              If the <a class='xattr' href='#Variadic'>[Variadic]</a>
              extended attribute appears on the final argument of an operation,
              it indicates that the operation is variadic, and can be passed
              zero or more arguments after the regular arguments.  Each of
              these extra arguments must be of the type specified by that
              final argument.  How such arguments are passed is specific to the
              language binding.
            </p>
            <p>
              The <a class='xattr' href='#Variadic'>[Variadic]</a>
              extended attribute takes no argument.
            </p>
            <div class='example'>
              <p>
                The following IDL fragment defines an interface that has a
                variadic operation:
              </p>
              <x:codeblock language='idl'>interface IntegerSet {
  readonly unsigned long cardinality;

  void union([Variadic] in long integers);
  void intersection([Variadic] in long integers);
};</x:codeblock>
              <p>
                In the ECMAScript binding, variadic operations are implemented by
                functions that can accept the subsequent arguments:
              </p>
              <x:codeblock language='es'>var s = getIntegerSet();  // Assume s is a host object implementing the IntegerSet interface.

s.union();                // Passing no arguments corresponding to 'integers'.
s.union(1, 4, 7);         // Passing three arguments corresponding to 'integers'.</x:codeblock>
              <p>
                A binding for a language that does not support variadic functions
                may specify that an explicit array or list of integers be passed
                to such an operation.
              </p>
            </div>
          </div>
        </div>
      </div>

      <div id='ecmascript-binding' class='section'>
        <h2>ECMAScript binding</h2>

        <p>
          This section describes how interfaces described with the IDL in section
          <?sref idl?> correspond to particular ECMAScript constructs.
        </p>
        <p>
          Unless otherwise specified, every object described in this section
          has internal properties <span class='prop'>[[Get]]</span>,
          <span class='prop'>[[Put]]</span>,
          <span class='prop'>[[CanPut]]</span>,
          <span class='prop'>[[HasProperty]]</span>,
          <span class='prop'>[[Delete]]</span> and
          <span class='prop'>[[DefaultValue]]</span> with the same behavior as
          specified for native objects, as described in section 8.6.2 of
          <a href='#ref-ECMA-262'>[ECMA-262]</a>.
        </p>
        <p>
          If a value for the internal property
          <span class='prop'>[[Class]]</span> is not given for a particular
          object, its value is implementation specific.
        </p>

        <div id='type-mapping' class='section'>
          <h3>Type mapping</h3>

          <p>
            This sub-section describes how types in the IDL map to types in ECMAScript.
            The phrase “to pass a value to a host object expecting type <var>T</var>” is used in this sub-section
            to describe passing an ECMAScript value as an argument to a function whose corresponding operation in the IDL specifies that
            the argument is of type <var>T</var>, or assigning to a property whose corresponding attribute in the IDL
            is of type <var>T</var>.  Conversely, the phrase “to return a value of type
            <var>T</var> from a host object” is used to describe obtaining the ECMAScript return value
            from a function whose corresponding operation in the IDL specifies a return type <var>T</var>,
            or retrieving a property whose corresponding attribute in the IDL is of type <var>T</var>.
          </p>

          <div id='type-any' class='section'>
            <h4>any</h4>

            <p>
              The <span class='idltype'>any</span> IDL type can correspond to any
              ECMAScript type.
            </p>
          </div>

          <div id='type-void' class='section'>
            <h4>void</h4>

            <p>
              The only place that the <span class='idltype'>void</span> type may appear
              in IDL is as the return type of an operation.  Functions on host objects
              that implement an operation whose IDL specifies a
              <span class='idltype'>void</span> return type must return the
              <span class='esvalue'>undefined</span> value.
            </p>
            <p>
              ECMAScript functions
              that implement an operation whose IDL specifies a <span class='idltype'>void</span>
              return type may return any value, which will be discarded.
            </p>
          </div>

          <div id='type-boolean' class='section'>
            <h4>boolean</h4>

            <p>
              Values passed to a host object that expects a
              <span class='idltype'>boolean</span> will first be converted
              to an ECMAScript <span class='estype'>Boolean</span> value by the
              ToBoolean operator defined in section 9.2 of [<a href='#ref-ECMA-262'>ECMA-262</a>].
            </p>
            <p>
              <span class='idltype'>boolean</span> values returned from a host object
              must be ECMAScript <span class='estype'>Boolean</span> values.
            </p>
          </div>

          <div id='type-octet' class='section'>
            <h4>octet</h4>

            <p>
              Values passed to a host object that expects an
              <span class='idltype'>octet</span> will first be converted to an
              ECMAScript <span class='estype'>Number</span> value by the
              ToUint8 operator, which functions, analagously to the ToUint32
              operator defined in section 9.6 of [<a href='#ref-ECMA-262'>ECMA-262</a>],
              as follows:
            </p>
            <ol class='algorithm'>
              <li>Call ToNumber on the input argument.</li>
              <li>If Result(1) is <span class='esvalue'>NaN</span>, +0, −0, +∞, or −∞, return +0.</li>
              <li>Compute sign(Result(1)) * floor(abs(Result(1))).</li>
              <li>Compute Result(3) modulo 2<sup>8</sup>.</li>
              <li>Return Result(4).</li>
            </ol>
            <p>
              <span class='idltype'>octet</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.
            </p>
          </div>

          <div id='type-short' class='section'>
            <h4>short</h4>

            <p>
              Values passed to a host object that expects a
              <span class='idltype'>short</span> will first be converted
              to an ECMAScript <span class='estype'>Number</span> value by
              the ToInt16 operator, which functions, analagously to the ToInt32
              operator defined in section 9.5 of [<a href='#ref-ECMA-262'>ECMA-262</a>],
              as follows:
            </p>
            <ol class='algorithm'>
              <li>Call ToNumber on the input argument.</li>
              <li>If Result(1) is <span class='esvalue'>NaN</span>, +0, −0, +∞, or −∞, return +0.</li>
              <li>Compute sign(Result(1)) * floor(abs(Result(1))).</li>
              <li>Compute Result(3) modulo 2<sup>16</sup>.</li>
              <li>If Result(4) is greater than or equal to 2<sup>15</sup>, return Result(4)−2<sup>16</sup>.
                Otherwise, return Result(4).</li>
            </ol>
            <p>
              <span class='idltype'>short</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.
            </p>
          </div>

          <div id='type-unsigned-short' class='section'>
            <h4>unsigned short</h4>

            <p>
              Values passed to a host object that expects an
              <span class='idltype'>unsigned short</span> will first be converted to an
              ECMAScript <span class='estype'>Number</span> value by the
              ToUint16 operator defined in section 9.7 of [<a href='#ref-ECMA-262'>ECMA-262</a>].
            </p>
            <p>
              <span class='idltype'>unsigned short</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.
            </p>
          </div>

          <div id='type-long' class='section'>
            <h4>long</h4>

            <p>
              Values passed to a host object that expects an
              <span class='idltype'>long</span> will first be converted to an
              ECMAScript <span class='estype'>Number</span> value by the
              ToInt32 operator defined in section 9.5 of [<a href='#ref-ECMA-262'>ECMA-262</a>].
            </p>
            <p>
              <span class='idltype'>long</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.
            </p>
          </div>

          <div id='type-unsigned-long' class='section'>
            <h4>unsigned long</h4>

            <p>
              Values passed to a host object that expects an
              <span class='idltype'>unsigned long</span> will first be converted to an
              ECMAScript <span class='estype'>Number</span> value by the
              ToUint32 operator defined in section 9.5 of [<a href='#ref-ECMA-262'>ECMA-262</a>].
            </p>
            <p>
              <span class='idltype'>unsigned long</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.
            </p>
          </div>

          <div id='type-long-long' class='section'>
            <h4>long long</h4>

            <p>
              Values passed to a host object that expects a
              <span class='idltype'>long long</span> will first be converted
              to an ECMAScript <span class='estype'>Number</span> value by
              the ToInt64 operator, which functions, analagously to the ToInt32
              operator defined in section 9.5 of [<a href='#ref-ECMA-262'>ECMA-262</a>],
              as follows:
            </p>
            <ol class='algorithm'>
              <li>Call ToNumber on the input argument.</li>
              <li>If Result(1) is <span class='esvalue'>NaN</span>, +0, −0, +∞, or −∞, return +0.</li>
              <li>Compute sign(Result(1)) * floor(abs(Result(1))).</li>
              <li>Compute Result(3) modulo 2<sup>64</sup>.</li>
              <li>If Result(4) is greater than or equal to 2<sup>63</sup>, return Result(4)−2<sup>64</sup>.
                Otherwise, return Result(4).</li>
            </ol>
            <p>
              <span class='idltype'>long long</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.  If the
              <span class='idltype'>long long</span> value cannot be represented exactly
              by a <span class='estype'>Number</span> value (i.e., it is less than or equal
              to −2<sup>53</sup> or greater than or equal to 2<sup>53</sup>), the
              <span class='estype'>Number</span> value returned must be the number
              representable by a <span class='estype'>Number</span> closest to the
              given <span class='idltype'>long long</span>.
            </p>
            <div class='ednote'>
              <p>Should check that range of signed integers representable in a double.</p>
            </div>
          </div>

          <div id='type-unsigned-long-long' class='section'>
            <h4>unsigned long long</h4>

            <p>
              Values passed to a host object that expects an
              <span class='idltype'>unsigned long long</span> will first be converted to an
              ECMAScript <span class='estype'>Number</span> value by the
              ToUint64 operator, which functions, analagously to the ToUint32
              operator defined in section 9.6 of [<a href='#ref-ECMA-262'>ECMA-262</a>],
              as follows:
            </p>
            <ol class='algorithm'>
              <li>Call ToNumber on the input argument.</li>
              <li>If Result(1) is <span class='esvalue'>NaN</span>, +0, −0, +∞, or −∞, return +0.</li>
              <li>Compute sign(Result(1)) * floor(abs(Result(1))).</li>
              <li>Compute Result(3) modulo 2<sup>64</sup>.</li>
              <li>Return Result(4).</li>
            </ol>
            <p>
              <span class='idltype'>unsigned long long</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.  If the
              <span class='idltype'>unsigned long long</span> value cannot be represented exactly
              by a <span class='estype'>Number</span> value (i.e., it is greater than
              or equal to 2<sup>53</sup>), the <span class='estype'>Number</span> value
              returned must be the number representable by a <span class='estype'>Number</span>
              closest to the given <span class='idltype'>unsigned long long</span>.
            </p>
            <div class='ednote'>
              <p>
                Should we do something other than choosing the closest double value to
                represent the long long?
              </p>
            </div>
          </div>

          <div id='type-float' class='section'>
            <h4>float</h4>

            <p>
              Values passed to a host object that expects a
              <span class='idltype'>float</span> will first be converted
              to an ECMAScript <span class='estype'>Number</span> value by the
              ToNumber operator defined in section 9.3 of [<a href='#ref-ECMA-262'>ECMA-262</a>].
            </p>
            <p>
              <span class='idltype'>float</span> values returned from a host object
              must be ECMAScript <span class='estype'>Number</span> values.
            </p>
          </div>

          <div id='type-Object' class='section'>
            <h4>Object</h4>

            <p>
              If a host object that expects an <span class='idltype'>Object</span>
              is passed the <span class='esvalue'>null</span> value, then that value
              is passed without modification.  Otherwise, the value being passed will
              first be converted to an ECMAScript <span class='estype'>Object</span> value
              by the ToObject operator defined in section 9.9 of [<a href='#ref-ECMA-262'>ECMA-262</a>].
            </p>
            <p>
              If a host object returns an <span class='idltype'>Object</span> that is null,
              then the ECMAScript <span class='estype'>null</span> value must be returned.
              Otherwise, an ECMAScript <span class='estype'>Object</span> value must be returned.
            </p>
          </div>

          <div id='type-sequence' class='section'>
            <h4>sequence&lt;<var>T</var>&gt;</h4>

            <p>
              Values passed to a host object that expects a
              <span class='idltype'>sequence&lt;<var>T</var>></span>
              must be objects with a <span class='prop'>length</span> property whose
              value is a non-negative integer <span class='estype'>Number</span> that indicates the number
              of elements in the sequence.  Such objects must return the element in
              the sequence at position <var>n</var> when their
              <span class='prop'>[[Get]]</span> internal method is invoked with
              <var>n</var> as its argument.  (An ECMAScript <span class='estype'>Array</span>
              is an object that matches this description.)  When the host object
              gets an element of the sequence using the <span class='prop'>[[Get]]</span> method,
              the returned value will first be handled according to the rules in this section
              for the type <var>T</var>.
            </p>
            <p>
              If a host object expecting a
              <span class='idltype'>sequence&lt;<var>T</var>></span>
              is passed a value which is not an object with a non-negative integer
              <span class='estype'>Number</span> <span class='prop'>length</span> property,
              a <span class='estype'>TypeError</span> exception must be thrown.
            </p>
            <p>
              Sequences are passed by reference.  If a reference to a sequence
              passed to a host object is kept (whether internally or as the
              value of an attribute), and the passed sequence is not an ECMAScript
              <span class='estype'>Array</span> object, the kept reference must
              be a newly created ECMAScript <span class='estype'>Array</span> object
              whose contents is the elements of the sequence.
            </p>
            <div class='example'>
              <p>
                The following IDL and ECMAScript code fragments illustrates how
                sequences are handled:
              </p>
              <x:codeblock language='idl'>typedef sequence&lt;unsigned short> Integers;

[Constructor]
interface LotteryResults {
  attribute Integers numbers;
};</x:codeblock>
              <x:codeblock language='es'>var results = new LotteryResults();  // results is a new host object implementing the LotteryResults interface.
var a = [4, 8, 15, 16, 23, 42];      // An object that can serve as a sequence&lt;unsigned short>.

results.numbers = a;                 // Assign the sequence.
a[0] = 5;                            // Change the array.
results.numbers[0];                  // Evaluates to 5, since results.numbers is a reference to 'a'.</x:codeblock>
            </div>
            <div class='ednote'>
              <p>
                Originally I had it use pass-by-value semantics, where passing
                sequences would pass a copy, but I changed it to pass-by-reference
                so that it could be used usefully for array-like things.
              </p>
            </div>
          </div>

          <div id='type-sequence-octet' class='section'>
            <h4>sequence&lt;octet&gt;</h4>

            <p>
              As a special case, a <span class='idltype'>sequence&lt;octet></span>
              is represented by an ECMAScript <span class='estype'>String</span>
              value.
            </p>
            <p>
              Values passed to a host object that expects a <span class='idltype'>sequence&lt;octet></span>
              value will first be converted to an ECMAScript <span class='estype'>String</span> value
              by the ToString operator defined in section 9.8 of [<a href='#ref-ECMA-262'>ECMA-262</a>].
            </p>
            <p>
              <span class='idltype'>sequence&lt;octet></span> values returned from a host object
              must be ECMAScript <span class='estype'>String</span> values.
            </p>
          </div>

          <div id='type-boxed-valuetype' class='section'>
            <h4>Boxed valuetypes</h4>

            <p>
              A boxed valuetype is represented by either the ECMAScript type corresponding to the
              IDL type being boxed, or the ECMAScript <span class='esvalue'>null</span> value.
            </p>
            <p>
              If a host object that expects a boxed valuetype that is not annotated with
              the <a class='xattr' href='#NoNull'>[NoNull]</a> extended attribute is passed the
              <span class='esvalue'>null</span> value, then that value is passed
              without modification.  However, if the <a class='xattr' href='#NoNull'>[NoNull]</a>
              extended attribute does apply and the <span class='esvalue'>null</span> value
              is passed to the host object, the behavior depends on the type being boxed.
              If the type being boxed is <span class='idltype'>sequence&lt;octet></span>,
              then the ECMAScript <span class='estype'>String</span> <span class='esstring'>"null"</span> is passed to
              the host object.  If the type being boxed is anything else, the behavior
              is implementation specific.
            </p>
            <p>
              If a host object that expects a boxed valuetype is passed an
              ECMAScript <span class='estype'>Object</span> value, the value
              will first be handled according to the rules in this section
              corresponding to the IDL type being boxed.
            </p>
            <p>
              If a host object returns a boxed valuetype that is null, then the
              ECMAScript <span class='estype'>null</span> value must be returned.
              If the operation or attribute is annotated with the
              <a class='xattr' href='#NoNull'>[NoNull]</a> extended attribute, the host
              object must not return <span class='estype'>null</span>.  If the value returned is not null,
              it must be handled according to the rules in
              this section corresponding to the IDL type being boxed.
            </p>

            <div class='ednote'>
              <p>
                Perhaps there should be an example here for the real-world case that boxed
                valuetypes are actually used for (DOMString).
              </p>
            </div>
          </div>

          <!--div id='type-array' class='section'>
            <h4>Arrays</h4>

            <div class='ednote'>
              <p>
                This definition of arrays is incompatible with OMG IDL in two ways.
                First, OMG IDL allows only fixed size arrays to be used (for dynamic
                sized arrays, you need to use sequences).  Omitting the array size
                is syntactically incompatible.  Second, OMG IDL uses pass-by-value
                semantics for arrays (and sequences).  Thus things like
              </p>
            </div>
            <p>

            </p>
          </div-->
        </div>

        <div id='interfaces' class='section'>
          <h3>Interfaces</h3>

          <p>
            Every interface corresponds to a property on the global object,
            whose name is the same as its identifier in the IDL.  This identifier
            is not the qualified name of the interface, but the final
            <a class='nt' href='#prod-Identifier'>Identifier</a> in a derivation
            of the <a class='nt' href='#prod-ScopedName'>ScopedName</a>
            production that forms the complete qualified name.
            The value of this property is an object called the
            <dfn>interface object</dfn>, which provides access to the constants
            and functions defined on the interface.  The property has the
            attributes <span class='propattrset'>{ DontDelete, DontEnum }</span>.
          </p>
          
          <div id='interface-object' class='section'>
            <h4>Interface object</h4>

            <p>
              The interface object for a particular interface has an internal
              <span class='prop'>[[Prototype]]</span> object whose value is
              the <span class='esvalue'>Object</span> prototype object.
            </p>
            <p>
              In addition, there is a property on the interface object for each
              constant defined on the interface with the same name as that constant.
              These properties have the attributes
              <span class='propattrset'>{ DontDelete }</span>.
            </p>
            <p>
              If the interface is declared with the
              <a class='xattr' href='#Constructor'>[Constructor]</a> extended attribute,
              then the interface object also has a
              <span class='prop'>[[Construct]]</span> internal property, which allows
              construction of objects that implement the given interface.  The behavior
              of this <span class='prop'>[[Construct]]</span> method is not
              necessarily the same as that described for <span class='estype'>Function</span> objects in
              section 13.2.2 of <a href='#ref-ECMA-262'>[ECMA-262]</a>.
            </p>
            <p>
              The interface object also has a property named
              <span class='prop'>prototype</span> with attributes
              <span class='propattrset'>{ DontDelete, ReadOnly }</span>
              whose value is an object called the <dfn>interface prototype
                object</dfn>.  This object provides access to the functions
              that correspond to the operations defined on the interface.
            </p>

            <div id='hasinstance' class='section'>
              <h5>[[HasInstance]] method</h5>

              <p>
                The internal <span class='prop'>[[HasInstance]]</span> method of every
                interface object <var>I</var> behaves, assuming <var>V</var> is the object
                argument passed to <span class='prop'>[[HasInstance]]</span>, as follows:
              </p>
              <ol class='algorithm'>
                <li>If <var>V</var> is not an object, return <span class='esvalue'>false</span>.</li>
                <li>Call the <span class='prop'>[[Get]]</span> method of <var>I</var> with property name <span class='esstring'>"prototype"</span>.</li>
                <li>Let <var>O</var> be Result(2).</li>
                <li>If <var>O</var> is not an object, throw a <span class='estype'>TypeError</span> exception.</li>
                <li>If <var>V</var> is a host object that implements the
                  interface for which <var>O</var> is the interface prototype object,
                  return <span class='esvalue'>true</span>.</li>
                <li>Let <var>V</var> be the value of the <span class='prop'>[[Prototype]]</span> property of <var>V</var>.</li>
                <li>If <var>V</var> is <span class='esvalue'>null</span>, return <span class='esvalue'>false</span>.</li>
                <li>If <var>O</var> and <var>V</var> refer to the same object or if they refer to objects joined to each other (see section 13.1.2 of <a href='#ref-ECMA-262'>[ECMA-262]</a>),
                  return <span class='esvalue'>true</span>.</li>
                <li>Go to step 6.</li>
              </ol>
            </div>
          </div>

          <div id='interface-prototype-object' class='section'>
            <h4>Interface prototype object</h4>

            <p>
              The interface prototype object for a particular interface has
              properties that correspond to the operations defined on that
              interface.  Each such property has attribute
              <span class='propattrset'>{ DontEnum }</span>.  These properties
              are described in more detail in
              <a href='#operations'>section <?sref operations?></a> below.
            </p>
            <p>
              If the interface is declared with the
              <a class='xattr' href='#Constructor'>[Constructor]</a> extended
              attribute, the interface prototype object also has a property
              named <span class='prop'>constructor</span> with attribute
              <span class='propattrset'>{ DontEnum }</span> whose value
              is a reference to the interface object for the interface.
            </p>
            <div class='ednote'>
              <p>
                Haven’t checked what attributes browsers use on the 
                <span class='prop'>constructor</span> property.
              </p>
              <p>
                Also, should the <span class='prop'>constructor</span> property
                exist even for non-constructable objects?
              </p>
              <p>
                Constants should be in here as well as in the interface object.
              </p>
            </div>
            <p>
              No particular value must be used for the internal
              <span class='prop'>[[Prototype]]</span> property of the
              interface prototype object.  However, it must be an object
              that provides access to the properties defined on all
              superinterfaces of the interfaces.  Changes made to
              the interface prototype objects of superinterfaces must be
              reflected through this object.  If more than one superinterface
              has a given property, it is implementation specific which
              one is accessed.
            </p>
            <div id='interface-prototype-object-example' class='example'>
              <p>
                Assume the following IDL:
              </p>
              <x:codeblock language='idl'>interface A {
  void f();
};

interface B {
  void g();
};

interface C : A, B {
  void f();
};

interface D : C {
  void h();
};</x:codeblock>
              <p>
                The following is one way for an implementation to set up
                the prototype chain for the interface objects:
              </p>
              <ul>
                <li>
                  The <span class='prop'>[[Prototype]]</span> internal property
                  of the interface prototype objects for <span class='idltype'>A</span>
                  and <span class='idltype'>B</span> is the
                  <span class='prop'>Object</span> prototype object, since
                  neither of these interfaces has a superinterface.
                </li>
                <li>
                  The <span class='prop'>[[Get]]</span>,
                  <span class='prop'>[[CanPut]]</span> and
                  <span class='prop'>[[HasProperty]]</span> internal methods of the
                  interface prototype object for <span class='idltype'>A</span>
                  are the standard ones defined in section 8.6.2 of
                  <a href='#ref-ECMA-262'>[ECMA-262]</a>.
                </li>
                <li>
                  The <span class='prop'>[[Prototype]]</span> internal prototype
                  of the interface prototype object for <span class='idltype'>C</span>
                  is <span class='esvalue'>null</span>.
                </li>
                <li>
                  The <span class='prop'>[[Get]]</span> internal method
                  of the interface prototype object for <span class='idltype'>C</span>
                  behaves as follows (where <var>O</var> is the object and
                  <var>P</var> is the property name):
                  <ol class='algorithm'>
                    <li>
                      If <var>O</var> doesn’t have a property with name
                      <var>P</var>, go to step 4.
                    </li>
                    <li>Get the value of the property.</li>
                    <li>Return Result(2).</li>
                    <li>
                      Call the <span class='prop'>[[HasProperty]]</span> method
                      of the interface prototype object for
                      <span class='idltype'>A</span> with property name <var>P</var>.
                    </li>
                    <li>
                      If Result(4) is <span class='esvalue'>false</span>, go to
                      step 8.
                    </li>
                    <li>
                      Call the <span class='prop'>[[Get]]</span> method of the
                      interface prototype object for <span class='idltype'>A</span>
                      with property name <var>P</var>.
                    </li>
                    <li>Return Result(6).</li>
                    <li>
                      Call the <span class='prop'>[[HasProperty]]</span> method
                      of the interface prototype object for
                      <span class='idltype'>B</span> with property name <var>P</var>.
                    </li>
                    <li>
                      If Result(8) is <span class='esvalue'>false</span>, go to
                      step 12.
                    </li>
                    <li>
                      Call the <span class='prop'>[[Get]]</span> method of the
                      interface prototype object for <span class='idltype'>B</span>
                      with property name <var>P</var>.
                    </li>
                    <li>Return Result(10).</li>
                    <li>Return <span class='esvalue'>undefined</span>.</li>
                  </ol>
                </li>
                <li>
                  The <span class='prop'>[[CanPut]]</span> internal method
                  of the interface prototype object for <span class='idltype'>C</span>
                  behaves as follows (where <var>O</var> is the object and
                  <var>P</var> is the property name):
                  <ol class='algorithm'>
                    <li>
                      If <var>O</var> doesn’t have a property with name <var>P</var>,
                      go to step 4.
                    </li>
                    <li>If the property has the ReadOnly attribute, return <span class='esvalue'>false</span>.</li>
                    <li>Return <span class='esvalue'>true</span>.</li>
                    <li>
                      Call the <span class='prop'>[[CanPut]]</span> method of the
                      interface prototype object for <span class='idltype'>A</span>
                      with property name <var>P</var>.
                    </li>
                    <li>
                      If Result(4) is <span class='esvalue'>false</span>, return
                      <span class='esvalue'>false</span>.
                    </li>
                    <li>
                      Call the <span class='prop'>[[CanPut]]</span> method of the
                      interface prototype object for <span class='idltype'>B</span>
                      with property name <var>P</var>.
                    </li>
                    <li>
                      If Result(6) is <span class='esvalue'>false</span>, return
                      <span class='esvalue'>false</span>.
                    </li>
                    <li>Return <span class='esvalue'>true</span>.</li>
                  </ol>
                </li>
                <li>
                  The <span class='prop'>[[HasProperty]]</span> internal method
                  of the interface prototype object for <span class='idltype'>C</span>
                  behaves as follows (where <var>O</var> is the object and
                  <var>P</var> is the property name):
                  <ol class='algorithm'>
                    <li>
                      If <var>O</var> has a property with name <var>P</var>,
                      return <span class='esvalue'>true</span>.
                    </li>
                    <li>
                      Call the <span class='prop'>[[HasProperty]]</span> method of the
                      interface prototype object for <span class='idltype'>A</span>
                      with property name <var>P</var>.
                    </li>
                    <li>
                      If Result(3) is <span class='esvalue'>true</span>, return
                      <span class='esvalue'>true</span>.
                    </li>
                    <li>
                      Call the <span class='prop'>[[HasProperty]]</span> method of the
                      interface prototype object for <span class='idltype'>B</span>
                      with property name <var>P</var>.
                    </li>
                    <li>
                      If Result(5) is <span class='esvalue'>true</span>, return
                      <span class='esvalue'>true</span>.
                    </li>
                    <li>Return <span class='esvalue'>false</span>.</li>
                  </ol>
                </li>
                <li>
                  The <span class='prop'>[[Prototype]]</span> internal property
                  of the interface prototype object for <span class='idltype'>D</span>
                  is the interface prototype object for <span class='idltype'>C</span>,
                  since <span class='idltype'>D</span> has only a single superinterface.
                </li>
                <li>
                  The <span class='prop'>[[Get]]</span>,
                  <span class='prop'>[[CanPut]]</span> and
                  <span class='prop'>[[HasProperty]]</span> internal methods of the
                  interface prototype object for <span class='idltype'>D</span>
                  are the standard ones defined in section 8.6.2 of
                  <a href='#ref-ECMA-262'>[ECMA-262]</a>.
                </li>
              </ul>
            </div>
            <div class='ednote'>
              <p>
                Should the prototype chain and internal methods given in the
                example above be mandated, or just left as an example of how
                to do it?
              </p>
            </div>
          </div>

          <div id='operations' class='section'>
            <h4>Operations</h4>

            <p>
              In order to describe how properties on the interface prototype
              object corresponding to operations are chosen in the presence of
              overloading, the notion of potential ambiguity is first defined.
              Two operations on an interface, <var>O</var><sub>1</sub> and
              <var>O</var><sub>2</sub>, are
              <dfn id='dfn-potentially-ambiguous'>potentially ambiguous</dfn> if
              the following algorithm returns true:
            </p>
            <ol class='algorithm'>
              <li>…</li>
              <!--
              <li>
                Let <var>variadic1</var> be whether <var>op1</var>
                is declared with an argument with the
                <a class='xattr' href='#Variadic'>[Variadic]</a> extended
                attribute.
              </li>
              <li>
                Let <var>variadic2</var> be whether <var>op1</var>
                is declared with an argument with the
                <a class='xattr' href='#Variadic'>[Variadic]</a> extended
                attribute.
              </li>
              <li>
                Let <var>arity1</var> be the number of arguments
                without the <a class='xattr' href='#Variadic'>[Variadic]</a>
                extended attribute that <var>op1</var> is declared with.
              </li>
              <li>
                Let <var>arity2</var> be the number of arguments
                without the <a class='xattr' href='#Variadic'>[Variadic]</a>
                extended attribute that <var>op2</var> is declared with.
              </li>
              <li>Initialize <var>i</var> = 0.</li>
              <li>
                While <var>i</var> &lt; <var>arity1</var> and <var>i</var>
                &lt; <var>arity2</var>:
                <ol>
                  <li>
                    Let <var>type1</var> be the type of the argument
                    <var>op1</var> is declared with at position
                    <var>i</var>.
                  </li>
                  <li>
                    Let <var>type2</var> be the type of the argument
                    <var>op2</var> is declared with at position
                    <var>i</var>.
                  </li>
                  <li>
                    If none of the following statements about
                    <var>type1</var> and <var>type2</var> are true,
                    then return false:
                    <ul>
                      <li>
                        Both <var>type1</var> and <var>type2</var>
                        are one of the numeric types
                        (<span class='idltype'>octet</span>,
                        <span class='idltype'>short</span>,
                        <span class='idltype'>unsigned short</span>,
                        <span class='idltype'>long</span>,
                        <span class='idltype'>unsigned long</span>,
                        <span class='idltype'>long long</span>,
                        <span class='idltype'>unsigned long long</span> and
                        <span class='idltype'>float</span>).
                      </li>
                      <li>
                        Both <var>type1</var> and <var>type2</var>
                        are <span class='idltype'>boolean</span>.
                      </li>
                      <li>
                        …
                      </li>
                    </ul>
                  </li>
                </ol>
              </li>
              -->
            </ol>
            <div class='ednote'>
              <p>
                A useful way to handle method overloading is not obvious.
              </p>
              <p>
                Three patterns of overloading seem to be desired, at least.
                The first is overloading to handle optional arguments, such
                as with XMLHttpRequest’s open method.  Handling this is
                reasonably simple.
              </p>
              <p>
                The second is distinguishing based on argument type, where
                the values of those types do not intersect.  XHR’s send
                method is an example of this, where there are two versions
                that take an argument: one a DOMString, the other a Document.
                It’s impossible for a non-null value to be both a DOMString
                and a Document, so distinguishing these at run time seems fine.
                It would be ambiguous for null though.  This could be avoided
                by, say, putting a [NoNull] extended attribute on one of those
                arguments, which would mean that the other method is invoked
                when null is passed.
              </p>
              <p>
                The third is distinguishing based on argument type, where
                the values of those types do intersect.  This can be seen
                with the createPattern methods on HTML 5’s CanvasRenderingContext2D
                interface, which are currently defined as:
              </p>
              <x:codeblock language='idl'>interface CanvasRenderingContext2D {
  …
  CanvasPattern createPattern(in HTMLImageElement image, DOMString repetition);
  CanvasPattern createPattern(in HTMLCanvasElement image, DOMString repetition);
  …
};</x:codeblock>
              <p>
                While in a normal web browser environment there’ll be no
                object that implements both HTMLImageElement and
                HTMLCanvasElement, in the general case objects can implement
                more than one interface.  To disallow overloading like this
                for all languages seems excessive, since there are languages
                that can handle this sort of things (e.g. C++ will allow calls
                to createPattern as long as it’s not ambiguous based on the
                type of the value being passed, or the ambiguity can be
                resolved explicitly).  Perhaps some sort of declaration in the
                IDL that if the object does implement both interfaces, then
                one of the operations is preferred (or defaults to arbitrary
                selection by the UA).  It seems a little hacky, because there’d
                be no way to explicitly disambiguate the call as you can do
                in other languages.
              </p>
            </div>

            <p>
              The <dfn id='dfn-overload-set'>overload set</dfn> for an operation
              <var>O</var> is defined as follows:
            </p>
            <ul>
              <li>
                If <var>O</var> is not declared with an
                <a class='xattr' href='#Overloads'>[Overloads]</a> extended
                attribute, then the set is equal to the union of { <var>O</var> }
                and all other operations declared on the interface with the
                <a class='xattr' href='#Overloads'>[Overloads]</a> extended
                attribute whose argument is the name of <var>O</var>.
              </li>
              <li>
                Otherwise, if <var>O</var> is declared with an
                <a class='xattr' href='#Overloads'>[Overloads]</a> extended
                attribute with argument <var>N</var>, then the set is equal
                to the <a class='dfnref' href='#dfn-overload-set'>overload set</a>
                for the operation with identifier <var>N</var> declared on the
                interface.
              </li>
            </ul>
            <p>
              An operation <var>O</var> is a
              <dfn id='dfn-non-overloadable-operation'>non-overloadable operation</dfn>
              if it matches one of the following two criteria:
            </p>
            <ol>
              <li>
                The <a class='dfnref' href='#dfn-overload-set'>overload set</a>
                of <var>O</var> is equal to { <var>O</var> }.
              </li>
              <li>
                There exists two operations <var>O</var><sub>1</sub> and <var>O</var><sub>2</sub>
                in the <a class='dfnref' href='#dfn-overload-set'>overload set</a>
                for <var>O</var> such that <var>O</var><sub>1</sub> and <var>O</var><sub>2</sub> are
                <a class='dfnref' href='#dfn-potentially-ambiguous'>potentially
                  ambiguous</a>.
              </li>
            </ol>
            <p>
              An operation is an
              <dfn id='dfn-overloaded-operation'>overloaded operation</dfn> if
              it is not declared with an
              <a class='xattr' href='#Overloads'>[Overloads]</a> extended
              attribute and the cardinality of its
              <a class='dfnref' href='#dfn-overload-set'>overload set</a>
              is greater than 1.
            </p>
            <p>
              For each
              <a class='dfnref' href='#dfn-non-overloadable-operation'>non-overloadable
                operation</a> <var>O</var> defined on the interface, a property exists on the
              interface prototype object whose name is the name of the operation
              and whose value is a <span class='estype'>Function</span> object
              that behaves as follows:
            </p>
            <ol class='algorithm'>
              <li>
                Let <var>n</var> be the number of arguments passed to the
                function.
              </li>
              <li>
                Let <var>arity</var> be the number of arguments that <var>O</var>
                is declared with if the final argument does not have the
                <a class='xattr' href='#Variadic'>[Variadic]</a> extended
                attribute, or the number of arguments that <var>O</var> is
                declared with minus 1 otherwise.
              </li>
              <li>
                If <var>n</var> &lt; <var>arity</var>, an implementation
                specific exception is thrown and these steps are ended.
              </li>
              <li>
                Let <var>arg</var><sub>0‥<var>n</var>−1</sub> be the arguments passed to the
                function.
              </li>
              <li>Initialize <var>i</var> to 0.</li>
              <li>
                While <var>i</var> &lt; <var>arity</var>:
                <ol>
                  <li>
                    Convert <var>arg<sub>i</sub></var>, according to the
                    type of the formal argument in position <var>i</var>,
                    by following the relevant steps from
                    <a href='#type-mapping'>section <?sref type-mapping?></a>
                    above.
                  </li>
                  <li>
                    If the type of the formal argument in position <var>i</var>
                    is a boxed <span class='idltype'>sequence&lt;octet></span>
                    valuetype and is declared with the
                    <a class='xattr' href='#NoNull'>[NoNull]</a> extended
                    attribute, and <var>arg<sub>i</sub></var> is
                    <span class='esvalue'>null</span>, set
                    <var>arg<sub>i</sub></var> to the
                    <span class='estype'>String</span> value
                    <span class='esstring'>"null"</span>.
                  </li>
                  <li>
                    Set <var>i</var> to <var>i</var> + 1.
                  </li>
                </ol>
              </li>
              <li>
                Let <var>j</var> be <var>n</var>
                if the final argument of <var>O</var> is declared with the
                <a class='xattr' href='#Variadic'>[Variadic]</a> extended
                attribute, or <var>arity</var> otherwise.
              </li>
              <li>
                While <var>i</var> &lt; <var>j</var>:
                <ol>
                  <li>
                    Convert <var>arg<sub>i</sub></var>, according to the
                    type of the formal argument in position <var>arity</var> + 1,
                    by following the relevant steps from
                    <a href='#type-mapping'>section <?sref type-mapping?></a>
                    above.
                  </li>
                  <li>
                    If the type of the formal argument in position <var>arity</var> + 1
                    is a boxed <span class='idltype'>sequence&lt;octet></span>
                    valuetype and is declared with the
                    <a class='xattr' href='#NoNull'>[NoNull]</a> extended
                    attribute, and <var>arg<sub>i</sub></var> is
                    <span class='esvalue'>null</span>, set
                    <var>arg<sub>i</sub></var> to the
                    <span class='estype'>String</span> value
                    <span class='esstring'>"null"</span>.
                  </li>
                  <li>
                    Set <var>i</var> to <var>i</var> + 1.
                  </li>
                </ol>
              </li>
              <li>
                Perform the actions listed in the description of <var>O</var>
                with <var>arg</var><sub>0‥<var>j</var>−1</sub> as the
                argument values.
              </li>
            </ol>
            <p>
              For each
              <a class='dfnref' href='#dfn-overloaded-operation'>overloaded
                operation</a> defined on the interface, a property exists on the
              interface prototype object whose name is the name of the operation
              and whose value is a <span class='estype'>Function</span> object
              that behaves as follows:
            </p>
            <ol class='algorithm'>
              <li>…</li>
            </ol>
            <div class='ednote'>
              <p>
                This will be written once the overloading rules are more definite.
              </p>
            </div>
          </div>
        </div>

        <div id='host-objects' class='section'>
          <h3>Host objects implementing interfaces</h3>

          <p>
            A host object that implements a particular interface has properties
            that correspond to the attributes declared on that interface.  If the
            attribute is declared <code>readonly</code>, the corresponding property
            has attributes <span class='propattrset'>{ DontDelete, ReadOnly }</span>,
            while if it is not declared <code>readonly</code>, it is
            <span class='propattrset'>{ DontDelete }</span>.  If a host object
            implements more than one interface with an attribute of a given name,
            it is implementation specific which attribute the property corresponds to.
          </p>

          <p>
            No particular value must be used for the internal
            <span class='prop'>[[Prototype]]</span> property of the host object.
            However, it must be an object that provides access to the properties
            corresponding to the operations and constants defined on all
            interfaces the host object implements.  Changes made to the interface
            prototype objects of interfaces implemented by the host object must
            be reflected through this object.  If more than one interface prototype
            object has a given property, it is implementation specific which one
            is accessed.
          </p>

          <div class='example'>
            <p>
              Assume the IDL and interface prototype objects given in the
              <a href='#interface-prototype-object-example'>section
                <?sref interface-prototype-object?> example</a>.
            </p>
            <p>
              Now assume that <var>ab</var> is a host object that implements
              <span class='idltype'>A</span> and <span class='idltype'>B</span>
              and <var>d</var> is a host object that implements
              <span class='idltype'>D</span>.
              The following is one way for an implementation to connect the
              host objects to the interface prototype objects:
            </p>
            <ul>
              <li>
                The <span class='prop'>[[Prototype]]</span> internal property of
                the host object <var>ab</var> is an object that provides access
                to the properties from the interface prototype objects for both
                <span class='idltype'>A</span> and <span class='idltype'>B</span>:
                <ul>
                  <li>
                    The <span class='prop'>[[Prototype]]</span> internal property
                    of the <span class='prop'>[[Prototype]]</span> object for <var>ab</var>
                    is <span class='esvalue'>null</span>.
                  </li>
                  <li>
                    The <span class='prop'>[[Get]]</span> internal method
                    of the <span class='prop'>[[Prototype]]</span> object for <var>ab</var>
                    behaves as follows (where <var>O</var> is the object and
                    <var>P</var> is the property name):
                    <ol class='algorithm'>
                      <li>
                        If <var>O</var> doesn’t have a property with name
                        <var>P</var>, go to step 4.
                      </li>
                      <li>Get the value of the property.</li>
                      <li>Return Result(2).</li>
                      <li>
                        Call the <span class='prop'>[[HasProperty]]</span> method
                        of the interface prototype object for
                        <span class='idltype'>A</span> with property name <var>P</var>.
                      </li>
                      <li>
                        If Result(4) is <span class='esvalue'>false</span>, go to
                        step 8.
                      </li>
                      <li>
                        Call the <span class='prop'>[[Get]]</span> method of the
                        interface prototype object for <span class='idltype'>A</span>
                        with property name <var>P</var>.
                      </li>
                      <li>Return Result(6).</li>
                      <li>
                        Call the <span class='prop'>[[HasProperty]]</span> method
                        of the interface prototype object for
                        <span class='idltype'>B</span> with property name <var>P</var>.
                      </li>
                      <li>
                        If Result(8) is <span class='esvalue'>false</span>, go to
                        step 12.
                      </li>
                      <li>
                        Call the <span class='prop'>[[Get]]</span> method of the
                        interface prototype object for <span class='idltype'>B</span>
                        with property name <var>P</var>.
                      </li>
                      <li>Return Result(10).</li>
                      <li>Return <span class='esvalue'>undefined</span>.</li>
                    </ol>
                  </li>
                  <li>
                    The <span class='prop'>[[CanPut]]</span> internal method
                    of the <span class='prop'>[[Prototype]]</span> object for <var>ab</var>
                    behaves as follows (where <var>O</var> is the object and
                    <var>P</var> is the property name):
                    <ol class='algorithm'>
                      <li>
                        If <var>O</var> doesn’t have a property with name <var>P</var>,
                        go to step 4.
                      </li>
                      <li>If the property has the ReadOnly attribute, return <span class='esvalue'>false</span>.</li>
                      <li>Return <span class='esvalue'>true</span>.</li>
                      <li>
                        Call the <span class='prop'>[[CanPut]]</span> method of the
                        interface prototype object for <span class='idltype'>A</span>
                        with property name <var>P</var>.
                      </li>
                      <li>
                        If Result(4) is <span class='esvalue'>false</span>, return
                        <span class='esvalue'>false</span>.
                      </li>
                      <li>
                        Call the <span class='prop'>[[CanPut]]</span> method of the
                        interface prototype object for <span class='idltype'>B</span>
                        with property name <var>P</var>.
                      </li>
                      <li>
                        If Result(6) is <span class='esvalue'>false</span>, return
                        <span class='esvalue'>false</span>.
                      </li>
                      <li>Return <span class='esvalue'>true</span>.</li>
                    </ol>
                    <p>
                      Note that this method shouldn’t strictly be required, since
                      there would be no way for script to get access to the
                      <span class='prop'>[[Prototype]]</span> object for <var>ab</var>.
                    </p>
                  </li>
                  <li>
                    The <span class='prop'>[[HasProperty]]</span> internal method
                    of the <span class='prop'>[[Prototype]]</span> object for <var>ab</var>
                    behaves as follows (where <var>O</var> is the object and
                    <var>P</var> is the property name):
                    <ol class='algorithm'>
                      <li>
                        If <var>O</var> has a property with name <var>P</var>,
                        return <span class='esvalue'>true</span>.
                      </li>
                      <li>
                        Call the <span class='prop'>[[HasProperty]]</span> method of the
                        interface prototype object for <span class='idltype'>A</span>
                        with property name <var>P</var>.
                      </li>
                      <li>
                        If Result(3) is <span class='esvalue'>true</span>, return
                        <span class='esvalue'>true</span>.
                      </li>
                      <li>
                        Call the <span class='prop'>[[HasProperty]]</span> method of the
                        interface prototype object for <span class='idltype'>B</span>
                        with property name <var>P</var>.
                      </li>
                      <li>
                        If Result(5) is <span class='esvalue'>true</span>, return
                        <span class='esvalue'>true</span>.
                      </li>
                      <li>Return <span class='esvalue'>false</span>.</li>
                    </ol>
                  </li>
                </ul>
              </li>
              <li>
                The <span class='prop'>[[Prototype]]</span> internal property of
                the host object <var>d</var> is the interface prototype object
                for <span class='idltype'>D</span>, since <span class='idltype'>D</span>
                is the only interface the object directly implements.
              </li>
            </ul>
          </div>

          <div id='get' class='section'>
            <h4>[[Get]] method</h4>

            <p>
              The internal <span class='prop'>[[Get]]</span> method of every
              host object <var>O</var> that implements at least one IDL interface
              behaves, assuming <var>P</var> is the property name passed to
              <span class='prop'>[[Get]]</span>, as follows:
            </p>
            <ol class='algorithm'>
              <li>
                Determine the name of a
                <a class='xattr' href='#IndexGetter'>[IndexGetter]</a>-annotated
                operation on the interfaces that <var>O</var> implements.
                If there is no such operation, go to step 7.
              </li>
              <li>Compute ToUint32(<var>P</var>).</li>
              <li>If Result(2) is not a non-negative integer, go to step 7.</li>
              <li>
                Invoke the <span class='prop'>[[Get]]</span> method of object <var>O</var> with Result(1)
                as the argument.
              </li>
              <li>
                Invoke the <span class='prop'>[[Call]]</span> method of Result(4), providing
                <var>O</var> as the <span class='esvalue'>this</span> value and
                Result(2) as the single argument value.
              </li>
              <li>Return Result(4).</li>
              <li>
                Determine the name of a
                <a class='xattr' href='#Getter'>[Getter]</a>-annotated operation
                on the interfaces that <var>O</var> implements.  If there is no
                such operation, go to step 13.
              </li>
              <li>
                Invoke the <span class='prop'>[[HasProperty]]</span> method of object <var>O</var> with
                <var>P</var> as the argument.
              </li>
              <li>
                If Result(7) is <span class='esvalue'>true</span>, go to step 13.
              </li>
              <li>
                Invoke the <span class='prop'>[[Get]]</span> method of object <var>O</var> with Result(6)
                as the argument.
              </li>
              <li>
                Invoke the <span class='prop'>[[Call]]</span> method of Result(9), providing
                <var>O</var> as the <span class='esvalue'>this</span> value and
                <var>P</var> as the single argument value.
              </li>
              <li>Return Result(10).</li>
              <li>
                If <var>O</var> doesn’t have a property with name <var>P</var>,
                go to step 16.
              </li>
              <li>Get the value of the property.</li>
              <li>Return Result(14).</li>
              <li>
                If the <span class='prop'>[[Prototype]]</span> of <var>O</var> is
                <span class='esvalue'>null</span>, return
                <span class='esvalue'>undefined</span>.
              </li>
              <li>
                Call the <span class='prop'>[[Get]]</span> method of <span class='prop'>[[Prototype]]</span> with property name
                <var>P</var>.
              </li>
              <li>Return Result(17).</li>
            </ol>
          </div>

          <div id='put' class='section'>
            <h4>[[Put]] method</h4>

            <p>
              The internal <span class='prop'><span class='prop'>[[Put]]</span></span> method of every
              host object <var>O</var> that implements at least one IDL interface
              behaves, assuming <var>P</var> is the property name and <var>V</var>
              is the property value passed to <span class='prop'><span class='prop'>[[Put]]</span></span>,
              as follows:
            </p>
            <ol class='algorithm'>
              <li>
                Determine the name of a
                <a class='xattr' href='#IndexSetter'>[IndexSetter]</a>-annotated
                operation on the interfaces that <var>O</var> implements.
                If there is no such operation, go to step 7.
              </li>
              <li>Compute ToUint32(<var>P</var>).</li>
              <li>If Result(2) is not a non-negative integer, go to step 7.</li>
              <li>
                Invoke the <span class='prop'>[[Get]]</span> method of object <var>O</var> with Result(1)
                as the argument.
              </li>
              <li>
                Invoke the <span class='prop'>[[Call]]</span> method of Result(4), providing
                <var>O</var> as the <span class='esvalue'>this</span> value and
                Result(2) and <var>V</var> as the two argument values.
              </li>
              <li>Return Result(4).</li>
              <li>
                Determine the name of a
                <a class='xattr' href='#Setter'>[Setter]</a>-annotated operation
                on the interfaces that <var>O</var> implements.  If there is no
                such operation, go to step 13.
              </li>
              <li>
                Invoke the <span class='prop'>[[HasProperty]]</span> method of object <var>O</var> with
                <var>P</var> as the argument.
              </li>
              <li>
                If Result(7) is <span class='esvalue'>true</span>, go to step 13.
              </li>
              <li>
                Invoke the <span class='prop'>[[Get]]</span> method of object <var>O</var> with Result(6)
                as the argument.
              </li>
              <li>
                Invoke the <span class='prop'>[[Call]]</span> method of Result(9), providing
                <var>O</var> as the <span class='esvalue'>this</span> value and
                <var>P</var> and <var>V</var> as the two argument values.
              </li>
              <li>Return Result(10).</li>
              <li>
                If <var>O</var> has a property with name <var>P</var> and that property does not correspond
                to an IDL operation declared <code>readonly</code>, then go to step 18.
              </li>
              <li>
                If the property on <var>O</var> with name <var>P</var> does not correspond
                to an IDL operation declared with a <a class='xattr' href='#PutForwards'>[PutForwards]</a>
                extended attribute, then an implementation specific exception is thrown and these steps
                are ended.
              </li>
              <li>
                Call the <span class='prop'>[[Get]]</span> method of <var>O</var> with name
                <var>P</var>.
              </li>
              <li>
                Call the <span class='prop'>[[Put]]</span> method of Result(15) with the property
                name being the argument to the <a class='xattr' href='#PutForwards'>[PutForwards]</a>
                extended attribute, and value <var>V</var>.
              </li>
              <li>Return.</li>

              <li>
                Call the <span class='prop'>[[CanPut]]</span> method of <var>O</var> with name
                <var>P</var>.
              </li>
              <li>
                If Result(18) is <span class='esvalue'>false</span>,
                return.
              </li>
              <li>
                If <var>O</var> doesn’t have a property with name <var>P</var>,
                go to step 23.
              </li>

              <li>
                Set the value of the property to <var>V</var>.  The attributes
                of the property are not changed.
              </li>
              <li>Return.</li>
              <li>
                Create a property with name <var>P</var>, set its value to
                <var>V</var> and give it empty attributes.
              </li>
              <li>Return.</li>
            </ol>
          </div>

          <!--
          <div id='delete' class='section'>
            <h4>[[Delete]] method</h4>
            <p>
              The internal <span class='prop'><span class='prop'>[[Delete]]</span></span> method of every
              host object <var>O</var> that implements at least one IDL interface
              behaves, assuming <var>P</var> is the name of the property
              passed to <span class='prop'><span class='prop'>[[Delete]]</span></span>,
              as follows:
            </p>
            <ol class='algorithm'>
            </ol>
          </div>
          -->
        </div>

        <div id='native-objects' class='section'>
          <h3>Native objects implementing interfaces</h3>

          <p>
            A native ECMAScript object is considered to implement a particular
            interface if it has a property corresponding to each operation
            on that interface whose value is a <span class='estype'>Function</span>
            object.  The rules for which operations correspond to properties
            in the presence of overloaded operations is the same as described
            for host objects in <a href='#operations'>section <?sref operations?></a>
            above.
          </p>
          <div class='ednote'>
            <p>
              How operations correspond to attributes on native objects
              could be fleshed out about, rather than just refering to the
              host object Operations section earlier.
            </p>
          </div>
          <p>
            Note that if the interface has attributes declared on it, properties
            are not required to be currently on the native object.
            Since native objects cannot have properties with attributes (such as
            ReadOnly), a property that does exist on the object that corresponds
            to a <code>readonly</code> attribute declared on the interface
            does not have to be read-only.
          </p>
          <p>
            Since native objects cannot have custom internal properties,
            such objects implementing the interface are not required to honor the
            <a class='xattr' href='#IndexGetter'>[[IndexGetter]]</a>,
            <a class='xattr' href='#IndexSetter'>[[IndexSetter]]</a>,
            <a class='xattr' href='#NameGetter'>[[NameGetter]]</a>,
            <a class='xattr' href='#NameSetter'>[[NameSetter]]</a> or
            <a class='xattr' href='#PutForwards'>[[PutForwards]]</a>
            extended attributes.
          </p>
          <p>
            As a special case, a <span class='estype'>Function</span> object
            <var>F</var> is considered to implement an interface if that interface is
            declared with exactly one operation.  The function itself is
            the implementation of the operation.  If the
            <span class='estype'>Function</span> object also has a property
            <var>P</var> whose name is the name of the operation and whose
            value is a <span class='estype'>Function</span> object, then
            that <var>P</var> is used as the implementation of the operation
            rather than <var>F</var>.
          </p>
        </div>
      </div>

      <div id='conformance' class='section'>
        <h2>Conformance</h2>

        <div class='ednote'>
          <p>Two conformance classes: conforming IDL, conforming UA w.r.t. some IDL.</p>
        </div>
      </div>

      <div id='acknowledgements' class='section'>
        <h2>Acknowledgements</h2>

        <p>
          The editor would like to thank the following people for contributing
          to this specification:
          David Andersson,
          Robin Berjon,
          Gorm Haug Eriksen,
          Ian Hickson,
          Björn Höhrmann,
          Anne van Kesteren,
          Jonas Sicking,
          Maciej Stachowiak,
          Boris Zbarsky.
        </p>
      </div>
    </div>

    <div id='appendices'>
      <div id='idl-grammar' class='section'>
        <h2>IDL grammar</h2>

        <p>
          This section defines an LL(1) grammar whose start symbol,
          <a class='nt' href='#prod-Definitions'>Definitions</a>, matches an
          entire IDL fragment.
        </p>

        <p>
          Each production in the grammar has on its right hand side either a
          non-zero sequence of terminal and non-terminal symbols, or an
          epsilon (ε) which indicates no symbols.  Symbols that begin with
          an uppercase letter are non-terminal symbols.  Symbols within quotes
          are terminal symbols that are matched with the exact text between
          the quotes.  Symbols that begin with a lowercase letter are terminal
          symbols that are matched by the regular expressions (using Perl 5 regular
          expression syntax [<a href='#ref-PERLRE'>PERLRE</a>]) as follows:
        </p>
        <table class='grammar'>
          <tr>
            <td id='prod-integer' class='nt'>integer</td>
            <td>=</td>
            <td class='regex'>-?0([0-7]*|[Xx][0-9A-Fa-f]+)|[1-9][0-9]*</td>
          </tr>
          <tr>
            <td id='prod-float' class='nt'>float</td>
            <td>=</td>
            <td class='regex'>-?([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+</td>
          </tr>
          <tr>
            <td id='prod-identifier' class='nt'>identifier</td>
            <td>=</td>
            <td class='regex'>[A-Z_a-z][0-9A-Z_a-z]*</td>
          </tr>
          <tr>
            <td id='prod-whitespace' class='nt'>whitespace</td>
            <td>=</td>
            <td class='regex'>[\t\n\r ]+|[\t\n\r ]*((//.*|/\*.*?\*/)[\t\n\r ]*)+</td>
          </tr>
        </table>

        <div class='ednote'>
          <p>
            Should we require quoting (with an underscore) of identifiers that would match
            keywords used in OMG IDL 3.0 but not in this IDL?
          </p>
        </div>

        <p>
          When tokenizing, the longest possible match must be used.  For example, if the input
          text is “<tt>a1</tt>”, it should be tokenized as a single <span class='terminal'>identifier</span>,
          and not as a separate <span class='terminal'>identifier</span> and <span class='terminal'>integer</span>.
          If the longest possible match could match both an <span class='terminal'>identifier</span> and
          one of the quoted terminal symbols from the grammar, it must be tokenized as the quoted
          terminal symbol.  Thus, the input text “<tt>in</tt>” is tokenized as the quoted terminal symbol
          <span class='terminal'>"in"</span> rather than an <span class='terminal'>identifier</span> called “in”.
        </p>

        <p>
          Implicitly, the <span class='terminal'>whitespace</span> terminal is allowed between every terminal
          in the input text being parsed.  Such <span class='terminal'>whitespace</span> terminals, which
          actually encompass both whitespace and comments, are ignored while parsing.
        </p>

        <p>
          The following LL(1) grammar matches an IDL fragment:
        </p>

        <grammar id='grammar' xmlns='http://mcc.id.au/ns/local'>
          <prod nt='Definitions'>ExtendedAttributeList Definition Definitions | ε</prod>
          <prod nt='Definition'>Module | Interface | Exception | Typedef | Valuetype | Const</prod>
          <prod nt='Module'>"module" identifier "{" Definitions "}" ";"</prod>
          <prod nt='Interface'>"interface" identifier InterfaceBody ";"</prod>
          <prod nt='InterfaceInheritance'>":" ScopedNameList | ε</prod>
          <prod nt='InterfaceBody'>InterfaceInheritance "{" InterfaceMembers "}" | ε</prod>
          <prod nt='InterfaceMembers'>ExtendedAttributeList InterfaceMember InterfaceMembers | ε</prod>
          <prod nt='InterfaceMember'>Const | Attribute | Operation</prod>
          <prod nt='Exception'>"exception" identifier "{" ExceptionMembers "}" ";"</prod>
          <prod nt='ExceptionMembers'>ExtendedAttributeList ExceptionMember ExceptionMembers | ε</prod>
          <prod nt='Typedef'>"typedef" Type identifier ";"</prod>
          <prod nt='Valuetype'>"valuetype" identifier Type ";"</prod>
          <prod nt='Const'>"const" Type identifier '=' ConstExpr ";"</prod>
          <prod nt='ConstExpr'>BooleanLiteral | integer | float</prod>
          <prod nt='BooleanLiteral'>"TRUE" | "FALSE"</prod>
          <prod nt='Attribute'>ReadOnly "attribute" Type identifier GetRaises SetRaises ";"</prod>
          <prod nt='ReadOnly'>"readonly" | ε</prod>
          <prod nt='GetRaises'>"getraises" ExceptionList | ε</prod>
          <prod nt='SetRaises'>"setraises" ExceptionList | ε</prod>
          <prod nt='Operation'>ReturnType identifier "(" ArgumentList ")" Raises ";"</prod>
          <prod nt='Raises'>"raises" ExceptionList | ε</prod>
          <prod nt='ExceptionList'>"(" ScopedName Exceptions ")"</prod>
          <prod nt='Exceptions'>"," ScopedName Exceptions | ε</prod>
          <prod nt='ArgumentList'>Argument Arguments | ε</prod>
          <prod nt='Arguments'>"," Argument Arguments | ε</prod>
          <prod nt='Argument'>ExtendedAttributeList "in" Type identifier</prod>
          <prod nt='ExceptionMember'>Type identifier ";"</prod>
          <prod nt='ExtendedAttributeList'>"[" ExtendedAttribute ExtendedAttributes "]"</prod>
          <prod nt='ExtendedAttributes'>"," ExtendedAttribute ExtendedAttributes | ε</prod>
          <prod nt='ExtendedAttribute'>identifier ExtendedAttributeAssignment</prod>
          <prod nt='ExtendedAttributeAssignment'>"=" ExtendedAttributeArgument | ε</prod>
          <prod nt='ExtendedAttributeArgument'>identifier</prod>
          <prod nt='Type'>UnsignedIntegerType | ScopedName | "any" | "boolean" | "octet" | "float" | "Object" | "sequence" "&lt;" Type ">"</prod>
          <prod nt='UnsignedIntegerType'>"unsigned" IntegerType | IntegerType</prod>
          <prod nt='IntegerType'>"short" | "long" OptionalLong</prod>
          <prod nt='OptionalLong'>"long" | ε</prod>
          <prod nt='ReturnType'>Type | "void"</prod>
          <prod nt='ScopedNameList'>ScopedName ScopedNames</prod>
          <prod nt='ScopedNames'>"," ScopedName ScopedNames | ε</prod>
          <prod nt='ScopedName'>"::" identifier ScopedNameParts | identifier ScopedNameParts</prod>
          <prod nt='ScopedNameParts'>"::" identifier ScopedNameParts | ε</prod>

          <!--prod nt='Keyword'>"any" | "attribute" | "boolean" | "const" | "exception" | "float" | "getraises" | "in" | "interface" | "long" | "module" | "Object" | "octet" | "raises" | "readonly" | "sequence" | "setraises" | "short" | "typedef" | "unsigned | "void"</prod-->
          <!-- the following are the remaining OMG IDL 3 keywords:
          "abstract" |
          "case" |
          "char" |
          "component" |
          "consumes" |
          "context" |
          "custom" |
          "default" |
          "double" |
          "emits" |
          "enum" |
          "eventtype" |
          "factory" |
          "FALSE" |
          "finder" |
          "fixed" |
          "home" |
          "inout" |
          "local" |
          "multiple" |
          "native" |
          "oneway" |
          "out" |
          "primarykey" |
          "private" |
          "provides" |
          "public" |
          "publishes" |
          "string" |
          "struct" |
          "supports" |
          "switch" |
          "TRUE" |
          "truncatable" |
          "typeid" |
          "typeprefix" |
          "union" |
          "uses" |
          "ValueBase" |
          "wchar" |
          "wstring"
          -->
        </grammar>

        <div class='ednote'>
          <p>
            Still not sure how we should handle extensibility of extended attributes.
          </p>
        </div>
      </div>

      <div id='references' class='section'>
        <h2>References</h2>

        <dl>
          <dt id='ref-ECMA-262'>[ECMA-262]</dt>
          <dd>
            <cite><a href='http://www.ecma-international.org/publications/standards/Ecma-262.htm'>ECMAScript Language Specification, 3rd Edition</a></cite>,
            M. Cowlishaw, Editor.  Ecma International, December 1999.  Available at http://www.ecma-international.org/publications/standards/Ecma-262.htm.
          </dd>
          <dt id='ref-OMGIDL'>[OMGIDL]</dt>
          <dd>
            <cite><a href='http://www.omg.org/cgi-bin/apps/doc?formal/02-06-39.pdf'>CORBA 3.0 – OMG IDL Syntax and Semantics chapter</a></cite>.
            Object Management Group, June 2002.  Available at http://www.omg.org/cgi-bin/apps/doc?formal/02-06-39.pdf.
          </dd>
          <dt id='ref-PERLRE'>[PERLRE]</dt>
          <dd>
            <cite><a href='http://search.cpan.org/dist/perl/pod/perlre.pod'>Perl regular expressions (Perl 5.8.8)</a></cite>.
            The Perl Foundation, February 2006.  Available at http://www.perl.com/doc/manual/html/pod/perlre.html.
          </dd>
        </dl>
      </div>
    </div>
  </body>
</html>
