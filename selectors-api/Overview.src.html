<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en-US">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<title>Selectors API</title>
	<style type="text/css">
	pre.idl { border:solid thin; background:#eee; color:#000; padding:0.5em }

	pre.idl :link, pre.idl :visited { color:inherit; background:transparent }
	div.example { border-left:double; padding-left:1em }
	dfn { font-style:normal; font-weight:bolder }
	em.ct { font-style:normal; font-weight:normal; font-variant:small-caps }
	p.note {  margin-left:2em; color:green; font-style:italic; font-weight:bold }
	p.note:before { content:"Note: " }
	.issue { padding:.5em; border:solid red }
	.issue:before { content:"Issue: " }
	code { color:#FF4500; }
	code :link, code :visited { color:inherit }
	</style>
	<link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/base.css">
	<link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-ED">
</head>
<body>
	<div class="head">
		<p><a href="http://www.w3.org/"><img height="48" width="72" alt="W3C" src="http://www.w3.org/Icons/w3c_home"></a></p>
		<h1 id="title">Selectors API</h1>
		<!-- "DOM Selectors" was not acceptable. "DOM Level 4 Selectors" and
		conforming to the DOM specification template (if there is such a thing) is
		just silly so we got stuck with this weird name. -->

		<h2 class="no-num no-toc" id="W3C-doctype">W3C Working Draft [DATE: 3 August 2002]</h2>
		<dl>
			<dt>This Version:</dt>
			<dd><a href="[VERSION]/">http://www.w3.org/TR/[YEAR]/ED-selectors-api-[CDATE]/</a></dd>

			<dt>Latest Version:</dt>
			<dd><a href="http://www.w3.org/TR/selectors-api/">http://www.w3.org/TR/selectors-api/</a></dd>

			<dt>Previous Versions:</dt>
			<dd><a href="http://www.w3.org/TR/2007/WD-selectors-api-20071221/">http://www.w3.org/TR/2007/WD-selectors-api-20071221/</a></dd>
			<dd><a href="http://www.w3.org/TR/2007/WD-selectors-api-20071019/">http://www.w3.org/TR/2007/WD-selectors-api-20071019/</a></dd>
			<dd><a href="http://www.w3.org/TR/2006/WD-selectors-api-20060926/">http://www.w3.org/TR/2006/WD-selectors-api-20060926/</a></dd>
			<dd><a href="http://www.w3.org/TR/2006/WD-selectors-api-20060525/">http://www.w3.org/TR/2006/WD-selectors-api-20060525/</a></dd>

			<dt>Editors:</dt>
			<dd><a href="http://lachy.id.au/">Lachlan Hunt</a>
			    (<a href="http://www.opera.com/">Opera Software ASA</a>)
			    &lt;<a href="mailto:lachlan.hunt@lachy.id.au">lachlan.hunt@lachy.id.au</a>&gt;</dd>
			<dd><a href="http://annevankesteren.nl/">Anne van Kesteren</a>
			    (<a href="http://www.opera.com/">Opera Software ASA</a>)
			    &lt;<a href="mailto:annevk@opera.com">annevk@opera.com</a>&gt;</dd>
		</dl>

		<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2006-2007
		   <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
		   (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>,
		   <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
		   <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
		   <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
		   and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
	</div>
	<hr>

	<h2 class="no-num no-toc" id="abstract">Abstract</h2>

	<p>Selectors, which are widely used in CSS, are patterns that match against
	   elements in a tree structure [<cite><a href="#ref-selectors">Selectors</a></cite>]
	   [<cite><a href="#ref-css21">CSS21</a></cite>]. The Selectors API
	   specification defines methods for retrieving <code>Element</code> nodes
	   from the <abbr title="Document Object Model">DOM</abbr> by matching
	   against a group of selectors. It is often desirable to perform DOM
	   operations on a specific set of elements in a document. These methods
	   simplify the process of acquiring specific elements, especially compared
	   with the more verbose techniques defined and used in the past.</p>

	<h2 class="no-num no-toc" id="sotd">Status of this Document</h2>

	<p><em>This section describes the status of this document at the time of its
	   publication. Other documents may supersede this document. A list of
	   current W3C publications and the latest revision of this technical report
	   can be found in the <a href="http://www.w3.org/TR/">W3C technical reports
	   index</a> at http://www.w3.org/TR/.</em></p>

	<p>This is a Last Call Working Draft of "Selectors API". The W3C Membership
	   and other interested parties are invited to review the document and send
	   comments to <a href="mailto:public-webapi@w3.org">public-webapi@w3.org</a>
	   (<a href="http://lists.w3.org/Archives/Public/public-webapi/">public archive</a>)
	   with <kbd>[selectors-api]</kbd> in the subject, through 06 January 2008.</p>

	<p><span class="notetoeditor">Web content and browser developers are
	   encouraged to review this draft. This draft is considered relatively
	   stable and is expected to progress to Candidate Recommendation after the
	   review period.</span> The editor’s copy of this specification is
	   <a href="http://dev.w3.org/2006/webapi/selectors-api/">available in W3C CVS</a>.
	   A detailed list of changes is also available
	   <a href="http://dev.w3.org/cvsweb/2006/webapi/selectors-api/">from the CVS server</a>.</p>

	<p>This document was developed by the
	   <a href="http://www.w3.org/2006/webapi">Web API Working Group</a>. The
	   Working Group expects to advance this Working Draft to Recommendation
	   Status.</p>

	<p>Publication as a Working Draft does not imply endorsement by the W3C
	   Membership. This is a draft document and may be updated, replaced or
	   obsoleted by other documents at any time. It is inappropriate to cite this
	   document as other than work in progress.</p>

	<p>This document was produced by a group operating under the
	   <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>.
	   W3C maintains a <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/38482/status">public list of any patent disclosures</a>
	   made in connection with the deliverables of the group; that page also
	   includes instructions for disclosing a patent. An individual who has
	   actual knowledge of a patent which the individual believes contains
	   <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a>
	   must disclose the information in accordance with
	   <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.

	<h2 class="no-num no-toc" id="toc">Table of Contents</h2>

	<!--toc-->

 	<h2 id="introduction">Introduction</h2>

	<p><em>This section is non-normative.</em></p>

	<p>This specification introduces two methods that take a group of selectors
	   (often simply referred to as a selector) as an argument and return the
	   matching elements [<cite><a href="#ref-selectors">Selectors</a></cite>].
	   With these methods, it is easier to match a set of <code>Element</code>
	   nodes based on specific criteria. So instead of having to filter the
	   result of a <code>getElementsByTagName()</code> call, authors can
	   directly “filter” in the query.</p>

	<h3 id="examples">Examples</h3>

	<p><em>This section is non-normative.</em></p>

	<p>Some ECMAScript [<cite><a href="#ref-ecma262">ECMAScript</a></cite>] examples:</p>
	<div class="example">
		<p>This is an example table written in HTML 4.01.</p>
		<pre>&lt;table id="score">
  &lt;thead>
    &lt;tr>
      &lt;th>Test
      &lt;th>Result
  &lt;tfoot>
    &lt;tr>
      &lt;th>Average
      &lt;td>82%
  &lt;tbody>
    &lt;tr>
      &lt;td>A
      &lt;td>87%
    &lt;tr>
      &lt;td>B
      &lt;td>78%
    &lt;tr>
      &lt;td>C
      &lt;td>81%
&lt;/table></pre>

		<p>In order to obtain the cells containing the results in the table, which 
		   might be done, for example, to plot the values on  a graph, there are at
		   least two approaches that may be taken.  Using only the APIs from DOM
		   Level 2, it requires a script like the following that iterates through
		   each <code>tr</code> within each <code>tbody</code> in the
		   <code>table</code> to find the second cell of each row.</p>

		<pre>var table = document.getElementById("score");
var groups = table.tBodies;
var rows = null;
var cells = [];

for (var i = 0; i &lt; groups.length; i++) {
  rows = groups[i].rows;
  for (var j = 0; j &lt; rows.length; j++) {
    cells.push(rows[j].cells[1]);
  }
}</pre>

		<p>Alternatively, using the <code title="document-selectallelements">querySelectorAll()</code>
		   method, that script becomes much more concise.</p>

		<pre>var cells = document.querySelectorAll("#score&gt;tbody&gt;tr&gt;td:nth-of-type(2)");</pre>

		<p>This script will also function correctly for a table written in XHTML
		   markup instead of HTML.</p>
	</div>

	<h3 id="conformance">Conformance Requirements</h3>

	<p>All diagrams, examples and notes in this specification are non-normative,
	   as are all sections explicitly marked non-normative. Everything else in
	   this specification is normative.</p>

	<p>The key words <em class="ct">must</em>, <em class="ct">should</em>, and
	   <em class="ct">may</em> in the normative parts of this document are to be
	   interpreted as described in RFC 2119
	   [<cite><a href="#ref-rfc2119">RFC2119</a></cite>].</p>

	<p>The following conformance classes are defined (and considered) by this
	   specification:</p>

	<dl>
		<dt><dfn>conforming user agent</dfn></dt>
		<dd>A user agent that implements the <code>DocumentSelector</code>,
		    <code>ElementSelector</code> and <code>NodeList</code> interfaces
		    described in this specification and conforms to all
		    <em class="ct">must</em>-level criteria that apply to
		    implementations.</dd>

		<dt><dfn>conforming namespace resolver</dfn></dt>
		<dd>An object implementing the <code>NSResolver</code> interface which
		    conforms to all <em class="ct">must</em>-level criteria that apply
		    to the <code>NSResolver</code> interface.</dd>

		<dt><dfn>conforming application</dfn></dt>
		<dd>An application that uses the interfaces defined in this
		    specification and conforms to all <em class="ct">must</em>-level
		    criteria that apply to applications.</dd>
	</dl>

	<h4 id="terminology">Terminology and Conventions</h4>

	<p>The terminology used in this specification is that from Selectors
	   [<cite><a href="#ref-selectors">Selectors</a></cite>].</p>

	<p>Conformance requirements phrased as algorithms or specific steps may be
	   implemented in any manner, so long as the end result is equivalent. In
	   doing so, implementations <em class="ct">may</em> assume that the
	   <code>lookupNamespaceURI()</code> method of the object
	   implementing the <code>NSResolver</code> interface (or ECMAScript
	   <code>Function</code> being used in place of such an object) returns
	   consistent results when invoked.</p>

	<p>The construction "<code>Foo</code> object", where <code>Foo</code> is
	   actually an interface, is sometimes used instead of the more accurate
	   "object implementing the <code>Foo</code> interface".</p>

	<h4 id="interoperability">Interoperability Considerations</h4>

	<p><em>This section is non-normative.</em></p>
	<p>Since implementations may optimise the algorithms described in this
	   specification, and because some may invoke the <code>NSResolver</code>
	   object more than others, interoperability concerns may arise if the
	   <code>NSResolver</code> object causes side effects or returns
	   inconsistent results each time it is invoked.</p>

	<div class="example">
		<p>In the following example, the <code>NSResolver</code> causes a side
		   effect when executed.</p>
		<pre>function resolver(prefix) {
  sideEffect();
  if (prefix == "test") {
    return "http://example.org/test";
  }
}

var x = document.querySelectorAll("test|*:empty > test|p", resolver)</pre>

		<p>Some implementations may not need to <span>resolve the namespace prefix</span>
		   in order to determine that the selector cannot match any elements, in
		   which case <code>sideEffect()</code> will  not be invoked.</p>
		<p>The following example could return inconsistent results each time it is
		   invoked, depending on the order in which namespace prefixes are resolved
		   and the number of times the resolver is invoked to for the
		   <code>foo</code> prefix.</p>

		<pre>var i = 0;
function resolver(prefix) {

  var ns = ["http://example.org/foo",
            "http://example.org/bar",
            "http://example.org/baz"];
  return ns[i++];
}

var x = document.querySelectorAll("foo|x, foo|y, bar|z", resolver);</pre>

		<p>This could result in selecting <code>x</code>, <code>y</code> and
		   <code>z</code> elements from almost any combination of namespaces that
		   may be returned. The result is unpredictable and different results may
		   occur in different implementations.</p>
	</div>

	<h4 id="extensibility">Extensibility</h4>

	<p><em>This section is non-normative.</em></p>

	<p>Extensions of the APIs defined in this specification are <em>strongly
	   discouraged</em>. Implementors, Working Groups and other interested
	   parties should discuss extensions on a relevant public forum, such as
	   <a href="mailto:public-webapi@w3.org">public-webapi@w3.org</a>.</p>

	<h3 id="security">Security Considerations</h3>

	<p>It is expected that implementing this specification introduces no new
	   security risks for users.</p>
	<p>Implementations <em class="ct">should</em> ensure they do not crash
	   or behave erratically when facing when facing a hostile <code>NSResolver</code>
	   object. Potentially hostile behaviour includes:</p>
	<ul>
		<li>Returning inconsistent results;</li>
		<li>Hanging;</li>
		<li>Changing the DOM during the operation.</li>
	</ul>

	<h3 id="privacy">Privacy Considerations </h3>

	<p>History theft is a potential privacy issue because the <code>:visited</code>
	   pseudo-class in Selectors [<cite><a href="#ref-selectors">Selectors</a></cite>]
	   allows authors to query which links have been visited.</p>
	<p class="note">This is not a new problem, as it can already be exploited
	   using existing CSS and DOM APIs, such as <code>getComputedStyle()</code>
	   [<cite><a href="#ref-dom2style">DOM2Style</a></cite>].</p>

	<div class="example">
		<p>In this example, <var>vlinks</var> will acquire a list of links that
		   the user has visited. The author can then obtain the URIs and
		   potentially exploit this knowledge.</p>
		<pre>var vlinks = document.querySelectorAll(":visited");
for (var i = 0; i &lt; vlinks.length; i++) {
  doSomethingEvil(vlinks[i].href);
}</pre>

	</div>

	<p>As <a href="http://www.w3.org/TR/css3-selectors/#link">defined in <cite>Selectors</cite></a>
	   ([<cite><a href="#ref-selectors">Selectors</a></cite>], section 6.6.1),
	   user agents <em class="ct">may</em> treat all links as unvisited links,
	   or implement other measures to preserve the user’s privacy.</p>

	<h2 id="documentselector">The <code title="">querySelector()</code> and	<code title="">querySelectorAll()</code> Methods</h2>

	<p>Objects implementing the <code>Document</code> interface, as defined in
	   DOM Level 3 Core, <em class="ct">must</em> also implement the
	   <code>DocumentSelector</code> interface. Likewise objects implementing
	   the <code>Element</code> interface, as defined in DOM Level 3 Core,
	   <em class="ct">must</em> also implement the <code>ElementSelector</code>
	   interface. [<cite><a href="#ref-dom3core">DOM3Core</a></cite>]</p>

	<pre class="idl">interface <dfn id="dom-document-selector">DocumentSelector</dfn> {
  Element   <span title="document-selectelement">querySelector</span>(in DOMString selectors);
  Element   <span title="document-selectelement">querySelector</span>(in DOMString selectors, in <span>NSResolver</span> nsresolver);
  <span>NodeList</span>  <span title="document-selectallelements">querySelectorAll</span>(in DOMString selectors);
  <span>NodeList</span>  <span title="document-selectallelements">querySelectorAll</span>(in DOMString selectors, in <span>NSResolver</span> nsresolver);
};

interface <dfn id="dom-element-selector">ElementSelector</dfn> {
  Element   <span title="element-selectelement">querySelector</span>(in DOMString selectors);
  Element   <span title="element-selectelement">querySelector</span>(in DOMString selectors, in <span>NSResolver</span> nsresolver);
  <span>NodeList</span>  <span title="element-selectallelements">querySelectorAll</span>(in DOMString selectors);
  <span>NodeList</span>  <span title="element-selectallelements">querySelectorAll</span>(in DOMString selectors, in <span>NSResolver</span> nsresolver);
};</pre>

	<p>The term <dfn>first</dfn> used in the definitions of the
	   <code>querySelector</code> methods means <em>first in document order</em>.
	   The term <dfn>document order</dfn> means a depth-first pre-order traversal
	   of the DOM tree or subtree in question. The term <dfn>element’s subtree</dfn>
	   refers to the tree of elements that are descendants of the element upon
	   which the method was invoked. The term <dfn>matching <code>Element</code>
	   node</dfn> refers to an <code>Element</code> node that matches the group
	   of selectors (<var>selectors</var>) that was passed to the method.</p>

	<p>The <dfn id="document-selectelement" title="document-selectelement"><code>querySelector()</code></dfn>
	   methods on the <code>DocumentSelector</code> interface <em class="ct">must</em>,
	   when invoked, return the first matching <code>Element</code> node within
	   the document. If there is no such node, the methods <em class="ct">must</em>
	   return <code>null</code>.</p>

	<p>The <dfn id="element-selectelement" title="element-selectelement"><code>querySelector()</code></dfn>
	   methods on the <code>ElementSelector</code> interface <em class="ct">must</em>,
	   when invoked, return the first matching <code>Element</code> node within
	   the element’s subtree. If there is no such node, the methods <em class="ct">must</em>
	   return <code>null</code>.</p>

	<p>The <dfn id="document-selectallelements" title="document-selectallelements"><code>querySelectorAll()</code></dfn>
	   methods on the <code>DocumentSelector</code> interface <em class="ct">must</em>,
	   when invoked, return a <code>NodeList</code> containing all of the
	   matching <code>Element</code> nodes within the document, in document order.
	   If there are no such nodes, the methods <em class="ct">must</em> return an empty
	   <code>NodeList</code>.</p>

	<p>The <dfn id="element-selectallelements" title="element-selectallelements"><code>querySelectorAll()</code></dfn>
	   methods on the <code>ElementSelector</code> interface <em class="ct">must</em>,
	   when invoked, return a <code>NodeList</code> containing all of the
	   matching <code>Element</code> nodes with the element’s subtree, in document order.
	   If there are no such nodes, the methods <em class="ct">must</em> return an empty
	   <code>NodeList</code>.</p>

	<p>The <code>NodeList</code> object returned by the <code>querySelectorAll()</code>
	   methods <em class="ct">must</em> be static, not
	   <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#td-live" title="Document Object Model Core">live</a>.
	   ([<cite><a href="#ref-dom3core">DOM3Core</a></cite>], section 1.1.1)
	   Subsequent changes to the structure of the underlying document
	   <em class="ct">must not</em> be reflected in the <code>NodeList</code>
	   object. This means that the object will instead contain a list of
	   matching <code>Element</code> nodes that were in the document at the time
	   the list was created.</p>

	<p>Both <code title="document-selectelement">querySelector()</code> and
	   <code title="document-selectallelements">querySelectorAll()</code> take
	   a group of selectors (<var>selectors</var>) as the first argument and
	   optionally an <code>NSResolver</code> (<var title="">nsresolver</var>) as
	   the second.  The implementation must process the <var title="">selectors</var>
	   according to <a href="http://www.w3.org/TR/css3-selectors/#w3cselgrammar">the grammar of Selectors</a>
	   ([<cite><a href="#ref-selectors">Selectors</a></cite>], section 10). If
	   the user agent also supports some level of CSS, the implementation
	   <em class="ct">must</em> support the same set of selectors in both these
	   APIs and CSS.</p>

	<p class="note">Authors are advised that while the use of pseudo-elements
	   in selectors is permitted, they will not match any elements in the
	   document, and thus would not result in any elements being returned.
	   Therefore, authors should avoid the use pseudo-elements in selectors that
	   are passed to the methods defined in this specification.</p>

	<p>Implementations <em class="ct">must</em> use the <var title="">nsresolver</var>
	   argument to <span>get the default namespace</span> for the group of 
	   selectors and, if the selectors include namespace prefixes, the
	   implementation must also use it to <span title="resolve-prefixes">resolve those prefixes</span>.

	<p>If the group of selectors uses namespace prefixes, or if the default
	   namespace for the group of selectors is not the <code>null</code>
	   namespace, the caller <em class="ct">must</em> pass in an
	   <code>NSResolver</code> object. Otherwise, the caller <em class="ct">may</em>
	   set the argument to <code>null</code> or omit it if the language binding
	   permits.</p>

	<p>If the given group of selectors is <a href="http://www.w3.org/TR/css3-selectors/#Conformance">invalid</a>
	   ([<cite><a href="#ref-selectors">Selectors</a></cite>], section 13), the
	   implementation <em class="ct">must</em>
	   <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMException-SYNTAX_ERR">raise a <code>SYNTAX_ERR</code> exception</a>
	   ([<cite><a href="#ref-dom3core">DOM3Core</a></cite>], section 1.4).</p>

	<p>An <dfn>unresolvable namespace</dfn> is a namespace that cannot be
	   resolved because there was no <code>NSResolver</code> provided or the
	   given <code>NSResolver</code> returns an empty string
	   (<a href="#convert-value">or equivalent</a>) for a prefix. When an
	   <span>unresolvable namespace</span> is encountered, the implementation
	   <em class="ct">must</em>
	   <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMException-NAMESPACE_ERR">raise a <code>NAMESPACE_ERR</code> exception</a>
	   ([<cite><a href="#ref-dom3core">DOM3Core</a></cite>], section 1.4).</p>

	<p class="note">Unresolvable namespaces can only occur for namespace
	   prefixes. The default namespace will always resolve as either the null
	   namespace or the value returned by the <code>NSResolver</code>.</p>

	<p>If an exception is raised by the <code>NSResolver</code> while resolving
	   namespaces, processing <em class="ct">must</em> be aborted and the
	   exception propagated to the caller.</p>

	<p>For languages that support optional arguments for methods, such as
	   ECMAScript, if the <var title="">nsresolver</var> argument is omitted,
	   the implementation <em class="ct">must</em> act as if the
	   <var title="">nsresolver</var> argument was set to <code>null</code>.</p>

	<div class="example">
		<p>The methods accept a group of selectors (comma separated) as the
		   argument. The following example would select all <code>p</code>
		   elements in the document that have a class of either
		   "<code>error</code>" or "<code>warning</code>".</p>

		<pre>var alerts = document.querySelectorAll("p.warning, p.error");</pre>

		<p>The <code title="document-selectelement">querySelector()</code>
		   methods also accept a group of selectors and they will return the
		   first element (if any) that matches any of the selectors in the
		   group.</p>

		<pre>var x = document.querySelector("#foo, #bar");</pre>

		<p><var>x</var> would contain the first element in the document with an
		   ID of either <code>foo</code> or <code>bar</code> (or both).</p>

		<p>The methods can also be invoked on elements. In this example, the
		   method is invoked on an element that is the target of an event
		   listener.</p>

		<pre>function handle(evt) {
  var x = evt.target.querySelector("span");
  ...
  // Do something with x
}</pre>
	</div>

	<h3 id="nsresolver-interface">The <code title="">NSResolver</code> Interface</h3>

	<p>The <code>NSResolver</code> interface allows prefixes to be bound to a
	   namespace URI.</p>

	<pre class="idl">interface <dfn>NSResolver</dfn> {
  DOMString       <span>lookupNamespaceURI</span>(in DOMString prefix);
};</pre>

	<p class="note">The object implementing this interface is expected to be
	   implemented by applications. Other specifications may introduce methods
	   that return an object implementing the <code>NSResolver</code> interface,
	   in which case it would be implemented by the user agent. When the object
	   is implemented by the application, some conformance requirements are
	   relaxed in order to make it easier for authors to write a conforming
	   implementation.</p>

	<p>When the <code>lookupNamespaceURI()</code> method is invoked, the
	   implementation <em class="ct">must</em> perform the following
	   algorithm:</p>

	<ul>
		<li>If the given prefix is an empty string, then:
			<ul>
				<li>If there is a default namespace, return the default
				    namespace URI.</li>
				<li>If there is no default namespace, return an empty
				    string.</li>
			</ul>
		</li>
		<li>Otherwise, look up the namespace URI associated with the given
		    prefix and:
			<ul>
				<li>If the prefix has an associated namespace URI, return the
				    URI.</li>
				<li>If the prefix has no associated namespace URI, return an
				    empty string.</li>
			</ul>
		</li>
	</ul>

	<p>If the <code>lookupNamespaceURI()</code> method is passed a value of
	   <code>null</code> or <code>undefined</code>, then the implementation
	   <em class="ct">must</em> act as if an empty string had been passed
	   instead. If the method is passed an object other than a string, the
	   object <em class="ct">must</em> be converted to a string and the
	   implementation <em class="ct">must</em> act as if the resulting string
	   had been passed instead. The method to convert an object to a string is
	   dependent upon the language used. For example, in ECMAScript, this is
	   achieved by invoking the <code>toString()</code> method on the
	   object.</p>

	<p>If the <code>NSResolver</code> object is implemented by the application
	   instead of the user agent, then, where the algorithm says to return an
	   empty string, the implementation <em class="ct">may</em> return
	   <code>null</code> or <code>undefined</code> instead. Additionally, the
	   implementation is not required to handle being passed <code>null</code>,
	   <code>undefined</code> or non-string objects as the prefix parameter.</p>

	<p>The <code>lookupNamespaceURI()</code> <em class="ct">must</em> return
	   consistent results each time it is invoked.</p>

	<p class="note">Authors are <em>strongly discouraged</em> from writing an
	   <code>NSResolver</code> that returns inconsistent results.</p>

	<p>To <dfn title="resolve-prefixes">resolve namespace prefixes</dfn>, if there was an <code>NSResolver</code>
	   object provided, implementations <em class="ct">must</em> pass the
	   prefix, preserving case, to the <code>lookupNamespaceURI()</code> method.
	   Implementations <em class="ct">must</em> handle prefixes case
	   sensitively. If there was no <code>NSResolver</code> object provided, or
	   if the method returns an empty string, the prefix represents an
	   <span>unresolvable namespace</span>. Otherwise, the return value is the
	   namespace for the given prefix.</p>





	<p class="note">Although prefixes are case sensitive, there are no
	   restrictions imposed by this specification on how the implementation of
	   the <code>NSResolver</code> object may handle them internally. Thus,
	   while the resolver may handle them case insensitively, such an approach
	   is effectively the same as declaring all case variants of the prefix with
	   the same namespace URI.</p>






	<p>To <dfn>get the default namespace</dfn>, if there was an <code>NSResolver</code>
	   object provided, implementations <em class="ct">must</em> invoke the
	   <code>lookupNamespaceURI()</code> method with the empty string as the
	   argument. If there is no <code>NSResolver</code> object provided, or if
	   the method returns an empty string, then there is no default namespace.
	   Otherwise, the return value is the default namespace.</p>

	<p id="convert-value">While resolving either a prefix or the default
	   namespace, if the <code>lookupNamespaceURI()</code> method returns
	   <code>undefined</code> or <code>null</code>, the implementation
	   <em class="ct">must</em> act as if an empty string had been returned.
	   If the method returns an object other than a string, the object
	   <em class="ct">must</em> be converted to a string and the
	   implementation must act as if the resulting string had been returned
	   instead. The method to convert an object to a string is dependent upon
	   the language used. For example, in ECMAScript, this is achieved by
	   invoking the <code>toString()</code> method on the object.</p>

	<p>For ECMAScript, this object <em class="ct">may</em> be implemented as a
	   <code>Function</code> and implementations <em class="ct">must</em>
	   support the <code>NSResolver</code> being implemented as either a
	   <code>Function</code> or an <code>Object</code>. In the algorithms to
	   <span>resolve namespace prefixes</span> or to <span>get the default
	   namespace</span>, if the implementation is passed a <code>Function</code>
	   instead of an object implementing the <code>NSResolver</code> interface,
	   it must instead invoke the function itself instead of the
	   <code>lookupNamespaceURI()</code> method.</p>

	<p>The number of times that an implementation <em class="ct">may</em> invoke
	   the <code>lookupNamespaceURI()</code> method with each prefix and the
	   order in which prefixes are resolved is not defined by this
	   specification.</p>

	<div class="example">
		<p>The following examples make use of this sample document.</p>
		<pre>&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:svg="http://www.w3.org/2000/svg"
      xml:lang="en">
  &lt;head>
    &lt;title&gt;Selectors API Example&lt;/title&gt;
  &lt;/head>
  &lt;body>
    &lt;div>&lt;svg:svg … > … &lt;/svg:svg>&lt;/div&gt;
    &lt;p>&lt;svg:svg … > … &lt;/svg:svg>&lt;/p&gt;
    &lt;p>&lt;svg xmlns="http://www.w3.org/2000/svg" … > … &lt;/svg>&lt;/p>
  &lt;/body>
&lt;/html></pre>

		<p>The <code>NSResolver</code> may be implemented as an object with a
		   <code>lookupNamespaceURI</code> method.</p>

		<pre>var resolver = {
  lookupNamespaceURI: function(prefix) {
    var ns = {
      "xh"  :"http://www.w3.org/1999/xhtml",
      "xbl" :"http://www.w3.org/ns/xbl",
      "svg" :"http://www.w3.org/2000/svg",
      "math":"http://www.w3.org/1998/Math/MathML"
    };
    return ns[prefix];
  }
}</pre>

		<p>For convenience, in ECMAScript, the <code>NSResolver</code> may also
		   be implemented as a function. In the above example, namespace 
		   prefixes are resolved case sensitively. If case insensitive namespace
		   prefixes are desired, it is possible to implement this in the
		   resolver by altering the case of the prefix before comparison.</p>

		<pre>function resolver(prefix) {
  var ns = {
    "xh"  :"http://www.w3.org/1999/xhtml",
    "xbl" :"http://www.w3.org/ns/xbl",
    "svg" :"http://www.w3.org/2000/svg",
    "math":"http://www.w3.org/1998/Math/MathML"
  };
  return ns[prefix.toLowerCase()];
}

var svgImages = document.querySelectorAll("xh|p SVG|svg", resolver);</pre>

		<p class="note">This is not a proper implementation of caseless matching
		   in Unicode, which requires both strings that are being compared to be
		   case folded prior to performing a binary comparison
		   [<cite><a href="#ref-casemap">CaseMap</a></cite>].
		   However, this is a sufficient approximation for prefixes that are
		   restricted to characters, such as those in the US-ASCII subset, for
		   which simply converting both strings to lowercase and comparing
		   returns the correct result. If desired, an implementation of the
		   full case mapping algorithm is left as an exersise for the
		   reader.</p>

		<p>Using the case insensitive namespace resolver, the prefix <code>xh</code>
		   will be resolved as <code>http://www.w3.org/1999/xhtml</code> and
		   <code>SVG</code> as <code>http://www.w3.org/2000/svg</code>. The
		   <var>svgImages</var> variable will be a <code>NodeList</code>
		   containing the two <code>svg</code> elements that are descendents of
		   the <code>p</code> elements.</p>

		<p>The default namespace can be specified so that prefixes do not need
		   to be used for selecting elements in a specific namespace. In the
		   following example, the default namespace has been set to the XHTML
		   namespace.</p>

		<pre>function resolver(prefix) {
  var ns = {
    ""    :"http://www.w3.org/1999/xhtml", // Default namespace
    "xbl" :"http://www.w3.org/ns/xbl",
    "svg" :"http://www.w3.org/2000/svg",
    "math":"http://www.w3.org/1998/Math/MathML"
  };
  return ns[prefix];
}</pre>

		<p>Using this resolver, the previous example can be rewritten without
		   explicitly declaring the XHTML namespace using the <code>xh</code>
		   prefix.</p>

		<pre>var svgImages = document.querySelectorAll("p svg|svg", resolver);</pre>

		<p>In the following example, the <code>foo</code> namespace is undefined
		   and will result in an unresolvable namespace. The <code>NAMESPACE_ERR</code>
		   exception can be handled using a <code>try</code>/<code>catch</code>
		   block.</p>

		<pre>try {
  document.querySelectorAll("foo|bar", resolver);
} catch (e) {
  switch (e.code) {
  case DOMException.NAMESPACE_ERR:
    // Namespace error
    break;
  case DOMException.SYNTAX_ERR:
    // Syntax error
    break;
  default:
    // Unknown error
  }
}</pre>

		<p>This example demonstrates how to iterate through the items in a
		   <code>NodeList</code>.</p>

		<pre>var lis = document.querySelectorAll("ul.nav&gt;li");
for (var i = 0; i &lt; lis.length; i++) {
  process(lis.item(i));
}</pre>

		<p>In ECMAScript, the language binding also allows <code>NodeList</code>s
		   and to be addressed using the array notation, so that loop could be
		   rewritten like this:</p>

		<pre>for (var i = 0; i &lt; lis.length; i++) {
  process(lis[i]);
}</pre>

		<p>Since the <code>NodeList</code> objects returned by these methods are
		   not live, changes to the DOM do not affect the content of the list.
		   Consider the <code>process()</code> function called in the previous
		   examples is defined as follows:</p>

		<pre>function process(elmt) {
  elmt.parentNode.removeChild(elmt);
}</pre>

		<p>This would cause each selected element to be removed from the DOM,
		   but each element will remain in the <code>NodeList</code>. If the
		   list were a live <code>NodeList</code>, removing an item from the
		   DOM would also remove the element from the list and adjust the
		   indexes of subsequent elements. That would have adverse effects upon
		   the loop because not all selected elements would be processed.</p>
	</div>

	<h2 class="no-num" id="references">References</h2>
	<dl>
		<dt id="ref-casemap">[CaseMap]</dt>
		<dd>(Non-normative) <cite><a href="http://unicode.org/reports/tr21/tr21-5.html">Unicode Standard Annex #21 Case Mappings</a></cite>,
		    M. Davis, editor. Unicode Consortium, March 2001.</dd>

		<dt id="ref-css21">[CSS21]</dt>
		<dd>(Non-normative) <cite><a href="http://www.w3.org/TR/CSS21">Cascading Style Sheets, level 2 revision 1</a></cite>,
		    B. Bos, T. Çelik, I. Hickson, H. Wium Lie, editors. World Wide Web
		    Consortium, June 2005.

		<dt id="ref-dom2style">[DOM2Style]</dt>
		<dd>(Non-normative) <cite><a href="http://www.w3.org/TR/DOM-Level-2-Style/">Document Object Model (DOM) Level 2 Style Specification</a></cite>,
		    C. Wilson, P. Le Hégaret, V. Apparao, editors. World Wide Web 
		    Consortium, November 2000.</dd>

		<dt id="ref-dom3core">[DOM3Core]</dt>
		<dd><cite><a href="http://www.w3.org/TR/DOM-Level-3-Core">Document Object Model (DOM) Level 3 Core Specification</a></cite>,
		    A. Le Hors, P. Le Hégaret, L. Wood, G. Nicol, J. Robie, M. Champion,
		    S. Byrne, editors. World Wide Web Consortium, April 2004.</dd>

		<dt id="ref-ecma262">[ECMAScript]</dt>
		<dd><cite><a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript Language Specification</a></cite>,
		    Third Edition. ECMA, December 1999.</dd>

		<dt id="ref-rfc2119">[RFC2119]</dt>
		<dd><cite><a href="http://ietf.org/rfc/rfc2119">RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
		    S. Bradner. IETF, March 1997.</dd>

		<dt id="ref-selectors">[Selectors]</dt>
		<dd><cite><a href="http://www.w3.org/TR/css3-selectors">Selectors</a></cite>,
		    D. Glazman, T. Çelik, I. Hickson, P. Linss, J. Williams, editors.
		    World Wide Web Consortium, December 2005.</dd>
	</dl>

	<h2 class="no-num" id="acknowledgements">Acknowledgements</h2>

	<p>The editor would like to thank to the following people who have
	   contributed to this specification (ordered on first name):</p>

	<ul>
		<li>Alex Russell</li>
		<li>Björn Höhrmann</li>
		<li>Boris Zbarsky</li>
		<li>Cameron McCormack</li>
		<li>Charles McCathieNevile</li>
		<li>Chris Wilson</li>
		<li>Daniel Schierbeck</li>
		<li>Dave Massy</li>
		<li>David Håsäther</li>
		<li>Dean Jackson</li>
		<li>Erik Dahlström</li>
		<li>Ian Hickson</li>
		<li>Jim Ley</li>
		<li>Jonas Sicking</li>
		<li>Jorgen Horstink</li>
		<li>Karl Dubost</li>
		<li>Maciej Stachowiak</li>
		<li>Mohamed Zergaoui</li>
		<li>Philip Taylor</li>
		<li>Robert Sayre</li>
		<li>Robin Berjon</li>
		<li>Simon Pieters</li>
		<li>Steven Pemberton</li>
		<li>Tarquin Wilton-Jones</li>
		<li>Travis Leithead</li>
	</ul>

	<p>Thanks to all those who have helped to improve this specification by
	   sending suggestions and corrections. (Please, keep bugging us with your
	   issues!)</p>
</body>
</html>
